export * from './string.js';
export * from './guards.js';
export * from './object/index.js';
export * from './promise.js';
export * from './time.js';
export * from './NoopTracer.js';
export * from './set.js';
export * from './browser.js';
export * from './Deferred.js';
export * from './misc.js';
export * from './env.js';
export * from './fast-deep-equal.js';
export * as base64 from './base64.js';
export { default as prettyBytes } from 'pretty-bytes';
import type * as otel from '@opentelemetry/api';
import type { Types } from 'effect';
export type Prettify<T> = T extends infer U ? {
    [K in keyof U]: Prettify<U[K]>;
} : never;
export type TypeEq<A, B> = (<T>() => T extends A ? 1 : 2) extends <T>() => T extends B ? 1 : 2 ? true : false;
/** `A` is subtype of `B` */
export type IsSubtype<A, B> = A extends B ? true : false;
export type AssertTrue<T extends true> = T;
export type Writeable<T> = {
    -readonly [P in keyof T]: T[P];
};
export type DeepWriteable<T> = {
    -readonly [P in keyof T]: DeepWriteable<T[P]>;
};
export type Nullable<T> = {
    [K in keyof T]: T[K] | null;
};
export type Primitive = null | undefined | string | number | boolean | symbol | bigint;
export type LiteralUnion<LiteralType, BaseType extends Primitive> = LiteralType | (BaseType & Record<never, never>);
export type GetValForKey<T, K> = K extends keyof T ? T[K] : never;
export type SingleOrReadonlyArray<T> = T | ReadonlyArray<T>;
export declare const sleep: (ms: number) => Promise<unknown>;
export declare const ref: <T>(val: T) => {
    current: T;
};
export declare const times: (n: number, fn: (index: number) => {}) => void;
export declare const debugCatch: <T>(try_: () => T) => T;
export declare const recRemoveUndefinedValues: (val: any) => void;
export declare const prop: <T extends {}, K extends keyof T>(key: K) => (obj: T) => T[K];
export declare const capitalizeFirstLetter: (str: string) => string;
export declare const isReadonlyArray: <I, T>(value: ReadonlyArray<I> | T) => value is ReadonlyArray<I>;
/**
 * Use this to make assertion at end of if-else chain that all members of a
 * union have been accounted for.
 */
export declare function casesHandled(unexpectedCase: never): never;
export declare const assertNever: (failIfFalse: boolean, msg?: string) => void;
export declare const debuggerPipe: <T>(val: T) => T;
export declare const notYetImplemented: (msg?: string) => never;
export declare const noop: () => void;
export type Thunk<T> = () => T;
export declare const unwrapThunk: <T>(_: T | (() => T)) => T;
export type NullableFieldsToOptional<T> = Types.Simplify<Partial<T> & {
    [K in keyof T as null extends T[K] ? K : never]?: Exclude<T[K], null>;
} & {
    [K in keyof T as null extends T[K] ? never : K]: T[K];
}>;
/** `end` is not included */
export declare const range: (start: number, end: number) => number[];
export declare const throttle: (fn: () => void, ms: number) => () => void;
export declare const getTraceParentHeader: (parentSpan: otel.Span) => string;
export declare const assertTag: <TObj extends {
    _tag: string;
}, TTag extends TObj["_tag"]>(obj: TObj, tag: TTag) => Extract<TObj, {
    _tag: TTag;
}>;
export declare const memoizeByStringifyArgs: <T extends (...args: any[]) => any>(fn: T) => T;
export declare const memoizeByRef: <T extends (arg: any) => any>(fn: T) => T;
export declare const isNonEmptyString: (str: string | undefined | null) => str is string;
export declare const isPromise: (value: any) => value is Promise<unknown>;
export declare const isIterable: <T>(value: any) => value is Iterable<T>;
export { objectToString as errorToString } from './misc.js';
//# sourceMappingURL=index.d.ts.map