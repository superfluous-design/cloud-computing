import { Array, Effect, STM, TRef } from 'effect';
export const make = () => TRef.make([]);
export const offerAll = (self, elements) => TRef.update(self, (bucket) => Array.appendAll(bucket, elements));
export const replace = (self, elements) => TRef.set(self, elements);
export const clear = (self) => TRef.set(self, []);
export const takeBetween = (bucket, min, max) => STM.gen(function* () {
    const bucketValue = yield* TRef.get(bucket);
    if (bucketValue.length < min) {
        return yield* STM.retry;
    }
    else {
        const elements = bucketValue.splice(0, Math.min(max, bucketValue.length));
        yield* TRef.set(bucket, bucketValue);
        return elements;
    }
});
export const peekAll = (bucket) => TRef.get(bucket);
/** Returns the elements up to the first element that matches the predicate, the rest is left in the queue
 *
 * @example
 * ```ts
 * const [elements, rest] = yield* BucketQueue.takeSplitWhere(bucket, (a) => a > 3)
 * assert.deepStrictEqual(elements, [1, 2, 3])
 * assert.deepStrictEqual(rest, [4, 5, 6])
 * ```
 */
export const takeSplitWhere = (bucket, predicate) => STM.gen(function* () {
    const bucketValue = yield* TRef.get(bucket);
    const [elements, rest] = Array.splitWhere(bucketValue, predicate);
    yield* TRef.set(bucket, rest);
    return elements;
});
export const size = (bucket) => TRef.get(bucket).pipe(Effect.map((_) => _.length));
//# sourceMappingURL=BucketQueue.js.map