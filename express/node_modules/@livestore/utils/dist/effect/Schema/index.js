import { Transferable } from '@effect/platform';
import { Effect, Hash, ParseResult, Schema } from 'effect';
import { shouldNeverHappen } from '../../index.js';
export * from 'effect/Schema';
export * from './debug-diff.js';
export * from './msgpack.js';
// NOTE this is a temporary workaround until Effect schema has a better way to hash schemas
// https://github.com/Effect-TS/effect/issues/2719
// TODO remove this once the issue is resolved
export const hash = (schema) => {
    try {
        return Hash.string(JSON.stringify(schema.ast, null, 2));
    }
    catch {
        console.warn(`Schema hashing failed, falling back to hashing the shortend schema AST string. This is less reliable and may cause false positives.`);
        return Hash.hash(schema.ast.toString());
    }
};
export const encodeWithTransferables = (schema, options) => (a, overrideOptions) => Effect.gen(function* () {
    const collector = yield* Transferable.makeCollector;
    const encoded = yield* Schema.encode(schema, options)(a, overrideOptions).pipe(Effect.provideService(Transferable.Collector, collector));
    return [encoded, collector.unsafeRead()];
});
export const decodeSyncDebug = (schema, options) => (input, overrideOptions) => {
    const res = Schema.decodeEither(schema, options)(input, overrideOptions);
    if (res._tag === 'Left') {
        return shouldNeverHappen(`decodeSyncDebug failed:`, res.left);
    }
    else {
        return res.right;
    }
};
export const encodeSyncDebug = (schema, options) => (input, overrideOptions) => {
    const res = Schema.encodeEither(schema, options)(input, overrideOptions);
    if (res._tag === 'Left') {
        return shouldNeverHappen(`encodeSyncDebug failed:`, res.left);
    }
    else {
        return res.right;
    }
};
export const swap = (schema) => Schema.transformOrFail(Schema.typeSchema(schema), Schema.encodedSchema(schema), {
    decode: ParseResult.encode(schema),
    encode: ParseResult.decode(schema),
});
export const Base64FromUint8Array = swap(Schema.Uint8ArrayFromBase64);
export const JsonValue = Schema.Union(Schema.String, Schema.Number, Schema.Boolean, Schema.Null, Schema.Array(Schema.suspend(() => JsonValue)), Schema.Record({ key: Schema.String, value: Schema.suspend(() => JsonValue) })).annotations({ title: 'JsonValue' });
//# sourceMappingURL=index.js.map