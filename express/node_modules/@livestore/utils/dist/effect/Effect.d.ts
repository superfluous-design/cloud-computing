import type { Context, Duration, Stream } from 'effect';
import { Deferred, Effect, Scope } from 'effect';
import type { UnknownException } from 'effect/Cause';
import type { LazyArg } from 'effect/Function';
export * from 'effect/Effect';
/** Same as `Effect.scopeWith` but with a `CloseableScope` instead of a `Scope`. */
export declare const scopeWithCloseable: <R, E, A>(fn: (scope: Scope.CloseableScope) => Effect.Effect<A, E, R | Scope.Scope>) => Effect.Effect<A, E, R | Scope.Scope>;
export declare const tryAll: <Res>(fn: () => Res) => Res extends Effect.Effect<infer A, infer E, never> ? Effect.Effect<A, E | UnknownException, never> : Res extends Promise<infer A> ? Effect.Effect<A, UnknownException, never> : Effect.Effect<Res, UnknownException, never>;
export declare const acquireReleaseLog: (label: string) => Effect.Effect<void, never, Scope.Scope>;
export declare const addFinalizerLog: (...msgs: any[]) => Effect.Effect<void, never, Scope.Scope>;
export declare const logBefore: (...msgs: any[]) => <A, E, R>(eff: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;
/** Logs both on errors and defects */
export declare const tapCauseLogPretty: <R, E, A>(eff: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;
export declare const eventListener: <TEvent = unknown>(target: Stream.EventListener<TEvent>, type: string, handler: (event: TEvent) => Effect.Effect<void, never, never>, options?: {
    once?: boolean;
}) => Effect.Effect<void, never, Scope.Scope>;
export declare const spanEvent: (message: any, attributes?: Record<string, any>) => Effect.Effect<void, never, never>;
export declare const logWarnIfTakesLongerThan: ({ label, duration }: {
    label: string;
    duration: Duration.DurationInput;
}) => <R, E, A>(eff: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;
export declare const logDuration: (label: string) => <R, E, A>(eff: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;
export declare const tapSync: <A>(tapFn: (a: A) => unknown) => <R, E>(eff: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;
export declare const debugLogEnv: (msg?: string) => Effect.Effect<Context.Context<never>>;
export declare const timeoutDie: <E1>(options: {
    onTimeout: LazyArg<E1>;
    duration: Duration.DurationInput;
}) => <R, E, A>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;
export declare const timeoutDieMsg: (options: {
    error: string;
    duration: Duration.DurationInput;
}) => <R, E, A>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;
export declare const toForkedDeferred: <R, E, A>(eff: Effect.Effect<A, E, R>) => Effect.Effect<Deferred.Deferred<A, E>, never, R | Scope.Scope>;
export declare const withPerformanceMeasure: (meaureLabel: string) => <R, E, A>(eff: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;
//# sourceMappingURL=Effect.d.ts.map