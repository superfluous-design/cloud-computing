import type { Runtime } from 'effect';
import { Effect, Exit, Layer } from 'effect';
export interface MainLayer<Ctx> {
    layer: Layer.Layer<Ctx>;
    close: Effect.Effect<void>;
}
export declare const unsafeMainLayer: <Ctx>(original: Layer.Layer<Ctx>) => MainLayer<Ctx>;
export declare const make: <TStaticData, Ctx>(staticData: TStaticData, runtime: Runtime.Runtime<Ctx>, close?: Effect.Effect<void>) => ServiceContext<Ctx, TStaticData>;
export interface ServiceContext<Ctx, TStaticData> {
    readonly provide: <E, A>(self: Effect.Effect<A, E, Ctx>) => Effect.Effect<A, E>;
    /**
     * Fire and Forget. Errors are logged however.
     */
    readonly runWithErrorLog: <E, A>(self: Effect.Effect<A, E, Ctx>) => AbortCallback;
    readonly runSync: <E, A>(self: Effect.Effect<A, E, Ctx>) => A;
    /**
     * Fire and Forget. A promise that never fails nor returns any value.
     * Errors are logged however.
     */
    readonly runPromiseWithErrorLog: <E, A>(self: Effect.Effect<A, E, Ctx>) => Promise<A | undefined>;
    /**
     * A Promise that never fails, the Resolved value is an Exit result that can be either Success or Failed
     */
    readonly runPromiseExit: <E, A>(self: Effect.Effect<A, E, Ctx>) => Promise<Exit.Exit<A, E>>;
    readonly runPromise: <E, A>(self: Effect.Effect<A, E, Ctx>) => Promise<A>;
    readonly withRuntime: (fn: (runtime: Runtime.Runtime<Ctx>) => void) => void;
    /** Closes the ServiceContext and closing all its layers */
    readonly close: Effect.Effect<void>;
    readonly closePromise: () => Promise<void>;
    readonly staticData: TStaticData;
}
export type AbortCallback = () => void;
export declare const runWithErrorLog: <E, A>(self: Effect.Effect<A, E>) => () => void;
export declare const runPromiseWithErrorLog: <E, A>(self: Effect.Effect<A, E>) => Promise<A | undefined>;
export declare const MissingContext: Effect.Effect<never, never, never>;
export declare const empty: <Ctx, TStaticData>() => ServiceContext<Ctx, TStaticData>;
//# sourceMappingURL=ServiceContext.d.ts.map