import { Effect, STM, TRef } from 'effect';
export type BucketQueue<A> = TRef.TRef<A[]>;
export declare const make: <A>() => STM.STM<BucketQueue<A>>;
export declare const offerAll: <A>(self: BucketQueue<A>, elements: ReadonlyArray<A>) => STM.STM<void, never, never>;
export declare const replace: <A>(self: BucketQueue<A>, elements: ReadonlyArray<A>) => STM.STM<void, never, never>;
export declare const clear: <A>(self: BucketQueue<A>) => STM.STM<void, never, never>;
export declare const takeBetween: <A>(bucket: BucketQueue<A>, min: number, max: number) => STM.STM<ReadonlyArray<A>, never, never>;
export declare const peekAll: <A>(bucket: BucketQueue<A>) => STM.STM<A[], never, never>;
/** Returns the elements up to the first element that matches the predicate, the rest is left in the queue
 *
 * @example
 * ```ts
 * const [elements, rest] = yield* BucketQueue.takeSplitWhere(bucket, (a) => a > 3)
 * assert.deepStrictEqual(elements, [1, 2, 3])
 * assert.deepStrictEqual(rest, [4, 5, 6])
 * ```
 */
export declare const takeSplitWhere: <A>(bucket: BucketQueue<A>, predicate: (a: A) => boolean) => STM.STM<A[], never, never>;
export declare const size: <A>(bucket: BucketQueue<A>) => Effect.Effect<number, never, never>;
//# sourceMappingURL=BucketQueue.d.ts.map