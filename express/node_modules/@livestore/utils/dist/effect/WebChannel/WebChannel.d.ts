import { Queue, Scope } from 'effect';
import type { DurationInput } from 'effect/Duration';
import * as Effect from '../Effect.js';
import * as Schema from '../Schema/index.js';
import { type InputSchema, type WebChannel } from './common.js';
export declare const shutdown: <MsgListen, MsgSend>(webChannel: WebChannel<MsgListen, MsgSend>) => Effect.Effect<void>;
export declare const noopChannel: <MsgListen, MsgSend>() => Effect.Effect<WebChannel<MsgListen, MsgSend>, never, Scope.Scope>;
/** Only works in browser environments */
export declare const broadcastChannel: <MsgListen, MsgSend, MsgListenEncoded, MsgSendEncoded>({ channelName, schema: inputSchema, }: {
    channelName: string;
    schema: InputSchema<MsgListen, MsgSend, MsgListenEncoded, MsgSendEncoded>;
}) => Effect.Effect<WebChannel<MsgListen, MsgSend>, never, Scope.Scope>;
/**
 * NOTE the `listenName` and `sendName` is needed for cases where both sides are using the same window
 * e.g. for a browser extension, so we need a way to know for which side a message is intended for.
 */
export declare const windowChannel: <MsgListen, MsgSend, MsgListenEncoded, MsgSendEncoded>({ listenWindow, sendWindow, targetOrigin, ids, schema: inputSchema, }: {
    listenWindow: Window;
    sendWindow: Window;
    targetOrigin?: string;
    ids: {
        own: string;
        other: string;
    };
    schema: InputSchema<MsgListen, MsgSend, MsgListenEncoded, MsgSendEncoded>;
}) => Effect.Effect<WebChannel<MsgListen, MsgSend>, never, Scope.Scope>;
export declare const messagePortChannel: {
    <MsgListen, MsgSend, MsgListenEncoded, MsgSendEncoded>(args: {
        port: MessagePort;
        schema: InputSchema<MsgListen, MsgSend, MsgListenEncoded, MsgSendEncoded>;
        debugId?: string | number;
    }): Effect.Effect<WebChannel<MsgListen, MsgSend>, never, Scope.Scope>;
};
export declare const sameThreadChannel: <MsgListen, MsgSend, MsgListenEncoded, MsgSendEncoded>({ schema: inputSchema, channelName, }: {
    schema: InputSchema<MsgListen, MsgSend, MsgListenEncoded, MsgSendEncoded>;
    channelName: string;
}) => Effect.Effect<WebChannel<MsgListen, MsgSend>, never, Scope.Scope>;
export declare const messagePortChannelWithAck: {
    <MsgListen, MsgSend, MsgListenEncoded, MsgSendEncoded>(args: {
        port: MessagePort;
        schema: InputSchema<MsgListen, MsgSend, MsgListenEncoded, MsgSendEncoded>;
        debugId?: string | number;
    }): Effect.Effect<WebChannel<MsgListen, MsgSend>, never, Scope.Scope>;
};
export type QueueChannelProxy<MsgListen, MsgSend> = {
    /** Only meant to be used externally */
    webChannel: WebChannel<MsgListen, MsgSend>;
    /**
     * Meant to be listened to (e.g. via `Stream.fromQueue`) for messages that have been sent
     * via `webChannel.send()`.
     */
    sendQueue: Queue.Dequeue<MsgSend>;
    /**
     * Meant to be pushed to (e.g. via `Queue.offer`) for messages that will be received
     * via `webChannel.listen()`.
     */
    listenQueue: Queue.Enqueue<MsgListen>;
};
/**
 * From the outside the `sendQueue` is only accessible read-only,
 * and the `listenQueue` is only accessible write-only.
 */
export declare const queueChannelProxy: <MsgListen, MsgSend>({ schema: inputSchema, }: {
    schema: Schema.Schema<MsgListen | MsgSend, any> | {
        listen: Schema.Schema<MsgListen, any>;
        send: Schema.Schema<MsgSend, any>;
    };
}) => Effect.Effect<QueueChannelProxy<MsgListen, MsgSend>, never, Scope.Scope>;
/**
 * Eagerly starts listening to a channel by buffering incoming messages in a queue.
 */
export declare const toOpenChannel: (channel: WebChannel<any, any>, options?: {
    /**
     * Sends a heartbeat message to the other end of the channel every `interval`.
     * If the other end doesn't respond within `timeout` milliseconds, the channel is shutdown.
     */
    heartbeat?: {
        interval: DurationInput;
        timeout: DurationInput;
    };
}) => Effect.Effect<WebChannel<any, any>, never, Scope.Scope>;
export declare const sendDebugPing: (channel: WebChannel<any, any>) => Effect.Effect<void, import("effect/ParseResult").ParseError, never>;
//# sourceMappingURL=WebChannel.d.ts.map