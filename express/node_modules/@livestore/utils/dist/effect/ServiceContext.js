import { Cause, Effect, Exit, Fiber, Layer, pipe, Scope } from 'effect';
export const unsafeMainLayer = (original) => {
    const scope = Effect.runSync(Scope.make());
    const layer = pipe(original, Layer.memoize, Effect.parallelFinalizers, // NOTE this runs the layer teardown in parallel
    Effect.provideService(Scope.Scope, scope), Effect.runSync);
    return { layer, close: Scope.close(scope, Exit.void) };
};
export const make = (staticData, runtime, close = Effect.dieMessage('close not implemented')) => {
    return {
        provide: (self) => Effect.provide(runtime)(self),
        runWithErrorLog: (self) => runWithErrorLog(Effect.provide(runtime)(self)),
        runSync: (self) => Effect.runSync(Effect.provide(runtime)(self)),
        runPromiseWithErrorLog: (self) => runPromiseWithErrorLog(Effect.provide(runtime)(self)),
        runPromiseExit: (self) => Effect.runPromiseExit(Effect.provide(runtime)(self)),
        runPromise: (self) => Effect.runPromise(Effect.provide(runtime)(self)),
        withRuntime: (fn) => fn(runtime),
        close: close,
        closePromise: () => Effect.runPromise(close),
        staticData,
    };
};
export const runWithErrorLog = (self) => {
    const fiber = Effect.runFork(self);
    fiber.addObserver((ex) => {
        if (ex._tag === 'Failure' && Cause.isInterruptedOnly(ex.cause) === false) {
            console.error(Cause.pretty(ex.cause));
        }
    });
    return () => {
        Effect.runFork(Fiber.interrupt(fiber));
    };
};
export const runPromiseWithErrorLog = (self) => Effect.runPromiseExit(self).then((ex) => {
    if (ex._tag === 'Failure') {
        console.error(Cause.pretty(ex.cause));
        return undefined;
    }
    else {
        return ex.value;
    }
});
export const MissingContext = Effect.die('service context not provided, wrap your app in LiveServiceContext');
export const empty = () => ({
    provide: () => MissingContext,
    runWithErrorLog: () => runWithErrorLog(MissingContext),
    runSync: () => Effect.runSync(MissingContext),
    runPromiseWithErrorLog: () => runPromiseWithErrorLog(MissingContext),
    runPromiseExit: () => Effect.runPromiseExit(MissingContext),
    runPromise: () => Effect.runPromise(MissingContext),
    withRuntime: () => Effect.runSync(MissingContext),
    close: Effect.dieMessage('Empty ServiceContext cannot be closed'),
    closePromise: () => Promise.reject('Empty ServiceContext cannot be closed'),
    staticData: {},
});
//# sourceMappingURL=ServiceContext.js.map