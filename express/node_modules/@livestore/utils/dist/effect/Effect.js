import * as OtelTracer from '@effect/opentelemetry/Tracer';
import { Cause, Deferred, Effect, Fiber, FiberRef, HashSet, Logger, pipe, Scope } from 'effect';
import { log } from 'effect/Console';
import { isPromise } from '../index.js';
import { UnknownError } from './Error.js';
export * from 'effect/Effect';
// export const log = <A>(message: A, ...rest: any[]): Effect.Effect<void> =>
//   Effect.sync(() => {
//     console.log(message, ...rest)
//   })
// export const logWarn = <A>(message: A, ...rest: any[]): Effect.Effect<void> =>
//   Effect.sync(() => {
//     console.warn(message, ...rest)
//   })
// export const logError = <A>(message: A, ...rest: any[]): Effect.Effect<void> =>
//   Effect.sync(() => {
//     console.error(message, ...rest)
//   })
/** Same as `Effect.scopeWith` but with a `CloseableScope` instead of a `Scope`. */
export const scopeWithCloseable = (fn) => Effect.gen(function* () {
    // const parentScope = yield* Scope.Scope
    // const scope = yield* Scope.fork(parentScope, ExecutionStrategy.sequential)
    const scope = yield* Scope.make();
    yield* Effect.addFinalizer((exit) => Scope.close(scope, exit));
    return yield* fn(scope).pipe(Scope.extend(scope));
});
export const tryAll = (fn) => Effect.try(() => fn()).pipe(Effect.andThen((fnRes) => Effect.isEffect(fnRes)
    ? fnRes
    : isPromise(fnRes)
        ? Effect.promise(() => fnRes)
        : Effect.succeed(fnRes)));
export const acquireReleaseLog = (label) => Effect.acquireRelease(Effect.log(`${label} acquire`), (_, ex) => Effect.log(`${label} release`, ex));
export const addFinalizerLog = (...msgs) => Effect.addFinalizer(() => Effect.log(...msgs));
export const logBefore = (...msgs) => (eff) => Effect.andThen(Effect.log(...msgs), eff);
/** Logs both on errors and defects */
export const tapCauseLogPretty = (eff) => Effect.tapErrorCause(eff, (cause) => Effect.gen(function* () {
    if (Cause.isInterruptedOnly(cause)) {
        // console.log('interrupted', Cause.pretty(err), err)
        return;
    }
    const span = yield* OtelTracer.currentOtelSpan.pipe(Effect.catchTag('NoSuchElementException', (_) => Effect.succeed(undefined)));
    const firstErrLine = cause.toString().split('\n')[0];
    yield* Effect.logError(firstErrLine, cause).pipe((_) => span === undefined
        ? _
        : Effect.annotateLogs({ spanId: span.spanContext().spanId, traceId: span.spanContext().traceId })(_));
}));
export const eventListener = (target, type, handler, options) => Effect.gen(function* () {
    const runtime = yield* Effect.runtime();
    const handlerFn = (event) => handler(event).pipe(Effect.provide(runtime), Effect.runFork);
    target.addEventListener(type, handlerFn, { once: options?.once ?? false });
    yield* Effect.addFinalizer(() => Effect.sync(() => target.removeEventListener(type, handlerFn)));
});
export const spanEvent = (message, attributes) => Effect.locallyWith(Effect.log(message).pipe(Effect.annotateLogs(attributes ?? {})), FiberRef.currentLoggers, () => HashSet.make(Logger.tracerLogger));
export const logWarnIfTakesLongerThan = ({ label, duration }) => (eff) => Effect.gen(function* () {
    const runtime = yield* Effect.runtime();
    let tookLongerThanTimer = false;
    const timeoutFiber = Effect.sleep(duration).pipe(Effect.tap(() => {
        tookLongerThanTimer = true;
        // TODO include span info
        return Effect.logWarning(`${label}: Took longer than ${duration}ms`);
    }), Effect.provide(runtime), Effect.runFork);
    const start = Date.now();
    const res = yield* eff.pipe(Effect.exit, Effect.onInterrupt(Effect.fn(function* () {
        const end = Date.now();
        yield* Fiber.interrupt(timeoutFiber);
        if (tookLongerThanTimer) {
            yield* Effect.logWarning(`${label}: Interrupted after ${end - start}ms`);
        }
    })));
    if (tookLongerThanTimer) {
        const end = Date.now();
        yield* Effect.logWarning(`${label}: Actual duration: ${end - start}ms`);
    }
    yield* Fiber.interrupt(timeoutFiber);
    return yield* res;
});
export const logDuration = (label) => (eff) => Effect.gen(function* () {
    const start = Date.now();
    const res = yield* eff;
    const end = Date.now();
    yield* Effect.log(`${label}: ${end - start}ms`);
    return res;
});
export const tapSync = (tapFn) => (eff) => Effect.tap(eff, (a) => Effect.sync(() => tapFn(a)));
export const debugLogEnv = (msg) => pipe(Effect.context(), Effect.tap((env) => log(msg ?? 'debugLogEnv', env)));
export const timeoutDie = (options) => (self) => Effect.orDie(Effect.timeoutFail(options)(self));
export const timeoutDieMsg = (options) => (self) => Effect.orDie(Effect.timeoutFail({ onTimeout: () => new UnknownError({ cause: options.error }), duration: options.duration })(self));
export const toForkedDeferred = (eff) => pipe(Deferred.make(), Effect.tap((deferred) => pipe(Effect.exit(eff), Effect.flatMap((ex) => Deferred.done(deferred, ex)), tapCauseLogPretty, Effect.forkScoped)));
export const withPerformanceMeasure = (meaureLabel) => (eff) => Effect.acquireUseRelease(Effect.sync(() => performance.mark(`${meaureLabel}:start`)), () => eff, () => Effect.sync(() => {
    performance.mark(`${meaureLabel}:end`);
    performance.measure(meaureLabel, `${meaureLabel}:start`, `${meaureLabel}:end`);
}));
const getSpanTrace = () => {
    const fiberOption = Fiber.getCurrentFiber();
    if (fiberOption._tag === 'None' || fiberOption.value.currentSpan === undefined) {
        return 'No current fiber';
    }
    return '';
    // const msg = Effect.runSync(
    //   Effect.fail({ message: '' }).pipe(
    //     Effect.withParentSpan(fiberOption.value.currentSpan),
    //     Effect.catchAllCause((cause) => Effect.succeed(cause.toString())),
    //   ),
    // )
    // // remove the first line
    // return msg
    //   .split('\n')
    //   .slice(1)
    //   .map((_) => _.trim().replace('at ', ''))
    //   .join('\n')
};
const logSpanTrace = () => console.log(getSpanTrace());
// @ts-expect-error TODO fix types
globalThis.getSpanTrace = getSpanTrace;
// @ts-expect-error TODO fix types
globalThis.logSpanTrace = logSpanTrace;
//# sourceMappingURL=Effect.js.map