// Fork of effect/Subscribable.ts which makes Subscribable yieldable
import { Effect, Effectable, Readable, Stream } from 'effect';
import { dual } from 'effect/Function';
import { hasProperty } from 'effect/Predicate';
/**
 * @since 2.0.0
 * @category type ids
 */
export const TypeId = Symbol.for('effect/Subscribable');
/**
 * @since 2.0.0
 * @category refinements
 */
export const isSubscribable = (u) => hasProperty(u, TypeId);
// const Proto: Omit<Subscribable<any>, 'get' | 'changes'> = {
//   [Readable.TypeId]: Readable.TypeId,
//   [TypeId]: TypeId,
//   pipe() {
//     return pipeArguments(this, arguments)
//   },
// }
class SubscribableImpl extends Effectable.Class {
    get;
    changes;
    // @ts-expect-error type symbol
    [TypeId] = TypeId;
    // @ts-expect-error type symbol
    [Readable.TypeId] = Readable.TypeId;
    constructor(get, changes) {
        super();
        this.get = get;
        this.changes = changes;
    }
    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
    commit() {
        return this.get;
    }
}
/**
 * @since 2.0.0
 * @category constructors
 */
// export const make = <A, E, R>(options: {
//   readonly get: Effect.Effect<A, E, R>
//   readonly changes: Stream.Stream<A, E, R>
// }): Subscribable<A, E, R> => Object.assign(Object.create(Proto), options)
export const make = (options) => new SubscribableImpl(options.get, options.changes);
export const fromSubscriptionRef = (ref) => make({
    get: ref.get,
    changes: ref.changes,
});
/**
 * @since 2.0.0
 * @category combinators
 */
export const map = dual(2, (self, f) => make({
    get: Effect.map(self.get, f),
    changes: Stream.map(self.changes, f),
}));
/**
 * @since 2.0.0
 * @category combinators
 */
export const mapEffect = dual(2, (self, f) => make({
    get: Effect.flatMap(self.get, f),
    changes: Stream.mapEffect(self.changes, f),
}));
/**
 * @since 2.0.0
 * @category constructors
 */
export const unwrap = (effect) => make({
    get: Effect.flatMap(effect, (s) => s.get),
    changes: Stream.unwrap(Effect.map(effect, (s) => s.changes)),
});
export const never = make({
    get: Effect.never,
    changes: Stream.never,
});
//# sourceMappingURL=Subscribable.js.map