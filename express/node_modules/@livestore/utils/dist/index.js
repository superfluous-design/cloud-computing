export * from './string.js';
export * from './guards.js';
export * from './object/index.js';
export * from './promise.js';
export * from './time.js';
export * from './NoopTracer.js';
export * from './set.js';
export * from './browser.js';
export * from './Deferred.js';
export * from './misc.js';
export * from './env.js';
export * from './fast-deep-equal.js';
export * as base64 from './base64.js';
export { default as prettyBytes } from 'pretty-bytes';
import { objectToString } from './misc.js';
export const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
export const ref = (val) => ({ current: val });
export const times = (n, fn) => {
    for (let i = 0; i < n; i++) {
        fn(i);
    }
};
export const debugCatch = (try_) => {
    try {
        return try_();
    }
    catch (e) {
        debugger;
        throw e;
    }
};
export const recRemoveUndefinedValues = (val) => {
    if (Array.isArray(val)) {
        val.forEach(recRemoveUndefinedValues);
    }
    else if (typeof val === 'object') {
        Object.keys(val).forEach((key) => {
            if (val[key] === undefined) {
                delete val[key];
            }
            else {
                recRemoveUndefinedValues(val[key]);
            }
        });
    }
};
export const prop = (key) => (obj) => obj[key];
export const capitalizeFirstLetter = (str) => str.charAt(0).toUpperCase() + str.slice(1);
export const isReadonlyArray = (value) => Array.isArray(value);
/**
 * Use this to make assertion at end of if-else chain that all members of a
 * union have been accounted for.
 */
/* eslint-disable-next-line prefer-arrow/prefer-arrow-functions */
export function casesHandled(unexpectedCase) {
    debugger;
    throw new Error(`A case was not handled for value: ${truncate(objectToString(unexpectedCase), 1000)}`);
}
export const assertNever = (failIfFalse, msg) => {
    if (failIfFalse === false) {
        debugger;
        throw new Error(`This should never happen: ${msg}`);
    }
};
export const debuggerPipe = (val) => {
    debugger;
    return val;
};
const truncate = (str, length) => {
    if (str.length > length) {
        return str.slice(0, length) + '...';
    }
    else {
        return str;
    }
};
export const notYetImplemented = (msg) => {
    debugger;
    throw new Error(`Not yet implemented: ${msg}`);
};
export const noop = () => { };
export const unwrapThunk = (_) => {
    if (typeof _ === 'function') {
        return _();
    }
    else {
        return _;
    }
};
/** `end` is not included */
export const range = (start, end) => {
    const length = end - start;
    return Array.from({ length }, (_, i) => start + i);
};
export const throttle = (fn, ms) => {
    let shouldWait = false;
    let shouldCallAgain = false;
    const timeoutFunc = () => {
        if (shouldCallAgain) {
            fn();
            shouldCallAgain = false;
            setTimeout(timeoutFunc, ms);
        }
        else {
            shouldWait = false;
        }
    };
    return () => {
        if (shouldWait) {
            shouldCallAgain = true;
            return;
        }
        fn();
        shouldWait = true;
        setTimeout(timeoutFunc, ms);
    };
};
export const getTraceParentHeader = (parentSpan) => {
    const spanContext = parentSpan.spanContext();
    // Format: {version}-{trace_id}-{span_id}-{trace_flags}
    // https://www.w3.org/TR/trace-context/#examples-of-http-traceparent-headers
    return `00-${spanContext.traceId}-${spanContext.spanId}-01`;
};
export const assertTag = (obj, tag) => {
    if (obj._tag !== tag) {
        throw new Error(`Expected tag ${tag} but got ${obj._tag}`);
    }
    return obj;
};
export const memoizeByStringifyArgs = (fn) => {
    const cache = new Map();
    return ((...args) => {
        const key = JSON.stringify(args);
        if (cache.has(key)) {
            return cache.get(key);
        }
        const result = fn(...args);
        cache.set(key, result);
        return result;
    });
};
export const memoizeByRef = (fn) => {
    const cache = new Map();
    return ((arg) => {
        if (cache.has(arg)) {
            return cache.get(arg);
        }
        const result = fn(arg);
        cache.set(arg, result);
        return result;
    });
};
export const isNonEmptyString = (str) => {
    return typeof str === 'string' && str.length > 0;
};
export const isPromise = (value) => typeof value?.then === 'function';
export const isIterable = (value) => typeof value?.[Symbol.iterator] === 'function';
export { objectToString as errorToString } from './misc.js';
//# sourceMappingURL=index.js.map