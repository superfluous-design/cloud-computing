import type { Brand } from '@livestore/utils/effect';
import { Schema } from '@livestore/utils/effect';
export type ParamsObject = Record<string, SqlValue>;
export type SqlValue = string | number | Uint8Array | null;
export type Bindable = ReadonlyArray<SqlValue> | ParamsObject;
export declare const SqlValueSchema: Schema.Union<[typeof Schema.String, typeof Schema.Number, typeof Schema.Uint8Array, typeof Schema.Null]>;
export declare const PreparedBindValues: Schema.brand<Schema.Union<[Schema.Array$<Schema.Union<[typeof Schema.String, typeof Schema.Number, typeof Schema.Uint8Array, typeof Schema.Null]>>, Schema.Record$<typeof Schema.String, Schema.Union<[typeof Schema.String, typeof Schema.Number, typeof Schema.Uint8Array, typeof Schema.Null]>>]>, "PreparedBindValues">;
export type PreparedBindValues = Brand.Branded<Bindable, 'PreparedBindValues'>;
/**
 * This is a tag function for tagged literals.
 * it lets us get syntax highlighting on SQL queries in VSCode, but
 * doesn't do anything at runtime.
 * Code copied from: https://esdiscuss.org/topic/string-identity-template-tag
 */
export declare const sql: (template: TemplateStringsArray, ...args: unknown[]) => string;
/**
 * Prepare bind values to send to SQLite
 * Add $ to the beginning of keys; which we use as our interpolation syntax
 * We also strip out any params that aren't used in the statement,
 * because rusqlite doesn't allow unused named params
 * TODO: Search for unused params via proper parsing, not string search
 * TODO: Also make sure that the SQLite binding limit of 1000 is respected
 */
export declare const prepareBindValues: (values: Bindable, statement: string) => PreparedBindValues;
//# sourceMappingURL=util.d.ts.map