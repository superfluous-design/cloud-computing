import type { Cause, Queue, Scope, SubscriptionRef, WebChannel } from '@livestore/utils/effect';
import { Effect, Schema, Stream } from '@livestore/utils/effect';
import type * as Devtools from './devtools/mod.js';
import * as EventSequenceNumber from './schema/EventSequenceNumber.js';
import type { LiveStoreEvent, LiveStoreSchema } from './schema/mod.js';
import type { QueryBuilder } from './schema/state/sqlite/query-builder/api.js';
import type { LeaderAheadError } from './sync/sync.js';
import type { PayloadUpstream, SyncState } from './sync/syncstate.js';
import type { PreparedBindValues } from './util.js';
export interface PreparedStatement {
    execute(bindValues: PreparedBindValues | undefined, options?: {
        onRowsChanged?: (rowsChanged: number) => void;
    }): void;
    select<T>(bindValues: PreparedBindValues | undefined): ReadonlyArray<T>;
    finalize(): void;
    sql: string;
}
export type SqliteDbSession = {
    changeset: () => Uint8Array | undefined;
    finish: () => void;
};
export type SqliteDbChangeset = {
    invert: () => SqliteDbChangeset;
    apply: () => void;
};
export interface ClientSession {
    /** SQLite database with synchronous API running in the same thread (usually in-memory) */
    sqliteDb: SqliteDb;
    devtools: {
        enabled: false;
    } | {
        enabled: true;
        pullLatch: Effect.Latch;
        pushLatch: Effect.Latch;
    };
    clientId: string;
    sessionId: string;
    /** Status info whether current session is leader or not */
    lockStatus: SubscriptionRef.SubscriptionRef<LockStatus>;
    shutdown: (cause: Cause.Cause<UnexpectedError | IntentionalShutdownCause>) => Effect.Effect<void>;
    /** A proxy API to communicate with the leader thread */
    leaderThread: ClientSessionLeaderThreadProxy;
    /** A unique identifier for the current instance of the client session. Used for debugging purposes. */
    debugInstanceId: string;
}
export declare const LeaderPullCursor: Schema.Struct<{
    mergeCounter: typeof Schema.Number;
    eventNum: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
}>;
export type LeaderPullCursor = typeof LeaderPullCursor.Type;
export interface ClientSessionLeaderThreadProxy {
    events: {
        pull: (args: {
            cursor: LeaderPullCursor;
        }) => Stream.Stream<{
            payload: typeof PayloadUpstream.Type;
            mergeCounter: number;
        }, UnexpectedError>;
        /** It's important that a client session doesn't call `push` concurrently. */
        push(batch: ReadonlyArray<LiveStoreEvent.AnyEncoded>): Effect.Effect<void, UnexpectedError | LeaderAheadError>;
    };
    /** The initial state after the leader thread has booted */
    readonly initialState: {
        /** The latest event sequence number during boot. Used for the client session to resume syncing. */
        readonly leaderHead: EventSequenceNumber.EventSequenceNumber;
        /** The migrations report from the leader thread */
        readonly migrationsReport: MigrationsReport;
    };
    export: Effect.Effect<Uint8Array, UnexpectedError>;
    getEventlogData: Effect.Effect<Uint8Array, UnexpectedError>;
    getSyncState: Effect.Effect<SyncState, UnexpectedError>;
    /** For debugging purposes it can be useful to manually trigger devtools messages (e.g. to reset the database) */
    sendDevtoolsMessage: (message: Devtools.Leader.MessageToApp) => Effect.Effect<void, UnexpectedError>;
}
/**
 * Common interface for SQLite databases used by LiveStore to facilitate a consistent API across different platforms.
 * Always assumes a synchronous SQLite build with the `bytecode` and `session` extensions enabled.
 * Can be either in-memory or persisted to disk.
 */
export interface SqliteDb<TReq = any, TMetadata extends TReq = TReq> {
    _tag: 'SqliteDb';
    metadata: TMetadata;
    prepare(queryStr: string): PreparedStatement;
    execute(queryStr: string, bindValues?: PreparedBindValues | undefined, options?: {
        onRowsChanged?: (rowsChanged: number) => void;
    }): void;
    execute(queryBuilder: QueryBuilder.Any, options?: {
        onRowsChanged?: (rowsChanged: number) => void;
    }): void;
    select<T>(queryStr: string, bindValues?: PreparedBindValues | undefined): ReadonlyArray<T>;
    select<T>(queryBuilder: QueryBuilder<T, any, any>): ReadonlyArray<T>;
    export(): Uint8Array;
    import: (data: Uint8Array | SqliteDb<TReq>) => void;
    close(): void;
    destroy(): void;
    session(): SqliteDbSession;
    makeChangeset: (data: Uint8Array) => SqliteDbChangeset;
}
export type MakeSqliteDb<TReq = {
    dbPointer: number;
    persistenceInfo: PersistenceInfo;
}, TInput_ extends {
    _tag: string;
} = {
    _tag: string;
}, TMetadata_ extends TReq = TReq, R = never> = <TInput extends TInput_, TMetadata extends TMetadata_ & {
    _tag: TInput['_tag'];
} = TMetadata_ & {
    _tag: TInput['_tag'];
}>(input: TInput) => Effect.Effect<SqliteDb<TReq, Extract<TMetadata, {
    _tag: TInput['_tag'];
}>>, SqliteError | UnexpectedError, R>;
export declare const PersistenceInfo: Schema.TypeLiteral<{
    fileName: typeof Schema.String;
}, readonly [{
    readonly key: typeof Schema.String;
    readonly value: typeof Schema.Any;
}]>;
export type PersistenceInfo<With extends {} = {}> = typeof PersistenceInfo.Type & With;
export type ResetMode = 'all-data' | 'only-app-db';
export declare const BootStateProgress: Schema.Struct<{
    done: typeof Schema.Number;
    total: typeof Schema.Number;
}>;
export declare const BootStatus: Schema.Union<[Schema.Struct<{
    stage: Schema.Literal<["loading"]>;
}>, Schema.Struct<{
    stage: Schema.Literal<["migrating"]>;
    progress: Schema.Struct<{
        done: typeof Schema.Number;
        total: typeof Schema.Number;
    }>;
}>, Schema.Struct<{
    stage: Schema.Literal<["rehydrating"]>;
    progress: Schema.Struct<{
        done: typeof Schema.Number;
        total: typeof Schema.Number;
    }>;
}>, Schema.Struct<{
    stage: Schema.Literal<["syncing"]>;
    progress: Schema.Struct<{
        done: typeof Schema.Number;
        total: typeof Schema.Number;
    }>;
}>, Schema.Struct<{
    stage: Schema.Literal<["done"]>;
}>]>;
export type BootStatus = typeof BootStatus.Type;
/**
 * Can be used in queries to refer to the current session id.
 * Will be replaced with the actual session id at runtime
 *
 * In client document table:
 * ```ts
 * const uiState = State.SQLite.clientDocument({
 *   name: 'ui_state',
 *   schema: Schema.Struct({
 *     theme: Schema.Literal('dark', 'light', 'system'),
 *     user: Schema.String,
 *     showToolbar: Schema.Boolean,
 *   }),
 *   default: { value: defaultFrontendState, id: SessionIdSymbol },
 * })
 * ```
 *
 * Or in a client document query:
 * ```ts
 * const query$ = queryDb(tables.uiState.get(SessionIdSymbol))
 * ```
 */
export declare const SessionIdSymbol: unique symbol;
export type SessionIdSymbol = typeof SessionIdSymbol;
export type LockStatus = 'has-lock' | 'no-lock';
declare const UnexpectedError_base: Schema.TaggedErrorClass<UnexpectedError, "LiveStore.UnexpectedError", {
    readonly _tag: Schema.tag<"LiveStore.UnexpectedError">;
} & {
    cause: typeof Schema.Defect;
    note: Schema.optional<typeof Schema.String>;
    payload: Schema.optional<typeof Schema.Any>;
}>;
export declare class UnexpectedError extends UnexpectedError_base {
    static mapToUnexpectedError: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, UnexpectedError, R>;
    static mapToUnexpectedErrorStream: <A, E, R>(stream: Stream.Stream<A, E, R>) => Stream.Stream<A, UnexpectedError, R>;
}
declare const IntentionalShutdownCause_base: Schema.TaggedErrorClass<IntentionalShutdownCause, "LiveStore.IntentionalShutdownCause", {
    readonly _tag: Schema.tag<"LiveStore.IntentionalShutdownCause">;
} & {
    reason: Schema.Literal<["devtools-reset", "devtools-import", "adapter-reset", "manual"]>;
}>;
export declare class IntentionalShutdownCause extends IntentionalShutdownCause_base {
}
declare const StoreInterrupted_base: Schema.TaggedErrorClass<StoreInterrupted, "LiveStore.StoreInterrupted", {
    readonly _tag: Schema.tag<"LiveStore.StoreInterrupted">;
} & {
    reason: typeof Schema.String;
}>;
export declare class StoreInterrupted extends StoreInterrupted_base {
}
declare const SqliteError_base: Schema.TaggedErrorClass<SqliteError, "LiveStore.SqliteError", {
    readonly _tag: Schema.tag<"LiveStore.SqliteError">;
} & {
    query: Schema.optional<Schema.Struct<{
        sql: typeof Schema.String;
        bindValues: Schema.Union<[Schema.Record$<typeof Schema.String, typeof Schema.Any>, Schema.Array$<typeof Schema.Any>]>;
    }>>;
    /** The SQLite result code */
    code: Schema.optional<Schema.Union<[typeof Schema.Number, typeof Schema.String]>>;
    /** The original SQLite3 error */
    cause: typeof Schema.Defect;
    note: Schema.optional<typeof Schema.String>;
}>;
export declare class SqliteError extends SqliteError_base {
}
export type MigrationOptions = {
    strategy: 'auto';
    hooks?: Partial<MigrationHooks>;
    logging?: {
        excludeAffectedRows?: (sqlStmt: string) => boolean;
    };
} | {
    strategy: 'manual';
    migrate: (oldDb: Uint8Array) => Uint8Array | Promise<Uint8Array> | Effect.Effect<Uint8Array, unknown>;
};
export type MigrationHooks = {
    /** Runs on the empty in-memory database with no database schemas applied yet */
    init: MigrationHook;
    /** Runs before applying the migration strategy but after table schemas have been applied and singleton rows have been created */
    pre: MigrationHook;
    /** Runs after applying the migration strategy before creating export snapshot and closing the database */
    post: MigrationHook;
};
export type MigrationHook = (db: SqliteDb) => void | Promise<void> | Effect.Effect<void, unknown>;
export interface ClientSessionDevtoolsChannel extends WebChannel.WebChannel<Devtools.ClientSession.MessageToApp, Devtools.ClientSession.MessageFromApp> {
}
export type ConnectDevtoolsToStore = (storeDevtoolsChannel: ClientSessionDevtoolsChannel) => Effect.Effect<void, UnexpectedError, Scope.Scope>;
export type Adapter = (args: AdapterArgs) => Effect.Effect<ClientSession, UnexpectedError, Scope.Scope>;
export interface AdapterArgs {
    schema: LiveStoreSchema;
    storeId: string;
    devtoolsEnabled: boolean;
    debugInstanceId: string;
    bootStatusQueue: Queue.Queue<BootStatus>;
    shutdown: (cause: Cause.Cause<any>) => Effect.Effect<void>;
    connectDevtoolsToStore: ConnectDevtoolsToStore;
    /**
     * Payload that will be passed to the sync backend when connecting
     *
     * @default undefined
     */
    syncPayload: Schema.JsonValue | undefined;
}
export declare const MigrationsReportEntry: Schema.Struct<{
    tableName: typeof Schema.String;
    hashes: Schema.Struct<{
        expected: typeof Schema.Number;
        actual: Schema.optional<typeof Schema.Number>;
    }>;
}>;
export declare const MigrationsReport: Schema.Struct<{
    migrations: Schema.Array$<Schema.Struct<{
        tableName: typeof Schema.String;
        hashes: Schema.Struct<{
            expected: typeof Schema.Number;
            actual: Schema.optional<typeof Schema.Number>;
        }>;
    }>>;
}>;
export type MigrationsReport = typeof MigrationsReport.Type;
export type MigrationsReportEntry = typeof MigrationsReportEntry.Type;
export {};
//# sourceMappingURL=adapter-types.d.ts.map