import { Schema } from '@livestore/utils/effect';
import { BoundArray } from './bounded-collections.js';
import { PreparedBindValues } from './util.js';
export type SlowQueryInfo = {
    queryStr: string;
    bindValues: PreparedBindValues | undefined;
    durationMs: number;
    rowsCount: number | undefined;
    queriedTables: Set<string>;
    startTimePerfNow: DOMHighResTimeStamp;
};
export declare const SlowQueryInfo: Schema.Struct<{
    queryStr: typeof Schema.String;
    bindValues: Schema.UndefinedOr<Schema.brand<Schema.Union<[Schema.Array$<Schema.Union<[typeof Schema.String, typeof Schema.Number, typeof Schema.Uint8Array, typeof Schema.Null]>>, Schema.Record$<typeof Schema.String, Schema.Union<[typeof Schema.String, typeof Schema.Number, typeof Schema.Uint8Array, typeof Schema.Null]>>]>, "PreparedBindValues">>;
    durationMs: typeof Schema.Number;
    rowsCount: Schema.UndefinedOr<typeof Schema.Number>;
    queriedTables: Schema.ReadonlySet$<typeof Schema.String>;
    startTimePerfNow: typeof Schema.Number;
}>;
export declare const BoundArraySchema: <ItemDecoded, ItemEncoded>(elSchema: Schema.Schema<ItemDecoded, ItemEncoded>) => Schema.transform<Schema.Struct<{
    size: typeof Schema.Number;
    items: Schema.Array$<Schema.Schema<ItemDecoded, ItemEncoded, never>>;
}>, Schema.Schema<BoundArray<ItemDecoded>, BoundArray<ItemDecoded>, never>>;
export declare const DebugInfo: Schema.Struct<{
    slowQueries: Schema.transform<Schema.Struct<{
        size: typeof Schema.Number;
        items: Schema.Array$<Schema.Schema<{
            readonly queryStr: string;
            readonly bindValues: ((readonly (string | number | Uint8Array<ArrayBufferLike> | null)[] | {
                readonly [x: string]: string | number | Uint8Array<ArrayBufferLike> | null;
            }) & import("effect/Brand").Brand<"PreparedBindValues">) | undefined;
            readonly durationMs: number;
            readonly rowsCount: number | undefined;
            readonly queriedTables: ReadonlySet<string>;
            readonly startTimePerfNow: number;
        }, {
            readonly queryStr: string;
            readonly bindValues: readonly (string | number | readonly number[] | null)[] | {
                readonly [x: string]: string | number | readonly number[] | null;
            } | undefined;
            readonly durationMs: number;
            readonly rowsCount: number | undefined;
            readonly queriedTables: readonly string[];
            readonly startTimePerfNow: number;
        }, never>>;
    }>, Schema.Schema<BoundArray<{
        readonly queryStr: string;
        readonly bindValues: ((readonly (string | number | Uint8Array<ArrayBufferLike> | null)[] | {
            readonly [x: string]: string | number | Uint8Array<ArrayBufferLike> | null;
        }) & import("effect/Brand").Brand<"PreparedBindValues">) | undefined;
        readonly durationMs: number;
        readonly rowsCount: number | undefined;
        readonly queriedTables: ReadonlySet<string>;
        readonly startTimePerfNow: number;
    }>, BoundArray<{
        readonly queryStr: string;
        readonly bindValues: ((readonly (string | number | Uint8Array<ArrayBufferLike> | null)[] | {
            readonly [x: string]: string | number | Uint8Array<ArrayBufferLike> | null;
        }) & import("effect/Brand").Brand<"PreparedBindValues">) | undefined;
        readonly durationMs: number;
        readonly rowsCount: number | undefined;
        readonly queriedTables: ReadonlySet<string>;
        readonly startTimePerfNow: number;
    }>, never>>;
    queryFrameDuration: typeof Schema.Number;
    queryFrameCount: typeof Schema.Number;
    events: Schema.transform<Schema.Struct<{
        size: typeof Schema.Number;
        items: Schema.Array$<Schema.Schema<readonly [string, any], readonly [string, any], never>>;
    }>, Schema.Schema<BoundArray<readonly [string, any]>, BoundArray<readonly [string, any]>, never>>;
}>;
export type DebugInfo = typeof DebugInfo.Type;
export declare const MutableDebugInfo: Schema.mutable<Schema.Struct<{
    slowQueries: Schema.transform<Schema.Struct<{
        size: typeof Schema.Number;
        items: Schema.Array$<Schema.Schema<{
            readonly queryStr: string;
            readonly bindValues: ((readonly (string | number | Uint8Array<ArrayBufferLike> | null)[] | {
                readonly [x: string]: string | number | Uint8Array<ArrayBufferLike> | null;
            }) & import("effect/Brand").Brand<"PreparedBindValues">) | undefined;
            readonly durationMs: number;
            readonly rowsCount: number | undefined;
            readonly queriedTables: ReadonlySet<string>;
            readonly startTimePerfNow: number;
        }, {
            readonly queryStr: string;
            readonly bindValues: readonly (string | number | readonly number[] | null)[] | {
                readonly [x: string]: string | number | readonly number[] | null;
            } | undefined;
            readonly durationMs: number;
            readonly rowsCount: number | undefined;
            readonly queriedTables: readonly string[];
            readonly startTimePerfNow: number;
        }, never>>;
    }>, Schema.Schema<BoundArray<{
        readonly queryStr: string;
        readonly bindValues: ((readonly (string | number | Uint8Array<ArrayBufferLike> | null)[] | {
            readonly [x: string]: string | number | Uint8Array<ArrayBufferLike> | null;
        }) & import("effect/Brand").Brand<"PreparedBindValues">) | undefined;
        readonly durationMs: number;
        readonly rowsCount: number | undefined;
        readonly queriedTables: ReadonlySet<string>;
        readonly startTimePerfNow: number;
    }>, BoundArray<{
        readonly queryStr: string;
        readonly bindValues: ((readonly (string | number | Uint8Array<ArrayBufferLike> | null)[] | {
            readonly [x: string]: string | number | Uint8Array<ArrayBufferLike> | null;
        }) & import("effect/Brand").Brand<"PreparedBindValues">) | undefined;
        readonly durationMs: number;
        readonly rowsCount: number | undefined;
        readonly queriedTables: ReadonlySet<string>;
        readonly startTimePerfNow: number;
    }>, never>>;
    queryFrameDuration: typeof Schema.Number;
    queryFrameCount: typeof Schema.Number;
    events: Schema.transform<Schema.Struct<{
        size: typeof Schema.Number;
        items: Schema.Array$<Schema.Schema<readonly [string, any], readonly [string, any], never>>;
    }>, Schema.Schema<BoundArray<readonly [string, any]>, BoundArray<readonly [string, any]>, never>>;
}>>;
export type MutableDebugInfo = typeof MutableDebugInfo.Type;
//# sourceMappingURL=debug-info.d.ts.map