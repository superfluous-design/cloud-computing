import { Schema } from '@livestore/utils/effect';
import { UnexpectedError } from '../adapter-types.js';
import * as LiveStoreEvent from '../schema/LiveStoreEvent.js';
declare const SyncState_base: Schema.Class<SyncState, {
    pending: Schema.Array$<typeof LiveStoreEvent.EncodedWithMeta>;
    /** What this node expects the next upstream node to have as its own local head */
    upstreamHead: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
    /** Equivalent to `pending.at(-1)?.id` if there are pending events */
    localHead: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
}, Schema.Struct.Encoded<{
    pending: Schema.Array$<typeof LiveStoreEvent.EncodedWithMeta>;
    /** What this node expects the next upstream node to have as its own local head */
    upstreamHead: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
    /** Equivalent to `pending.at(-1)?.id` if there are pending events */
    localHead: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
}>, never, {
    readonly upstreamHead: {
        readonly global: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
        readonly client: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    };
} & {
    readonly localHead: {
        readonly global: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
        readonly client: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    };
} & {
    readonly pending: readonly LiveStoreEvent.EncodedWithMeta[];
}, {}, {}>;
/**
 * SyncState represents the current sync state of a sync node relative to an upstream node.
 * Events flow from local to upstream, with each state maintaining its own event head.
 *
 * Example:
 * ```
 *                 +------------------------+
 *                 |     PENDING EVENTS     |
 *                 +------------------------+
 *               ▼                       ▼
 *        Upstream Head             Local Head
 *             (1,0)     (1,1), (1,2), (2,0)
 * ```
 *
 * **Pending Events**: Events awaiting acknowledgment from the upstream.
 * - Can be confirmed or rejected by the upstream.
 * - Subject to rebase if rejected.
 *
 * Payloads:
 * - `PayloadUpstreamRebase`: Upstream has performed a rebase, so downstream must roll back to the specified event
 *    and rebase the pending events on top of the new events.
 * - `PayloadUpstreamAdvance`: Upstream has advanced, so downstream must rebase the pending events on top of the new events.
 * - `PayloadLocalPush`: Local push payload
 *
 * Invariants:
 * 1. **Chain Continuity**: Each event must reference its immediate parent.
 * 2. **Head Ordering**: Upstream Head ≤ Local Head.
 * 3. **Event number sequence**: Must follow the pattern (1,0)→(1,1)→(1,2)→(2,0).
 *
 * A few further notes to help form an intuition:
 * - The goal is to keep the pending events as small as possible (i.e. to have synced with the next upstream node)
 * - There are 2 cases for rebasing:
 *   - The conflicting event only conflicts with the pending events -> only (some of) the pending events need to be rolled back
 *
 * The `merge` function processes updates to the sync state based on incoming payloads,
 * handling cases such as upstream rebase, advance and local push.
 */
export declare class SyncState extends SyncState_base {
    toJSON: () => any;
}
declare const PayloadUpstreamRebase_base: Schema.TaggedStruct<"upstream-rebase", {
    /** Events which need to be rolled back */
    rollbackEvents: Schema.Array$<typeof LiveStoreEvent.EncodedWithMeta>;
    /** Events which need to be applied after the rollback (already rebased by the upstream node) */
    newEvents: Schema.Array$<typeof LiveStoreEvent.EncodedWithMeta>;
}>;
/**
 * This payload propagates a rebase from the upstream node
 */
export declare class PayloadUpstreamRebase extends PayloadUpstreamRebase_base {
}
declare const PayloadUpstreamAdvance_base: Schema.TaggedStruct<"upstream-advance", {
    newEvents: Schema.Array$<typeof LiveStoreEvent.EncodedWithMeta>;
}>;
export declare class PayloadUpstreamAdvance extends PayloadUpstreamAdvance_base {
}
declare const PayloadLocalPush_base: Schema.TaggedStruct<"local-push", {
    newEvents: Schema.Array$<typeof LiveStoreEvent.EncodedWithMeta>;
}>;
export declare class PayloadLocalPush extends PayloadLocalPush_base {
}
declare const Payload_base: Schema.Union<[typeof PayloadUpstreamRebase, typeof PayloadUpstreamAdvance, typeof PayloadLocalPush]>;
export declare class Payload extends Payload_base {
}
declare const PayloadUpstream_base: Schema.Union<[typeof PayloadUpstreamRebase, typeof PayloadUpstreamAdvance]>;
export declare class PayloadUpstream extends PayloadUpstream_base {
}
declare const MergeContext_base: Schema.Class<MergeContext, {
    payload: typeof Payload;
    syncState: typeof SyncState;
}, Schema.Struct.Encoded<{
    payload: typeof Payload;
    syncState: typeof SyncState;
}>, never, {
    readonly payload: {
        readonly _tag: "upstream-rebase";
        readonly rollbackEvents: readonly LiveStoreEvent.EncodedWithMeta[];
        readonly newEvents: readonly LiveStoreEvent.EncodedWithMeta[];
    } | {
        readonly _tag: "upstream-advance";
        readonly newEvents: readonly LiveStoreEvent.EncodedWithMeta[];
    } | {
        readonly _tag: "local-push";
        readonly newEvents: readonly LiveStoreEvent.EncodedWithMeta[];
    };
} & {
    readonly syncState: SyncState;
}, {}, {}>;
/** Only used for debugging purposes */
export declare class MergeContext extends MergeContext_base {
    toJSON: () => any;
}
declare const MergeResultAdvance_base: Schema.Class<MergeResultAdvance, {
    _tag: Schema.Literal<["advance"]>;
    newSyncState: typeof SyncState;
    newEvents: Schema.Array$<typeof LiveStoreEvent.EncodedWithMeta>;
    /** Events which were previously pending but are now confirmed */
    confirmedEvents: Schema.Array$<typeof LiveStoreEvent.EncodedWithMeta>;
    mergeContext: typeof MergeContext;
}, Schema.Struct.Encoded<{
    _tag: Schema.Literal<["advance"]>;
    newSyncState: typeof SyncState;
    newEvents: Schema.Array$<typeof LiveStoreEvent.EncodedWithMeta>;
    /** Events which were previously pending but are now confirmed */
    confirmedEvents: Schema.Array$<typeof LiveStoreEvent.EncodedWithMeta>;
    mergeContext: typeof MergeContext;
}>, never, {
    readonly _tag: "advance";
} & {
    readonly newEvents: readonly LiveStoreEvent.EncodedWithMeta[];
} & {
    readonly newSyncState: SyncState;
} & {
    readonly mergeContext: MergeContext;
} & {
    readonly confirmedEvents: readonly LiveStoreEvent.EncodedWithMeta[];
}, {}, {}>;
export declare class MergeResultAdvance extends MergeResultAdvance_base {
    toJSON: () => any;
}
declare const MergeResultRebase_base: Schema.Class<MergeResultRebase, {
    _tag: Schema.Literal<["rebase"]>;
    newSyncState: typeof SyncState;
    newEvents: Schema.Array$<typeof LiveStoreEvent.EncodedWithMeta>;
    /** Events which need to be rolled back */
    rollbackEvents: Schema.Array$<typeof LiveStoreEvent.EncodedWithMeta>;
    mergeContext: typeof MergeContext;
}, Schema.Struct.Encoded<{
    _tag: Schema.Literal<["rebase"]>;
    newSyncState: typeof SyncState;
    newEvents: Schema.Array$<typeof LiveStoreEvent.EncodedWithMeta>;
    /** Events which need to be rolled back */
    rollbackEvents: Schema.Array$<typeof LiveStoreEvent.EncodedWithMeta>;
    mergeContext: typeof MergeContext;
}>, never, {
    readonly _tag: "rebase";
} & {
    readonly rollbackEvents: readonly LiveStoreEvent.EncodedWithMeta[];
} & {
    readonly newEvents: readonly LiveStoreEvent.EncodedWithMeta[];
} & {
    readonly newSyncState: SyncState;
} & {
    readonly mergeContext: MergeContext;
}, {}, {}>;
export declare class MergeResultRebase extends MergeResultRebase_base {
    toJSON: () => any;
}
declare const MergeResultReject_base: Schema.Class<MergeResultReject, {
    _tag: Schema.Literal<["reject"]>;
    /** The minimum id that the new events must have */
    expectedMinimumId: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
    mergeContext: typeof MergeContext;
}, Schema.Struct.Encoded<{
    _tag: Schema.Literal<["reject"]>;
    /** The minimum id that the new events must have */
    expectedMinimumId: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
    mergeContext: typeof MergeContext;
}>, never, {
    readonly _tag: "reject";
} & {
    readonly mergeContext: MergeContext;
} & {
    readonly expectedMinimumId: {
        readonly global: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
        readonly client: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    };
}, {}, {}>;
export declare class MergeResultReject extends MergeResultReject_base {
    toJSON: () => any;
}
declare const MergeResultUnexpectedError_base: Schema.Class<MergeResultUnexpectedError, {
    _tag: Schema.Literal<["unexpected-error"]>;
    cause: typeof UnexpectedError;
}, Schema.Struct.Encoded<{
    _tag: Schema.Literal<["unexpected-error"]>;
    cause: typeof UnexpectedError;
}>, never, {
    readonly _tag: "unexpected-error";
} & {
    readonly cause: UnexpectedError;
}, {}, {}>;
export declare class MergeResultUnexpectedError extends MergeResultUnexpectedError_base {
}
declare const MergeResult_base: Schema.Union<[typeof MergeResultAdvance, typeof MergeResultRebase, typeof MergeResultReject, typeof MergeResultUnexpectedError]>;
export declare class MergeResult extends MergeResult_base {
}
export declare const merge: ({ syncState, payload, isClientEvent, isEqualEvent, ignoreClientEvents, }: {
    syncState: SyncState;
    payload: typeof Payload.Type;
    isClientEvent: (event: LiveStoreEvent.EncodedWithMeta) => boolean;
    isEqualEvent: (a: LiveStoreEvent.EncodedWithMeta, b: LiveStoreEvent.EncodedWithMeta) => boolean;
    /** This is used in the leader which should ignore client events when receiving an upstream-advance payload */
    ignoreClientEvents?: boolean;
}) => typeof MergeResult.Type;
/**
 * Gets the index relative to `existingEvents` where the divergence point is
 * by comparing each event in `existingEvents` to the corresponding event in `incomingEvents`
 */
export declare const findDivergencePoint: ({ existingEvents, incomingEvents, isEqualEvent, isClientEvent, ignoreClientEvents, }: {
    existingEvents: ReadonlyArray<LiveStoreEvent.EncodedWithMeta>;
    incomingEvents: ReadonlyArray<LiveStoreEvent.EncodedWithMeta>;
    isEqualEvent: (a: LiveStoreEvent.EncodedWithMeta, b: LiveStoreEvent.EncodedWithMeta) => boolean;
    isClientEvent: (event: LiveStoreEvent.EncodedWithMeta) => boolean;
    ignoreClientEvents: boolean;
}) => number;
export {};
//# sourceMappingURL=syncstate.d.ts.map