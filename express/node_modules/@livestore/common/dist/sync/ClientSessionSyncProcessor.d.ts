import { Option, type Runtime, type Scope } from '@livestore/utils/effect';
import { Effect, Subscribable } from '@livestore/utils/effect';
import * as otel from '@opentelemetry/api';
import type { ClientSession, UnexpectedError } from '../adapter-types.js';
import * as LiveStoreEvent from '../schema/LiveStoreEvent.js';
import { type LiveStoreSchema } from '../schema/mod.js';
import * as SyncState from './syncstate.js';
/**
 * Rebase behaviour:
 * - We continously pull events from the leader and apply them to the local store.
 * - If there was a race condition (i.e. the leader and client session have both advacned),
 *   we'll need to rebase the local pending events on top of the leader's head.
 * - The goal is to never block the UI, so we'll interrupt rebasing if a new events is pushed by the client session.
 * - We also want to avoid "backwards-jumping" in the UI, so we'll transactionally apply state changes during a rebase.
 * - We might need to make the rebase behaviour configurable e.g. to let users manually trigger a rebase
 *
 * Longer term we should evalutate whether we can unify the ClientSessionSyncProcessor with the LeaderSyncProcessor.
 */
export declare const makeClientSessionSyncProcessor: ({ schema, clientSession, runtime, materializeEvent, rollback, refreshTables, span, params, confirmUnsavedChanges, }: {
    schema: LiveStoreSchema;
    clientSession: ClientSession;
    runtime: Runtime.Runtime<Scope.Scope>;
    materializeEvent: (eventDecoded: LiveStoreEvent.PartialAnyDecoded, options: {
        otelContext: otel.Context;
        withChangeset: boolean;
        materializerHashLeader: Option.Option<number>;
    }) => {
        writeTables: Set<string>;
        sessionChangeset: {
            _tag: "sessionChangeset";
            data: Uint8Array;
            debug: any;
        } | {
            _tag: "no-op";
        } | {
            _tag: "unset";
        };
        materializerHash: Option.Option<number>;
    };
    rollback: (changeset: Uint8Array) => void;
    refreshTables: (tables: Set<string>) => void;
    span: otel.Span;
    params: {
        leaderPushBatchSize: number;
    };
    /**
     * Currently only used in the web adapter:
     * If true, registers a beforeunload event listener to confirm unsaved changes.
     */
    confirmUnsavedChanges: boolean;
}) => ClientSessionSyncProcessor;
export interface ClientSessionSyncProcessor {
    push: (batch: ReadonlyArray<LiveStoreEvent.PartialAnyDecoded>, options: {
        otelContext: otel.Context;
    }) => {
        writeTables: Set<string>;
    };
    boot: Effect.Effect<void, UnexpectedError, Scope.Scope>;
    /**
     * Only used for debugging / observability.
     */
    syncState: Subscribable.Subscribable<SyncState.SyncState>;
    debug: {
        print: () => void;
        debugInfo: () => {
            rebaseCount: number;
            advanceCount: number;
        };
    };
}
//# sourceMappingURL=ClientSessionSyncProcessor.d.ts.map