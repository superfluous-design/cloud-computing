import type { Effect, HttpClient, Option, Scope, Stream, SubscriptionRef } from '@livestore/utils/effect';
import { Schema } from '@livestore/utils/effect';
import type { UnexpectedError } from '../adapter-types.js';
import type { InitialSyncOptions } from '../leader-thread/types.js';
import * as EventSequenceNumber from '../schema/EventSequenceNumber.js';
import type * as LiveStoreEvent from '../schema/LiveStoreEvent.js';
/**
 * Those arguments can be used to implement multi-tenancy etc and are passed in from the store.
 */
export type MakeBackendArgs = {
    storeId: string;
    clientId: string;
    payload: Schema.JsonValue | undefined;
};
export type SyncOptions = {
    backend?: SyncBackendConstructor<any>;
    /** @default { _tag: 'Skip' } */
    initialSyncOptions?: InitialSyncOptions;
    /**
     * What to do if there is an error during sync.
     *
     * Options:
     * `shutdown` will stop the sync processor and cause the app to crash.
     * `ignore` will log the error and let the app continue running acting as if it was offline.
     *
     * @default 'ignore'
     * */
    onSyncError?: 'shutdown' | 'ignore';
};
export type SyncBackendConstructor<TSyncMetadata = Schema.JsonValue> = (args: MakeBackendArgs) => Effect.Effect<SyncBackend<TSyncMetadata>, UnexpectedError, Scope.Scope | HttpClient.HttpClient>;
export type SyncBackend<TSyncMetadata = Schema.JsonValue> = {
    /**
     * Can be implemented to prepare a connection to the sync backend to speed up the first pull/push.
     */
    connect: Effect.Effect<void, IsOfflineError | UnexpectedError, HttpClient.HttpClient | Scope.Scope>;
    pull: (args: Option.Option<{
        cursor: EventSequenceNumber.EventSequenceNumber;
        metadata: Option.Option<TSyncMetadata>;
    }>) => Stream.Stream<{
        batch: ReadonlyArray<{
            eventEncoded: LiveStoreEvent.AnyEncodedGlobal;
            metadata: Option.Option<TSyncMetadata>;
        }>;
        remaining: number;
    }, IsOfflineError | InvalidPullError, HttpClient.HttpClient>;
    push: (
    /**
     * Constraints for batch:
     * - Number of events: 1-100
     * - sequence numbers must be in ascending order
     * */
    batch: ReadonlyArray<LiveStoreEvent.AnyEncodedGlobal>) => Effect.Effect<void, IsOfflineError | InvalidPushError, HttpClient.HttpClient>;
    isConnected: SubscriptionRef.SubscriptionRef<boolean>;
    /**
     * Metadata describing the sync backend. (Currently only used by devtools.)
     */
    metadata: {
        name: string;
        description: string;
    } & Record<string, Schema.JsonValue>;
};
declare const IsOfflineError_base: Schema.TaggedErrorClass<IsOfflineError, "IsOfflineError", {
    readonly _tag: Schema.tag<"IsOfflineError">;
}>;
export declare class IsOfflineError extends IsOfflineError_base {
}
declare const InvalidPushError_base: Schema.TaggedErrorClass<InvalidPushError, "InvalidPushError", {
    readonly _tag: Schema.tag<"InvalidPushError">;
} & {
    reason: Schema.Union<[Schema.TaggedStruct<"Unexpected", {
        message: typeof Schema.String;
    }>, Schema.TaggedStruct<"ServerAhead", {
        minimumExpectedNum: typeof Schema.Number;
        providedNum: typeof Schema.Number;
    }>]>;
}>;
export declare class InvalidPushError extends InvalidPushError_base {
}
declare const InvalidPullError_base: Schema.TaggedErrorClass<InvalidPullError, "InvalidPullError", {
    readonly _tag: Schema.tag<"InvalidPullError">;
} & {
    message: typeof Schema.String;
}>;
export declare class InvalidPullError extends InvalidPullError_base {
}
declare const LeaderAheadError_base: Schema.TaggedErrorClass<LeaderAheadError, "LeaderAheadError", {
    readonly _tag: Schema.tag<"LeaderAheadError">;
} & {
    minimumExpectedNum: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
    providedNum: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
}>;
export declare class LeaderAheadError extends LeaderAheadError_base {
}
export {};
//# sourceMappingURL=sync.d.ts.map