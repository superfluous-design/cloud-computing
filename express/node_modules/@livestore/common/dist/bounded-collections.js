/**
 * Creates a map that has a fixed number of entries.
 * Once hitting the bound, earliest insertions are removed
 */
export class BoundMap {
    #map = new Map();
    #sizeLimit;
    constructor(sizeLimit) {
        this.#sizeLimit = sizeLimit;
    }
    onEvict;
    set = (key, value) => {
        this.#map.set(key, value);
        // console.log(this.#map.size, this.#sizeLimit);
        if (this.#map.size > this.#sizeLimit) {
            const firstKey = this.#map.keys().next().value;
            const deletedValue = this.#map.get(firstKey);
            this.#map.delete(firstKey);
            if (this.onEvict) {
                this.onEvict(firstKey, deletedValue);
            }
        }
    };
    get = (key) => {
        return this.#map.get(key);
    };
    delete = (key) => {
        this.#map.delete(key);
    };
    keys = () => {
        return this.#map.keys();
    };
}
export class BoundSet {
    #map;
    constructor(sizeLimit) {
        this.#map = new BoundMap(sizeLimit);
        this.#map.onEvict = this.#onEvict;
    }
    #onEvict = (v) => {
        if (this.onEvict) {
            this.onEvict(v);
        }
    };
    onEvict;
    add = (v) => {
        this.#map.set(v, v);
    };
    [Symbol.iterator] = () => {
        return this.#map.keys();
    };
}
export class BoundArray {
    #array = [];
    sizeLimit;
    constructor(sizeLimit) {
        this.sizeLimit = sizeLimit;
    }
    static make = (sizeLimit, initial = []) => {
        const b = new BoundArray(sizeLimit);
        for (const v of initial) {
            b.push(v);
        }
        return b;
    };
    onEvict;
    push = (v) => {
        this.#array.push(v);
        if (this.#array.length > this.sizeLimit) {
            const first = this.#array.shift();
            if (first && this.onEvict) {
                this.onEvict(first);
            }
        }
    };
    get = (index) => {
        return this.#array[index];
    };
    delete = (index) => {
        this.#array.splice(index, 1);
    };
    get length() {
        return this.#array.length;
    }
    [Symbol.iterator] = () => {
        return this.#array[Symbol.iterator]();
    };
    map = (fn) => {
        return this.#array.map(fn);
    };
    clear = () => {
        this.#array = [];
    };
    sort = (fn) => {
        return this.#array.sort(fn);
    };
}
//# sourceMappingURL=bounded-collections.js.map