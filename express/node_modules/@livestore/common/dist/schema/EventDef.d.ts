import type { SingleOrReadonlyArray } from '@livestore/utils';
import { Schema } from '@livestore/utils/effect';
import type { BindValues } from '../sql-queries/sql-queries.js';
import type { ParamsObject } from '../util.js';
import type { QueryBuilder } from './state/sqlite/query-builder/mod.js';
export type EventDefMap = {
    map: Map<string | 'livestore.RawSql', EventDef.Any>;
};
export type EventDefRecord = {
    'livestore.RawSql': RawSqlEvent;
    [name: string]: EventDef.Any;
};
export type EventDef<TName extends string, TType, TEncoded = TType, TDerived extends boolean = false> = {
    name: TName;
    schema: Schema.Schema<TType, TEncoded>;
    options: {
        /**
         * When set to true, the mutation won't be synced across clients but
         */
        clientOnly: boolean;
        /** Warning: This feature is not fully implemented yet */
        facts: FactsCallback<TType> | undefined;
        derived: TDerived;
    };
    /** Helper function to construct a partial event */
    (args: TType): {
        name: TName;
        args: TType;
    };
    /** Helper function to construct a partial encoded event */
    encoded: (args: TEncoded) => {
        name: TName;
        args: TEncoded;
    };
    readonly Event: {
        name: TName;
        args: TType;
    };
};
export type FactsCallback<TTo> = (args: TTo, currentFacts: EventDefFacts) => {
    modify: {
        set: Iterable<EventDefFactInput>;
        unset: Iterable<EventDefFactInput>;
    };
    require: Iterable<EventDefFactInput>;
};
export declare namespace EventDef {
    type Any = EventDef<string, any, any, boolean>;
    type AnyWithoutFn = Pick<Any, 'name' | 'schema' | 'options'>;
}
export type EventDefKey = string;
export type EventDefFact = string;
export type EventDefFacts = ReadonlyMap<string, any>;
export type EventDefFactsGroup = {
    modifySet: EventDefFacts;
    modifyUnset: EventDefFacts;
    /**
     * Events on independent "dependency" branches are commutative which can facilitate more prioritized syncing
     */
    depRequire: EventDefFacts;
    depRead: EventDefFacts;
};
export type EventDefFactsSnapshot = Map<string, any>;
export type EventDefFactInput = string | readonly [string, any];
export declare const defineFacts: <TRecord extends Record<string, EventDefFactInput | ((...args: any[]) => EventDefFactInput)>>(record: TRecord) => TRecord;
export type DefineEventOptions<TTo, TDerived extends boolean = false> = {
    /** Warning: This feature is not fully implemented yet */
    facts?: (args: TTo, currentFacts: EventDefFacts) => {
        modify?: {
            set?: Iterable<EventDefFactInput>;
            unset?: Iterable<EventDefFactInput>;
        };
        /**
         * Two purposes: constrain history and constrain compaction
         */
        require?: Iterable<EventDefFactInput>;
    };
    /**
     * When set to true, the event won't be synced over the network
     */
    clientOnly?: boolean;
    derived?: TDerived;
};
export declare const defineEvent: <TName extends string, TType, TEncoded = TType, TDerived extends boolean = false>(args: {
    name: TName;
    schema: Schema.Schema<TType, TEncoded>;
} & DefineEventOptions<TType, TDerived>) => EventDef<TName, TType, TEncoded, TDerived>;
export declare const synced: <TName extends string, TType, TEncoded = TType>(args: {
    name: TName;
    schema: Schema.Schema<TType, TEncoded>;
} & Omit<DefineEventOptions<TType, false>, "derived" | "clientOnly">) => EventDef<TName, TType, TEncoded>;
export declare const clientOnly: <TName extends string, TType, TEncoded = TType>(args: {
    name: TName;
    schema: Schema.Schema<TType, TEncoded>;
} & Omit<DefineEventOptions<TType, false>, "derived" | "clientOnly">) => EventDef<TName, TType, TEncoded>;
export type MaterializerResult = {
    sql: string;
    bindValues: BindValues;
    writeTables?: ReadonlySet<string>;
} | QueryBuilder.Any | string;
export type MaterializerContextQuery = {
    (args: {
        query: string;
        bindValues: ParamsObject;
    }): ReadonlyArray<unknown>;
    <TResult>(qb: QueryBuilder<TResult, any, any>): TResult;
};
export type Materializer<TEventDef extends EventDef.AnyWithoutFn = EventDef.AnyWithoutFn> = (event: TEventDef['schema']['Type'], context: {
    currentFacts: EventDefFacts;
    eventDef: TEventDef;
    /** Can be used to query the current state */
    query: MaterializerContextQuery;
}) => SingleOrReadonlyArray<MaterializerResult>;
export declare const defineMaterializer: <TEventDef extends EventDef.AnyWithoutFn>(eventDef: TEventDef, materializer: Materializer<TEventDef>) => Materializer<TEventDef>;
export declare const materializers: <TInputRecord extends Record<string, EventDef.AnyWithoutFn>>(eventDefRecord: TInputRecord, handlers: { [TEventName in TInputRecord[keyof TInputRecord]["name"] as Extract<TInputRecord[keyof TInputRecord], {
    name: TEventName;
}>["options"]["derived"] extends true ? never : TEventName]: Materializer<Extract<TInputRecord[keyof TInputRecord], {
    name: TEventName;
}>>; }) => { [TEventName in TInputRecord[keyof TInputRecord]["name"] as Extract<TInputRecord[keyof TInputRecord], {
    name: TEventName;
}>["options"]["derived"] extends true ? never : TEventName]: Materializer<Extract<TInputRecord[keyof TInputRecord], {
    name: TEventName;
}>>; };
export declare const rawSqlEvent: EventDef<"livestore.RawSql", {
    readonly bindValues?: {
        readonly [x: string]: any;
    } | undefined;
    readonly sql: string;
    readonly writeTables?: ReadonlySet<string> | undefined;
}, {
    readonly sql: string;
    readonly bindValues?: {
        readonly [x: string]: any;
    } | undefined;
    readonly writeTables?: readonly string[] | undefined;
}, true>;
export declare const rawSqlMaterializer: Materializer<EventDef<"livestore.RawSql", {
    readonly bindValues?: {
        readonly [x: string]: any;
    } | undefined;
    readonly sql: string;
    readonly writeTables?: ReadonlySet<string> | undefined;
}, {
    readonly sql: string;
    readonly bindValues?: {
        readonly [x: string]: any;
    } | undefined;
    readonly writeTables?: readonly string[] | undefined;
}, true>>;
export type RawSqlEvent = typeof rawSqlEvent;
//# sourceMappingURL=EventDef.d.ts.map