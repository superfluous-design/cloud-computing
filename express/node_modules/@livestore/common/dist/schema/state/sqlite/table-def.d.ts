import { type Nullable } from '@livestore/utils';
import type { Schema, Types } from '@livestore/utils/effect';
import { SqliteDsl } from './db-schema/mod.js';
import type { QueryBuilder } from './query-builder/mod.js';
export declare const blob: SqliteDsl.ColDefFn<"blob">, boolean: SqliteDsl.SpecializedColDefFn<"integer", false, boolean>, column: <TColumnType extends SqliteDsl.FieldColumnType>(columnType: TColumnType) => SqliteDsl.ColDefFn<TColumnType>, datetime: SqliteDsl.SpecializedColDefFn<"text", false, Date>, integer: SqliteDsl.ColDefFn<"integer">, isColumnDefinition: (value: unknown) => value is SqliteDsl.ColumnDefinition<any, any>, json: SqliteDsl.SpecializedColDefFn<"text", true, unknown>, real: SqliteDsl.ColDefFn<"real">, text: SqliteDsl.ColDefFn<"text">;
export type StateType = 'singleton' | 'dynamic';
export type DefaultSqliteTableDef = SqliteDsl.TableDefinition<string, SqliteDsl.Columns>;
export type DefaultSqliteTableDefConstrained = SqliteDsl.TableDefinition<string, SqliteDsl.ConstraintColumns>;
export declare const TableDefInternalsSymbol: unique symbol;
export type TableDefInternalsSymbol = typeof TableDefInternalsSymbol;
export type TableDefBase<TSqliteDef extends DefaultSqliteTableDef = DefaultSqliteTableDefConstrained, TOptions extends TableOptions = TableOptions> = {
    sqliteDef: TSqliteDef;
    options: TOptions;
    rowSchema: SqliteDsl.StructSchemaForColumns<TSqliteDef['columns']>;
    insertSchema: SqliteDsl.InsertStructSchemaForColumns<TSqliteDef['columns']>;
};
export type TableDef<TSqliteDef extends DefaultSqliteTableDef = DefaultSqliteTableDefConstrained, TOptions extends TableOptions = TableOptions, TSchema = Schema.Schema<SqliteDsl.AnyIfConstained<TSqliteDef['columns'], {
    readonly [K in keyof TSqliteDef['columns']]: TSqliteDef['columns'][K]['schema']['Type'];
}>, SqliteDsl.AnyIfConstained<TSqliteDef['columns'], {
    readonly [K in keyof TSqliteDef['columns']]: TSqliteDef['columns'][K]['schema']['Encoded'];
}>>> = {
    sqliteDef: TSqliteDef;
    options: TOptions;
    rowSchema: TSchema;
    insertSchema: SqliteDsl.InsertStructSchemaForColumns<TSqliteDef['columns']>;
    readonly Type: Schema.Schema.Type<TSchema>;
    readonly Encoded: Schema.Schema.Encoded<TSchema>;
} & QueryBuilder<ReadonlyArray<Schema.Schema.Type<TSchema>>, TableDefBase<TSqliteDef & {}, TOptions>>;
export type TableOptionsInput = Partial<{
    indexes: SqliteDsl.Index[];
}>;
export declare namespace TableDef {
    type Any = TableDef<any, any>;
}
export type TableOptions = {
    /** Derived based on whether the table definition has one or more columns (besides the `id` column) */
    readonly isClientDocumentTable: boolean;
};
export declare const table: <TName extends string, TColumns extends SqliteDsl.Columns | SqliteDsl.ColumnDefinition<any, any>, const TOptionsInput extends TableOptionsInput = TableOptionsInput>(args: {
    name: TName;
    columns: TColumns;
} & Partial<TOptionsInput>) => TableDef<SqliteTableDefForInput<TName, TColumns>, WithDefaults<TColumns>>;
export declare namespace FromTable {
    type RowDecoded<TTableDef extends TableDefBase> = Types.Simplify<Nullable<Pick<RowDecodedAll<TTableDef>, NullableColumnNames<TTableDef>>> & Omit<RowDecodedAll<TTableDef>, NullableColumnNames<TTableDef>>>;
    type NullableColumnNames<TTableDef extends TableDefBase> = FromColumns.NullableColumnNames<TTableDef['sqliteDef']['columns']>;
    type Columns<TTableDef extends TableDefBase> = {
        [K in keyof TTableDef['sqliteDef']['columns']]: TTableDef['sqliteDef']['columns'][K]['columnType'];
    };
    type RowEncodeNonNullable<TTableDef extends TableDefBase> = {
        [K in keyof TTableDef['sqliteDef']['columns']]: Schema.Schema.Encoded<TTableDef['sqliteDef']['columns'][K]['schema']>;
    };
    type RowEncoded<TTableDef extends TableDefBase> = Types.Simplify<Nullable<Pick<RowEncodeNonNullable<TTableDef>, NullableColumnNames<TTableDef>>> & Omit<RowEncodeNonNullable<TTableDef>, NullableColumnNames<TTableDef>>>;
    type RowDecodedAll<TTableDef extends TableDefBase> = {
        [K in keyof TTableDef['sqliteDef']['columns']]: Schema.Schema.Type<TTableDef['sqliteDef']['columns'][K]['schema']>;
    };
}
export declare namespace FromColumns {
    type RowDecoded<TColumns extends SqliteDsl.Columns> = Types.Simplify<Nullable<Pick<RowDecodedAll<TColumns>, NullableColumnNames<TColumns>>> & Omit<RowDecodedAll<TColumns>, NullableColumnNames<TColumns>>>;
    type RowDecodedAll<TColumns extends SqliteDsl.Columns> = {
        [K in keyof TColumns]: Schema.Schema.Type<TColumns[K]['schema']>;
    };
    type RowEncoded<TColumns extends SqliteDsl.Columns> = Types.Simplify<Nullable<Pick<RowEncodeNonNullable<TColumns>, NullableColumnNames<TColumns>>> & Omit<RowEncodeNonNullable<TColumns>, NullableColumnNames<TColumns>>>;
    type RowEncodeNonNullable<TColumns extends SqliteDsl.Columns> = {
        [K in keyof TColumns]: Schema.Schema.Encoded<TColumns[K]['schema']>;
    };
    type NullableColumnNames<TColumns extends SqliteDsl.Columns> = keyof {
        [K in keyof TColumns as TColumns[K]['default'] extends true ? K : never]: {};
    };
    type RequiredInsertColumnNames<TColumns extends SqliteDsl.Columns> = SqliteDsl.FromColumns.RequiredInsertColumnNames<TColumns>;
    type InsertRowDecoded<TColumns extends SqliteDsl.Columns> = SqliteDsl.FromColumns.InsertRowDecoded<TColumns>;
}
export type SqliteTableDefForInput<TName extends string, TColumns extends SqliteDsl.Columns | SqliteDsl.ColumnDefinition<any, any>> = SqliteDsl.TableDefinition<TName, PrettifyFlat<ToColumns<TColumns>>>;
type WithDefaults<TColumns extends SqliteDsl.Columns | SqliteDsl.ColumnDefinition<any, any>> = {
    isClientDocumentTable: false;
    requiredInsertColumnNames: SqliteDsl.FromColumns.RequiredInsertColumnNames<ToColumns<TColumns>>;
};
export type PrettifyFlat<T> = T extends infer U ? {
    [K in keyof U]: U[K];
} : never;
type ToColumns<TColumns extends SqliteDsl.Columns | SqliteDsl.ColumnDefinition<any, any>> = TColumns extends SqliteDsl.Columns ? TColumns : TColumns extends SqliteDsl.ColumnDefinition<any, any> ? {
    value: TColumns;
} : never;
export {};
//# sourceMappingURL=table-def.d.ts.map