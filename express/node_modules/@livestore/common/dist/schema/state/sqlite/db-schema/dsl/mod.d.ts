import type { Nullable } from '@livestore/utils';
import type { Option, Types } from '@livestore/utils/effect';
import { Schema } from '@livestore/utils/effect';
import type * as SqliteAst from '../ast/sqlite.js';
import type { ColumnDefinition } from './field-defs.js';
export * from './field-defs.js';
export type DbSchema = {
    [key: string]: TableDefinition<string, Columns>;
};
/** Note when using the object-notation, the object keys are ignored and not used as table names */
export type DbSchemaInput = Record<string, TableDefinition<any, any>> | ReadonlyArray<TableDefinition<any, any>>;
/**
 * In case of ...
 * - array: we use the table name of each array item (= table definition) as the object key
 * - object: we discard the keys of the input object and use the table name of each object value (= table definition) as the new object key
 */
export type DbSchemaFromInputSchema<TSchemaInput extends DbSchemaInput> = TSchemaInput extends ReadonlyArray<TableDefinition<any, any>> ? {
    [K in TSchemaInput[number] as K['name']]: K;
} : TSchemaInput extends Record<string, TableDefinition<any, any>> ? {
    [K in keyof TSchemaInput as TSchemaInput[K]['name']]: TSchemaInput[K];
} : never;
export declare const makeDbSchema: <TDbSchemaInput extends DbSchemaInput>(schema: TDbSchemaInput) => DbSchemaFromInputSchema<TDbSchemaInput>;
export declare const table: <TTableName extends string, TColumns extends Columns, TIndexes extends Index[]>(name: TTableName, columns: TColumns, indexes?: TIndexes) => TableDefinition<TTableName, TColumns>;
export type AnyIfConstained<In, Out> = '__constrained' extends keyof In ? any : Out;
export type EmptyObjIfConstained<In> = '__constrained' extends keyof In ? {} : In;
export type StructSchemaForColumns<TCols extends ConstraintColumns> = Schema.Schema<AnyIfConstained<TCols, FromColumns.RowDecoded<TCols>>, AnyIfConstained<TCols, FromColumns.RowEncoded<TCols>>>;
export type InsertStructSchemaForColumns<TCols extends ConstraintColumns> = Schema.Schema<AnyIfConstained<TCols, FromColumns.InsertRowDecoded<TCols>>, AnyIfConstained<TCols, FromColumns.InsertRowEncoded<TCols>>>;
export declare const structSchemaForTable: <TTableDefinition extends TableDefinition<any, any>>(tableDef: TTableDefinition) => StructSchemaForColumns<TTableDefinition["columns"]>;
export declare const insertStructSchemaForTable: <TTableDefinition extends TableDefinition<any, any>>(tableDef: TTableDefinition) => InsertStructSchemaForColumns<TTableDefinition["columns"]>;
export type TableDefinition<TName extends string, TColumns extends Columns> = {
    name: TName;
    columns: TColumns;
    indexes?: ReadonlyArray<Index>;
    ast: SqliteAst.Table;
};
export type Columns = Record<string, ColumnDefinition<any, any>>;
export type IsSingleColumn<TColumns extends Columns | ColumnDefinition<any, any>> = TColumns extends ColumnDefinition<any, any> ? true : false;
/**
 * NOTE this is only needed to avoid a TS limitation where `StructSchemaForColumns` in the default case
 * results in `Record<string, any>` instead of `any`. (Thanks to Andarist for the workaround)
 *
 * Hopefully this can be removed in the future
 */
export type ConstraintColumns = Record<string, ColumnDefinition<any, any>> & {
    __constrained?: never;
};
export type Index = {
    name: string;
    columns: ReadonlyArray<string>;
    /** @default false */
    isUnique?: boolean;
};
export declare namespace FromTable {
    type RowDecoded<TTableDefinition extends TableDefinition<any, any>> = Types.Simplify<Nullable<Pick<RowDecodedAll<TTableDefinition>, NullableColumnNames<TTableDefinition>>> & Omit<RowDecodedAll<TTableDefinition>, NullableColumnNames<TTableDefinition>>>;
    type NullableColumnNames<TTableDefinition extends TableDefinition<any, any>> = FromColumns.NullableColumnNames<TTableDefinition['columns']>;
    type Columns<TTableDefinition extends TableDefinition<any, any>> = {
        [K in keyof TTableDefinition['columns']]: TTableDefinition['columns'][K]['columnType'];
    };
    type RowEncodeNonNullable<TTableDefinition extends TableDefinition<any, any>> = {
        [K in keyof TTableDefinition['columns']]: Schema.Schema.Encoded<TTableDefinition['columns'][K]['schema']>;
    };
    type RowEncoded<TTableDefinition extends TableDefinition<any, any>> = Types.Simplify<Nullable<Pick<RowEncodeNonNullable<TTableDefinition>, NullableColumnNames<TTableDefinition>>> & Omit<RowEncodeNonNullable<TTableDefinition>, NullableColumnNames<TTableDefinition>>>;
    type RowDecodedAll<TTableDefinition extends TableDefinition<any, any>> = {
        [K in keyof TTableDefinition['columns']]: Schema.Schema.Type<TTableDefinition['columns'][K]['schema']>;
    };
}
export declare namespace FromColumns {
    type RowDecoded<TColumns extends Columns> = Types.Simplify<Nullable<Pick<RowDecodedAll<TColumns>, NullableColumnNames<TColumns>>> & Omit<RowDecodedAll<TColumns>, NullableColumnNames<TColumns>>>;
    type RowDecodedAll<TColumns extends Columns> = {
        readonly [K in keyof TColumns]: Schema.Schema.Type<TColumns[K]['schema']>;
    };
    type RowEncodedAll<TColumns extends Columns> = {
        readonly [K in keyof TColumns]: Schema.Schema.Encoded<TColumns[K]['schema']>;
    };
    type RowEncoded<TColumns extends Columns> = Types.Simplify<Nullable<Pick<RowEncodeNonNullable<TColumns>, NullableColumnNames<TColumns>>> & Omit<RowEncodeNonNullable<TColumns>, NullableColumnNames<TColumns>>>;
    type RowEncodeNonNullable<TColumns extends Columns> = {
        readonly [K in keyof TColumns]: Schema.Schema.Encoded<TColumns[K]['schema']>;
    };
    type NullableColumnNames<TColumns extends Columns> = keyof {
        [K in keyof TColumns as TColumns[K] extends ColumnDefinition<any, true> ? K : never]: {};
    };
    type RequiredInsertColumns<TColumns extends Columns> = {
        [K in keyof TColumns as TColumns[K]['nullable'] extends true ? never : TColumns[K]['default'] extends Option.Some<any> ? never : K]: {};
    };
    type RequiredInsertColumnNames<TColumns extends Columns> = keyof RequiredInsertColumns<TColumns>;
    type RequiresInsertValues<TColumns extends Columns> = RequiredInsertColumnNames<TColumns> extends never ? false : true;
    type InsertRowDecoded<TColumns extends Columns> = Types.Simplify<Pick<RowDecodedAll<TColumns>, RequiredInsertColumnNames<TColumns>> & Partial<Omit<RowDecodedAll<TColumns>, RequiredInsertColumnNames<TColumns>>>>;
    type InsertRowEncoded<TColumns extends Columns> = Types.Simplify<Pick<RowEncodedAll<TColumns>, RequiredInsertColumnNames<TColumns>> & Partial<Omit<RowEncodedAll<TColumns>, RequiredInsertColumnNames<TColumns>>>>;
}
//# sourceMappingURL=mod.d.ts.map