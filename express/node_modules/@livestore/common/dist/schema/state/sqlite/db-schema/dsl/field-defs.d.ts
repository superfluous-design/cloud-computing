import { Option, Schema } from '@livestore/utils/effect';
export type ColumnDefinition<TEncoded, TDecoded> = {
    readonly columnType: FieldColumnType;
    readonly schema: Schema.Schema<TDecoded, TEncoded>;
    readonly default: Option.Option<TEncoded>;
    /** @default false */
    readonly nullable: boolean;
    /** @default false */
    readonly primaryKey: boolean;
};
export declare const isColumnDefinition: (value: unknown) => value is ColumnDefinition<any, any>;
export type ColumnDefinitionInput = {
    readonly schema?: Schema.Schema<unknown>;
    readonly default?: unknown | NoDefault;
    readonly nullable?: boolean;
    readonly primaryKey?: boolean;
};
export declare const NoDefault: unique symbol;
export type NoDefault = typeof NoDefault;
export type SqlDefaultValue = {
    readonly sql: string;
};
export declare const isSqlDefaultValue: (value: unknown) => value is SqlDefaultValue;
export type ColDefFn<TColumnType extends FieldColumnType> = {
    (): {
        columnType: TColumnType;
        schema: Schema.Schema<DefaultEncodedForColumnType<TColumnType>>;
        default: Option.None<never>;
        nullable: false;
        primaryKey: false;
    };
    <TEncoded extends DefaultEncodedForColumnType<TColumnType>, TDecoded = DefaultEncodedForColumnType<TColumnType>, const TNullable extends boolean = false, const TDefault extends TDecoded | SqlDefaultValue | NoDefault | (TNullable extends true ? null : never) = NoDefault, const TPrimaryKey extends boolean = false>(args: {
        schema?: Schema.Schema<TDecoded, TEncoded>;
        default?: TDefault;
        nullable?: TNullable;
        primaryKey?: TPrimaryKey;
    }): {
        columnType: TColumnType;
        schema: TNullable extends true ? Schema.Schema<NoInfer<TDecoded> | null, NoInfer<TEncoded> | null> : Schema.Schema<NoInfer<TDecoded>, NoInfer<TEncoded>>;
        default: TDefault extends NoDefault ? Option.None<never> : Option.Some<NoInfer<TDefault>>;
        nullable: NoInfer<TNullable>;
        primaryKey: NoInfer<TPrimaryKey>;
    };
};
export declare const column: <TColumnType extends FieldColumnType>(columnType: TColumnType) => ColDefFn<TColumnType>;
export declare const text: ColDefFn<'text'>;
export declare const integer: ColDefFn<'integer'>;
export declare const real: ColDefFn<'real'>;
export declare const blob: ColDefFn<'blob'>;
/**
 * `NoInfer` is needed for some generics to work properly in certain cases.
 * See full explanation here: https://gist.github.com/schickling/a15e96819826530492b41a10d79d3c04?permalink_comment_id=4805120#gistcomment-4805120
 *
 * Big thanks to @andarist for their help with this!
 */
type NoInfer<T> = [T][T extends any ? 0 : never];
export type SpecializedColDefFn<TColumnType extends FieldColumnType, TAllowsCustomSchema extends boolean, TBaseDecoded> = {
    (): {
        columnType: TColumnType;
        schema: Schema.Schema<TBaseDecoded, DefaultEncodedForColumnType<TColumnType>>;
        default: Option.None<never>;
        nullable: false;
        primaryKey: false;
    };
    <TDecoded = TBaseDecoded, const TNullable extends boolean = false, const TDefault extends TDecoded | NoDefault | (TNullable extends true ? null : never) = NoDefault, const TPrimaryKey extends boolean = false>(args: TAllowsCustomSchema extends true ? {
        schema?: Schema.Schema<TDecoded, any>;
        default?: TDefault;
        nullable?: TNullable;
        primaryKey?: TPrimaryKey;
    } : {
        default?: TDefault;
        nullable?: TNullable;
        primaryKey?: TPrimaryKey;
    }): {
        columnType: TColumnType;
        schema: TNullable extends true ? Schema.Schema<NoInfer<TDecoded> | null, DefaultEncodedForColumnType<TColumnType> | null> : Schema.Schema<NoInfer<TDecoded>, DefaultEncodedForColumnType<TColumnType>>;
        default: TDefault extends NoDefault ? Option.None<never> : Option.Some<TDefault>;
        nullable: NoInfer<TNullable>;
        primaryKey: NoInfer<TPrimaryKey>;
    };
};
export declare const json: SpecializedColDefFn<'text', true, unknown>;
export declare const datetime: SpecializedColDefFn<'text', false, Date>;
export declare const datetimeInteger: SpecializedColDefFn<'integer', false, Date>;
export declare const boolean: SpecializedColDefFn<'integer', false, boolean>;
export type FieldColumnType = 'text' | 'integer' | 'real' | 'blob';
export type DefaultEncodedForColumnType<TColumnType extends FieldColumnType> = TColumnType extends 'text' ? string : TColumnType extends 'integer' ? number : TColumnType extends 'real' ? number : TColumnType extends 'blob' ? Uint8Array : never;
export declare const defaultSchemaForColumnType: <TColumnType extends FieldColumnType>(columnType: TColumnType) => Schema.Schema<DefaultEncodedForColumnType<TColumnType>>;
export {};
//# sourceMappingURL=field-defs.d.ts.map