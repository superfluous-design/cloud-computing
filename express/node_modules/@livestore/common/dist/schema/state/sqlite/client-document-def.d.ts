import type { Option, Types } from '@livestore/utils/effect';
import { Schema } from '@livestore/utils/effect';
import { SessionIdSymbol } from '../../../adapter-types.js';
import type { EventDef, Materializer } from '../../EventDef.js';
import { SqliteDsl } from './db-schema/mod.js';
import type { QueryBuilder } from './query-builder/mod.js';
import type { TableDef, TableDefBase } from './table-def.js';
/**
 * Special:
 * - Synced across client sessions (e.g. tabs) but not across different clients
 * - Derived setters
 *   - Emits client-only events
 *   - Has implicit setter-reducers
 * - Similar to `React.useState` (except it's persisted)
 *
 * Careful:
 * - When changing the table definitions in a non-backwards compatible way, the state might be lost without
 *   explicit reducers to handle the old auto-generated events
 */
export declare const clientDocument: <TName extends string, TType, TEncoded, const TOptions extends ClientDocumentTableOptions.Input<NoInfer<TType>>>({ name, schema: valueSchema, ...inputOptions }: {
    name: TName;
    schema: Schema.Schema<TType, TEncoded>;
} & TOptions) => ClientDocumentTableDef<TName, TType, TEncoded, Types.Simplify<ClientDocumentTableOptions.WithDefaults<TOptions>>>;
export declare const deriveEventAndMaterializer: ({ name, valueSchema, defaultValue, partialSet, }: {
    name: string;
    valueSchema: Schema.Schema<any, any>;
    defaultValue: any;
    partialSet: boolean;
}) => {
    eventDef: EventDef<`${string}Set`, {
        readonly value: any;
        readonly id: string | typeof SessionIdSymbol;
    }, {
        readonly value: any;
        readonly id: string | typeof SessionIdSymbol;
    }, true>;
    materializer: Materializer<EventDef<`${string}Set`, {
        readonly value: any;
        readonly id: string | typeof SessionIdSymbol;
    }, {
        readonly value: any;
        readonly id: string | typeof SessionIdSymbol;
    }, true>>;
};
export declare const tableIsClientDocumentTable: <TTableDef extends TableDefBase>(tableDef: TTableDef) => tableDef is TTableDef & {
    options: {
        isClientDocumentTable: true;
    };
} & ClientDocumentTableDef.Trait<TTableDef["sqliteDef"]["name"], any, any, any>;
export type ClientDocumentTableOptions<TType> = {
    partialSet: boolean;
    default: {
        id: SessionIdSymbol | string | undefined;
        value: TType;
    };
};
export declare namespace ClientDocumentTableOptions {
    type Input<TType> = {
        /**
         * Whether to allow for partial set operations. Only applies if the schema is a struct.
         *
         * @default true
         */
        partialSet?: boolean;
        default: {
            id?: SessionIdSymbol | string | undefined;
            value: TType;
        };
    };
    type WithDefaults<TInput extends Input<any>> = {
        partialSet: TInput['partialSet'] extends false ? false : true;
        default: {
            id: TInput['default']['id'] extends string | SessionIdSymbol ? TInput['default']['id'] : undefined;
            value: TInput['default']['value'];
        };
    };
}
export type ClientDocumentTableDef<TName extends string, TType, TEncoded, TOptions extends ClientDocumentTableOptions<TType>> = TableDef<ClientDocumentTableDef.SqliteDef<TName, TType>, {
    isClientDocumentTable: true;
}> & ClientDocumentTableDef.Trait<TName, TType, TEncoded, TOptions>;
export declare namespace ClientDocumentTableDef {
    type Any = ClientDocumentTableDef<any, any, any, any>;
    type SqliteDef<TName extends string, TType> = SqliteDsl.TableDefinition<TName, {
        id: SqliteDsl.ColumnDefinition<string, string> & {
            default: Option.Some<string>;
        };
        value: SqliteDsl.ColumnDefinition<string, TType> & {
            default: Option.Some<TType>;
        };
    }>;
    type TableDefBase_<TName extends string, TType> = TableDefBase<SqliteDef<TName, TType>, {
        isClientDocumentTable: true;
    }>;
    interface Trait<TName extends string, TType, TEncoded, TOptions extends ClientDocumentTableOptions<TType>> {
        /**
         * Get the current value of the client document table.
         *
         * @example
         * ```ts
         * const someDocumentTable = State.SQLite.clientDocument({
         *   name: 'SomeDocumentTable',
         *   schema: Schema.Struct({
         *     someField: Schema.String,
         *   }),
         *   default: { value: { someField: 'some-value' } },
         * })
         *
         * const value$ = queryDb(someDocumentTable.get('some-id'))
         *
         * // When you've set a default id, you can omit the id argument
         *
         * const uiState = State.SQLite.clientDocument({
         *   name: 'UiState',
         *   schema: Schema.Struct({
         *     someField: Schema.String,
         *   }),
         *   default: { id: SessionIdSymbol, value: { someField: 'some-value' } },
         * })
         *
         * const value$ = queryDb(uiState.get())
         * ```
         */
        readonly get: MakeGetQueryBuilder<TName, TType, TOptions>;
        /**
         * Derived event definition for setting the value of the client document table.
         * If the document doesn't exist yet, the first .set event will create it.
         *
         * @example
         * ```ts
         * const someDocumentTable = State.SQLite.clientDocument({
         *   name: 'SomeDocumentTable',
         *   schema: Schema.Struct({
         *     someField: Schema.String,
         *     someOtherField: Schema.String,
         *   }),
         *   default: { value: { someField: 'some-default-value', someOtherField: 'some-other-default-value' } },
         * })
         *
         * const setEventDef = store.commit(someDocumentTable.set({ someField: 'explicit-value' }, 'some-id'))
         * // Will commit an event with the following payload:
         * // { id: 'some-id', value: { someField: 'explicit-value', someOtherField: 'some-other-default-value' } }
         * ```
         *
         * Similar to `.get`, you can omit the id argument if you've set a default id.
         *
         * @example
         * ```ts
         * const uiState = State.SQLite.clientDocument({
         *   name: 'UiState',
         *   schema: Schema.Struct({ someField: Schema.String }),
         *   default: { id: SessionIdSymbol, value: { someField: 'some-default-value' } },
         * })
         *
         * const setEventDef = store.commit(uiState.set({ someField: 'explicit-value' }))
         * // Will commit an event with the following payload:
         * // { id: '...', value: { someField: 'explicit-value' } }
         * //        ^^^
         * //        Automatically replaced with the client session id
         * ```
         */
        readonly set: SetEventDefLike<TName, TType, TOptions>;
        readonly Value: TType;
        readonly valueSchema: Schema.Schema<TType, TEncoded>;
        readonly default: TOptions['default'];
        readonly [ClientDocumentTableDefSymbol]: {
            readonly options: TOptions;
            readonly derived: {
                readonly setEventDef: SetEventDef<TName, TType, TOptions>;
                readonly setMaterializer: Materializer<SetEventDef<TName, TType, TOptions>>;
            };
        };
    }
    type GetOptions<TTableDef extends TraitAny> = TTableDef extends ClientDocumentTableDef.Trait<any, any, any, infer TOptions> ? TOptions : never;
    type TraitAny = Trait<any, any, any, any>;
    type DefaultIdType<TTableDef extends TraitAny> = TTableDef extends ClientDocumentTableDef.Trait<any, any, any, infer TOptions> ? TOptions['default']['id'] extends SessionIdSymbol | string ? TOptions['default']['id'] : never : never;
    type SetEventDefLike<TName extends string, TType, TOptions extends ClientDocumentTableOptions<TType>> = (TOptions['default']['id'] extends undefined ? (args: TOptions['partialSet'] extends false ? TType : Partial<TType>, id: string | SessionIdSymbol) => {
        name: `${TName}Set`;
        args: {
            id: string;
            value: TType;
        };
    } : (args: TOptions['partialSet'] extends false ? TType : Partial<TType>, id?: string | SessionIdSymbol) => {
        name: `${TName}Set`;
        args: {
            id: string;
            value: TType;
        };
    }) & {
        readonly name: `${TName}Set`;
        readonly schema: Schema.Schema<any>;
        readonly Event: {
            readonly name: `${TName}Set`;
            readonly args: {
                id: string;
                value: TType;
            };
        };
        readonly options: {
            derived: true;
            clientOnly: true;
            facts: undefined;
        };
    };
    type SetEventDef<TName extends string, TType, TOptions extends ClientDocumentTableOptions<TType>> = EventDef<TName, TOptions['partialSet'] extends false ? {
        id: string;
        value: TType;
    } : {
        id: string;
        value: Partial<TType>;
    }, any, true>;
    type MakeGetQueryBuilder<TName extends string, TType, TOptions extends ClientDocumentTableOptions<TType>> = TOptions extends ClientDocumentTableOptions<TType> & {
        default: {
            id: string | SessionIdSymbol;
        };
    } ? (id?: TOptions['default']['id'] | SessionIdSymbol, options?: {
        default: Partial<TType>;
    }) => QueryBuilder<TType, ClientDocumentTableDef.TableDefBase_<TName, TType>, QueryBuilder.ApiFeature> : (id: string | SessionIdSymbol, options?: {
        default: Partial<TType>;
    }) => QueryBuilder<TType, ClientDocumentTableDef.TableDefBase_<TName, TType>, QueryBuilder.ApiFeature>;
}
export declare const ClientDocumentTableDefSymbol: unique symbol;
export type ClientDocumentTableDefSymbol = typeof ClientDocumentTableDefSymbol;
//# sourceMappingURL=client-document-def.d.ts.map