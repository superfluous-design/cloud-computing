import { Schema } from '@livestore/utils/effect';
export declare const SCHEMA_META_TABLE = "__livestore_schema";
export declare const schemaMetaTable: import("./table-def.js").TableDef<import("./table-def.js").SqliteTableDefForInput<"__livestore_schema", {
    readonly tableName: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    /** ISO date format */
    readonly updatedAt: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
}>, {
    isClientDocumentTable: false;
    requiredInsertColumnNames: "tableName" | "schemaHash" | "updatedAt";
}, Schema.Schema<{
    readonly tableName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, {
    readonly tableName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, never>>;
export type SchemaMetaRow = typeof schemaMetaTable.Type;
export declare const SCHEMA_EVENT_DEFS_META_TABLE = "__livestore_schema_event_defs";
export declare const schemaEventDefsMetaTable: import("./table-def.js").TableDef<import("./table-def.js").SqliteTableDefForInput<"__livestore_schema_event_defs", {
    readonly eventName: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    /** ISO date format */
    readonly updatedAt: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
}>, {
    isClientDocumentTable: false;
    requiredInsertColumnNames: "schemaHash" | "updatedAt" | "eventName";
}, Schema.Schema<{
    readonly eventName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, {
    readonly eventName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, never>>;
export type SchemaEventDefsMetaRow = typeof schemaEventDefsMetaTable.Type;
/**
 * Table which stores SQLite changeset blobs which is used for rolling back
 * read-model state during rebasing.
 */
export declare const SESSION_CHANGESET_META_TABLE = "__livestore_session_changeset";
export declare const sessionChangesetMetaTable: import("./table-def.js").TableDef<import("./table-def.js").SqliteTableDefForInput<"__livestore_session_changeset", {
    readonly seqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly seqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly changeset: {
        columnType: "blob";
        schema: Schema.Schema<Uint8Array<ArrayBufferLike> | null, Uint8Array<ArrayBufferLike> | null, never>;
        default: import("effect/Option").None<never>;
        nullable: true;
        primaryKey: false;
    };
    readonly debug: {
        columnType: "text";
        schema: Schema.Schema<unknown, string | null, never>;
        default: import("effect/Option").Some<any> | import("effect/Option").None<never>;
        nullable: true;
        primaryKey: false;
    };
}>, {
    isClientDocumentTable: false;
    requiredInsertColumnNames: "seqNumGlobal" | "seqNumClient";
}, Schema.Schema<{
    readonly seqNumGlobal: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
    readonly seqNumClient: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    readonly changeset: Uint8Array<ArrayBufferLike> | null;
    readonly debug: unknown;
}, {
    readonly seqNumGlobal: number;
    readonly seqNumClient: number;
    readonly changeset: Uint8Array<ArrayBufferLike> | null;
    readonly debug: string | null;
}, never>>;
export type SessionChangesetMetaRow = typeof sessionChangesetMetaTable.Type;
export declare const LEADER_MERGE_COUNTER_TABLE = "__livestore_leader_merge_counter";
export declare const leaderMergeCounterTable: import("./table-def.js").TableDef<import("./table-def.js").SqliteTableDefForInput<"__livestore_leader_merge_counter", {
    readonly id: {
        columnType: "integer";
        schema: Schema.Schema<0, 0, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
    };
    readonly mergeCounter: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
    };
}>, {
    isClientDocumentTable: false;
    requiredInsertColumnNames: "id" | "mergeCounter";
}, Schema.Schema<{
    readonly id: 0;
    readonly mergeCounter: number;
}, {
    readonly id: 0;
    readonly mergeCounter: number;
}, never>>;
export type LeaderMergeCounterRow = typeof leaderMergeCounterTable.Type;
export declare const stateSystemTables: (import("./table-def.js").TableDef<import("./table-def.js").SqliteTableDefForInput<"__livestore_schema", {
    readonly tableName: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    /** ISO date format */
    readonly updatedAt: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
}>, {
    isClientDocumentTable: false;
    requiredInsertColumnNames: "tableName" | "schemaHash" | "updatedAt";
}, Schema.Schema<{
    readonly tableName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, {
    readonly tableName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, never>> | import("./table-def.js").TableDef<import("./table-def.js").SqliteTableDefForInput<"__livestore_schema_event_defs", {
    readonly eventName: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    /** ISO date format */
    readonly updatedAt: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
}>, {
    isClientDocumentTable: false;
    requiredInsertColumnNames: "schemaHash" | "updatedAt" | "eventName";
}, Schema.Schema<{
    readonly eventName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, {
    readonly eventName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, never>> | import("./table-def.js").TableDef<import("./table-def.js").SqliteTableDefForInput<"__livestore_session_changeset", {
    readonly seqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly seqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly changeset: {
        columnType: "blob";
        schema: Schema.Schema<Uint8Array<ArrayBufferLike> | null, Uint8Array<ArrayBufferLike> | null, never>;
        default: import("effect/Option").None<never>;
        nullable: true;
        primaryKey: false;
    };
    readonly debug: {
        columnType: "text";
        schema: Schema.Schema<unknown, string | null, never>;
        default: import("effect/Option").Some<any> | import("effect/Option").None<never>;
        nullable: true;
        primaryKey: false;
    };
}>, {
    isClientDocumentTable: false;
    requiredInsertColumnNames: "seqNumGlobal" | "seqNumClient";
}, Schema.Schema<{
    readonly seqNumGlobal: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
    readonly seqNumClient: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    readonly changeset: Uint8Array<ArrayBufferLike> | null;
    readonly debug: unknown;
}, {
    readonly seqNumGlobal: number;
    readonly seqNumClient: number;
    readonly changeset: Uint8Array<ArrayBufferLike> | null;
    readonly debug: string | null;
}, never>> | import("./table-def.js").TableDef<import("./table-def.js").SqliteTableDefForInput<"__livestore_leader_merge_counter", {
    readonly id: {
        columnType: "integer";
        schema: Schema.Schema<0, 0, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
    };
    readonly mergeCounter: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
    };
}>, {
    isClientDocumentTable: false;
    requiredInsertColumnNames: "id" | "mergeCounter";
}, Schema.Schema<{
    readonly id: 0;
    readonly mergeCounter: number;
}, {
    readonly id: 0;
    readonly mergeCounter: number;
}, never>>)[];
export declare const isStateSystemTable: (tableName: string) => boolean;
export declare const EVENTLOG_META_TABLE = "eventlog";
export declare const eventlogMetaTable: import("./table-def.js").TableDef<import("./table-def.js").SqliteTableDefForInput<"eventlog", {
    readonly seqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
    };
    readonly seqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
    };
    readonly parentSeqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly parentSeqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly name: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly argsJson: {
        columnType: "text";
        schema: Schema.Schema<any, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly clientId: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly sessionId: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly syncMetadataJson: {
        columnType: "text";
        schema: Schema.Schema<import("effect/Option").None<Schema.JsonValue> | import("effect/Option").Some<Schema.JsonValue>, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
}>, {
    isClientDocumentTable: false;
    requiredInsertColumnNames: "clientId" | "sessionId" | "name" | "schemaHash" | "seqNumGlobal" | "seqNumClient" | "parentSeqNumGlobal" | "parentSeqNumClient" | "argsJson" | "syncMetadataJson";
}, Schema.Schema<{
    readonly seqNumGlobal: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
    readonly seqNumClient: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    readonly parentSeqNumGlobal: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
    readonly parentSeqNumClient: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    readonly name: string;
    readonly argsJson: any;
    readonly clientId: string;
    readonly sessionId: string;
    readonly schemaHash: number;
    readonly syncMetadataJson: import("effect/Option").None<Schema.JsonValue> | import("effect/Option").Some<Schema.JsonValue>;
}, {
    readonly seqNumGlobal: number;
    readonly seqNumClient: number;
    readonly parentSeqNumGlobal: number;
    readonly parentSeqNumClient: number;
    readonly name: string;
    readonly argsJson: string;
    readonly clientId: string;
    readonly sessionId: string;
    readonly schemaHash: number;
    readonly syncMetadataJson: string;
}, never>>;
export type EventlogMetaRow = typeof eventlogMetaTable.Type;
export declare const SYNC_STATUS_TABLE = "__livestore_sync_status";
export declare const syncStatusTable: import("./table-def.js").TableDef<import("./table-def.js").SqliteTableDefForInput<"__livestore_sync_status", {
    readonly head: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
    };
}>, {
    isClientDocumentTable: false;
    requiredInsertColumnNames: "head";
}, Schema.Schema<{
    readonly head: number;
}, {
    readonly head: number;
}, never>>;
export type SyncStatusRow = typeof syncStatusTable.Type;
export declare const eventlogSystemTables: (import("./table-def.js").TableDef<import("./table-def.js").SqliteTableDefForInput<"eventlog", {
    readonly seqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
    };
    readonly seqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
    };
    readonly parentSeqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly parentSeqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly name: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly argsJson: {
        columnType: "text";
        schema: Schema.Schema<any, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly clientId: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly sessionId: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
    readonly syncMetadataJson: {
        columnType: "text";
        schema: Schema.Schema<import("effect/Option").None<Schema.JsonValue> | import("effect/Option").Some<Schema.JsonValue>, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
    };
}>, {
    isClientDocumentTable: false;
    requiredInsertColumnNames: "clientId" | "sessionId" | "name" | "schemaHash" | "seqNumGlobal" | "seqNumClient" | "parentSeqNumGlobal" | "parentSeqNumClient" | "argsJson" | "syncMetadataJson";
}, Schema.Schema<{
    readonly seqNumGlobal: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
    readonly seqNumClient: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    readonly parentSeqNumGlobal: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
    readonly parentSeqNumClient: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    readonly name: string;
    readonly argsJson: any;
    readonly clientId: string;
    readonly sessionId: string;
    readonly schemaHash: number;
    readonly syncMetadataJson: import("effect/Option").None<Schema.JsonValue> | import("effect/Option").Some<Schema.JsonValue>;
}, {
    readonly seqNumGlobal: number;
    readonly seqNumClient: number;
    readonly parentSeqNumGlobal: number;
    readonly parentSeqNumClient: number;
    readonly name: string;
    readonly argsJson: string;
    readonly clientId: string;
    readonly sessionId: string;
    readonly schemaHash: number;
    readonly syncMetadataJson: string;
}, never>> | import("./table-def.js").TableDef<import("./table-def.js").SqliteTableDefForInput<"__livestore_sync_status", {
    readonly head: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
    };
}>, {
    isClientDocumentTable: false;
    requiredInsertColumnNames: "head";
}, Schema.Schema<{
    readonly head: number;
}, {
    readonly head: number;
}, never>>)[];
//# sourceMappingURL=system-tables.d.ts.map