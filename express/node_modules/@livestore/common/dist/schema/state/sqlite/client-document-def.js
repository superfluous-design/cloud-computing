import { shouldNeverHappen } from '@livestore/utils';
import { Schema, SchemaAST } from '@livestore/utils/effect';
import { SessionIdSymbol } from '../../../adapter-types.js';
import { sql } from '../../../util.js';
import { defineEvent, defineMaterializer } from '../../EventDef.js';
import { SqliteDsl } from './db-schema/mod.js';
import { QueryBuilderAstSymbol, QueryBuilderTypeId } from './query-builder/mod.js';
import { table } from './table-def.js';
/**
 * Special:
 * - Synced across client sessions (e.g. tabs) but not across different clients
 * - Derived setters
 *   - Emits client-only events
 *   - Has implicit setter-reducers
 * - Similar to `React.useState` (except it's persisted)
 *
 * Careful:
 * - When changing the table definitions in a non-backwards compatible way, the state might be lost without
 *   explicit reducers to handle the old auto-generated events
 */
export const clientDocument = ({ name, schema: valueSchema, ...inputOptions }) => {
    const options = {
        partialSet: inputOptions.partialSet ?? true,
        default: {
            id: inputOptions.default.id,
            value: inputOptions.default.value,
        },
    };
    const columns = {
        id: SqliteDsl.text({ primaryKey: true }),
        value: SqliteDsl.json({ schema: valueSchema }),
    };
    const tableDef = table({ name, columns });
    // @ts-expect-error TODO properly type this
    tableDef.options.isClientDocumentTable = true;
    const { eventDef: derivedSetEventDef, materializer: derivedSetMaterializer } = deriveEventAndMaterializer({
        name,
        valueSchema,
        defaultValue: options.default.value,
        partialSet: options.partialSet,
    });
    const setEventDef = (...args) => {
        const [value, id = options.default.id] = args;
        return derivedSetEventDef({ id, value });
    };
    Object.defineProperty(setEventDef, 'name', { value: `${name}Set` });
    Object.defineProperty(setEventDef, 'schema', {
        value: Schema.Struct({
            id: Schema.String,
            value: options.partialSet ? Schema.partial(valueSchema) : valueSchema,
        }).annotations({ title: `${name}Set:Args` }),
    });
    Object.defineProperty(setEventDef, 'options', { value: { derived: true, clientOnly: true, facts: undefined } });
    const clientDocumentTableDefTrait = {
        get: makeGetQueryBuilder(() => clientDocumentTableDef),
        set: setEventDef,
        Value: 'only-for-type-inference',
        default: options.default,
        valueSchema,
        [ClientDocumentTableDefSymbol]: {
            derived: {
                setEventDef: derivedSetEventDef,
                setMaterializer: derivedSetMaterializer,
            },
            options,
        },
    };
    const clientDocumentTableDef = {
        ...tableDef,
        ...clientDocumentTableDefTrait,
    };
    return clientDocumentTableDef;
};
const mergeDefaultValues = (defaultValues, explicitDefaultValues) => {
    if (typeof defaultValues !== 'object' ||
        typeof explicitDefaultValues !== 'object' ||
        defaultValues === null ||
        explicitDefaultValues === null) {
        return explicitDefaultValues;
    }
    return Object.keys(defaultValues).reduce((acc, key) => {
        acc[key] = explicitDefaultValues[key] ?? defaultValues[key];
        return acc;
    }, {});
};
export const deriveEventAndMaterializer = ({ name, valueSchema, defaultValue, partialSet, }) => {
    const derivedSetEventDef = defineEvent({
        name: `${name}Set`,
        schema: Schema.Struct({
            id: Schema.Union(Schema.String, Schema.UniqueSymbolFromSelf(SessionIdSymbol)),
            value: partialSet ? Schema.partial(valueSchema) : valueSchema,
        }).annotations({ title: `${name}Set:Args` }),
        clientOnly: true,
        derived: true,
    });
    const derivedSetMaterializer = defineMaterializer(derivedSetEventDef, ({ id, value }) => {
        if (id === SessionIdSymbol) {
            return shouldNeverHappen(`SessionIdSymbol needs to be replaced before materializing the set event`);
        }
        // Override the full value if it's not an object or no partial set is allowed
        const schemaProps = SchemaAST.getPropertySignatures(valueSchema.ast);
        if (schemaProps.length === 0 || partialSet === false) {
            const valueColJsonSchema = Schema.parseJson(valueSchema);
            const encodedInsertValue = Schema.encodeSyncDebug(valueColJsonSchema)(value ?? defaultValue);
            const encodedUpdateValue = Schema.encodeSyncDebug(valueColJsonSchema)(value);
            return {
                sql: `INSERT INTO '${name}' (id, value) VALUES (?, ?) ON CONFLICT (id) DO UPDATE SET value = ?`,
                bindValues: [id, encodedInsertValue, encodedUpdateValue],
                writeTables: new Set([name]),
            };
        }
        else {
            const valueColJsonSchema = Schema.parseJson(Schema.partial(valueSchema));
            const encodedInsertValue = Schema.encodeSyncDebug(valueColJsonSchema)(mergeDefaultValues(defaultValue, value));
            let jsonSetSql = 'value';
            const setBindValues = [];
            const keys = Object.keys(value);
            const partialUpdateSchema = valueSchema.pipe(Schema.pick(...keys));
            const encodedPartialUpdate = Schema.encodeSyncDebug(partialUpdateSchema)(value);
            for (const key in encodedPartialUpdate) {
                const encodedValueForKey = encodedPartialUpdate[key];
                // Skipping undefined values
                if (encodedValueForKey === undefined) {
                    continue;
                }
                jsonSetSql = `json_set(${jsonSetSql}, ?, json(?))`;
                setBindValues.push(`$.${key}`, JSON.stringify(encodedValueForKey));
            }
            const onConflictClause = setBindValues.length > 0
                ? `ON CONFLICT (id) DO UPDATE SET value = ${jsonSetSql}`
                : 'ON CONFLICT (id) DO NOTHING';
            const sqlQuery = `
      INSERT INTO '${name}' (id, value)
      VALUES (?, ?)
      ${onConflictClause}
    `;
            return {
                sql: sqlQuery,
                bindValues: [id, encodedInsertValue, ...setBindValues],
                writeTables: new Set([name]),
            };
        }
    });
    return { eventDef: derivedSetEventDef, materializer: derivedSetMaterializer };
};
export const tableIsClientDocumentTable = (tableDef) => tableDef.options.isClientDocumentTable === true;
const makeGetQueryBuilder = (getTableDef) => {
    return ((...args) => {
        const tableDef = getTableDef();
        const [id = tableDef[ClientDocumentTableDefSymbol].options.default.id, options = {}] = args;
        const explicitDefaultValues = options.default ?? tableDef[ClientDocumentTableDefSymbol].options.default.value;
        const ast = {
            _tag: 'RowQuery',
            tableDef,
            id,
            explicitDefaultValues,
        };
        const query = sql `SELECT * FROM '${tableDef.sqliteDef.name}' WHERE id = ?`;
        return {
            [QueryBuilderTypeId]: QueryBuilderTypeId,
            [QueryBuilderAstSymbol]: ast,
            ResultType: 'only-for-type-inference',
            asSql: () => ({ query, bindValues: [id] }),
            toString: () => query.toString(),
            ...{}, // Needed for type cast
        };
    });
};
export const ClientDocumentTableDefSymbol = Symbol('ClientDocumentTableDef');
//# sourceMappingURL=client-document-def.js.map