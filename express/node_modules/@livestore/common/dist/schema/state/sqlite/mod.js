import { shouldNeverHappen } from '@livestore/utils';
import { rawSqlEvent, rawSqlMaterializer } from '../../EventDef.js';
import { ClientDocumentTableDefSymbol, tableIsClientDocumentTable } from './client-document-def.js';
import { SqliteAst } from './db-schema/mod.js';
import { stateSystemTables } from './system-tables.js';
export * from './table-def.js';
export { ClientDocumentTableDefSymbol, tableIsClientDocumentTable, clientDocument, } from './client-document-def.js';
export * from '../../EventDef.js';
export const makeState = (inputSchema) => {
    const inputTables = Array.isArray(inputSchema.tables)
        ? inputSchema.tables
        : Object.values(inputSchema.tables);
    const tables = new Map();
    for (const tableDef of inputTables) {
        const sqliteDef = tableDef.sqliteDef;
        // TODO validate tables (e.g. index names are unique)
        if (tables.has(sqliteDef.ast.name)) {
            shouldNeverHappen(`Duplicate table name: ${sqliteDef.ast.name}. Please use unique names for tables.`);
        }
        tables.set(sqliteDef.ast.name, tableDef);
    }
    for (const tableDef of stateSystemTables) {
        tables.set(tableDef.sqliteDef.name, tableDef);
    }
    const materializers = new Map();
    for (const [name, materializer] of Object.entries(inputSchema.materializers)) {
        materializers.set(name, materializer);
    }
    materializers.set(rawSqlEvent.name, rawSqlMaterializer);
    for (const tableDef of inputTables) {
        if (tableIsClientDocumentTable(tableDef)) {
            materializers.set(tableDef[ClientDocumentTableDefSymbol].derived.setEventDef.name, tableDef[ClientDocumentTableDefSymbol].derived.setMaterializer);
        }
    }
    const hash = SqliteAst.hash({
        _tag: 'dbSchema',
        tables: [...tables.values()].map((_) => _.sqliteDef.ast),
    });
    return { sqlite: { tables, migrations: inputSchema.migrations ?? { strategy: 'auto' }, hash }, materializers };
};
//# sourceMappingURL=mod.js.map