import { Option, Schema } from '@livestore/utils/effect';
import type { EventDef, EventDefRecord } from './EventDef.js';
import * as EventSequenceNumber from './EventSequenceNumber.js';
import type { LiveStoreSchema } from './schema.js';
export declare namespace ForEventDef {
    type PartialDecoded<TEventDef extends EventDef.Any> = {
        name: TEventDef['name'];
        args: Schema.Schema.Type<TEventDef['schema']>;
    };
    type PartialEncoded<TEventDef extends EventDef.Any> = {
        name: TEventDef['name'];
        args: Schema.Schema.Encoded<TEventDef['schema']>;
    };
    type Decoded<TEventDef extends EventDef.Any> = {
        name: TEventDef['name'];
        args: Schema.Schema.Type<TEventDef['schema']>;
        seqNum: EventSequenceNumber.EventSequenceNumber;
        parentSeqNum: EventSequenceNumber.EventSequenceNumber;
        clientId: string;
        sessionId: string;
    };
    type Encoded<TEventDef extends EventDef.Any> = {
        name: TEventDef['name'];
        args: Schema.Schema.Encoded<TEventDef['schema']>;
        seqNum: EventSequenceNumber.EventSequenceNumber;
        parentSeqNum: EventSequenceNumber.EventSequenceNumber;
        clientId: string;
        sessionId: string;
    };
}
export type AnyDecoded = ForEventDef.Decoded<EventDef.Any>;
export declare const AnyDecoded: Schema.Struct<{
    name: typeof Schema.String;
    args: typeof Schema.Any;
    seqNum: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
    parentSeqNum: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
    clientId: typeof Schema.String;
    sessionId: typeof Schema.String;
}>;
export type AnyEncoded = ForEventDef.Encoded<EventDef.Any>;
export declare const AnyEncoded: Schema.Struct<{
    name: typeof Schema.String;
    args: typeof Schema.Any;
    seqNum: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
    parentSeqNum: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
    clientId: typeof Schema.String;
    sessionId: typeof Schema.String;
}>;
export declare const AnyEncodedGlobal: Schema.Struct<{
    name: typeof Schema.String;
    args: typeof Schema.Any;
    seqNum: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
    parentSeqNum: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
    clientId: typeof Schema.String;
    sessionId: typeof Schema.String;
}>;
export type AnyEncodedGlobal = typeof AnyEncodedGlobal.Type;
export type PartialAnyDecoded = ForEventDef.PartialDecoded<EventDef.Any>;
export type PartialAnyEncoded = ForEventDef.PartialEncoded<EventDef.Any>;
export declare const PartialAnyEncoded: Schema.Struct<{
    name: typeof Schema.String;
    args: typeof Schema.Any;
}>;
export type PartialForSchema<TSchema extends LiveStoreSchema> = {
    [K in keyof TSchema['_EventDefMapType']]: ForEventDef.PartialDecoded<TSchema['_EventDefMapType'][K]>;
}[keyof TSchema['_EventDefMapType']];
export type ForSchema<TSchema extends LiveStoreSchema> = {
    [K in keyof TSchema['_EventDefMapType']]: ForEventDef.Decoded<TSchema['_EventDefMapType'][K]>;
}[keyof TSchema['_EventDefMapType']];
export declare const isPartialEventDef: (event: AnyDecoded | PartialAnyDecoded) => event is PartialAnyDecoded;
export type ForEventDefRecord<TEventDefRecord extends EventDefRecord> = Schema.Schema<{
    [K in keyof TEventDefRecord]: {
        name: K;
        args: Schema.Schema.Type<TEventDefRecord[K]['schema']>;
        seqNum: EventSequenceNumber.EventSequenceNumber;
        parentSeqNum: EventSequenceNumber.EventSequenceNumber;
        clientId: string;
        sessionId: string;
    };
}[keyof TEventDefRecord], {
    [K in keyof TEventDefRecord]: {
        name: K;
        args: Schema.Schema.Encoded<TEventDefRecord[K]['schema']>;
        seqNum: EventSequenceNumber.EventSequenceNumber;
        parentSeqNum: EventSequenceNumber.EventSequenceNumber;
        clientId: string;
        sessionId: string;
    };
}[keyof TEventDefRecord]>;
export type EventDefPartialSchema<TEventDefRecord extends EventDefRecord> = Schema.Schema<{
    [K in keyof TEventDefRecord]: {
        name: K;
        args: Schema.Schema.Type<TEventDefRecord[K]['schema']>;
    };
}[keyof TEventDefRecord], {
    [K in keyof TEventDefRecord]: {
        name: K;
        args: Schema.Schema.Encoded<TEventDefRecord[K]['schema']>;
    };
}[keyof TEventDefRecord]>;
export declare const makeEventDefSchema: <TSchema extends LiveStoreSchema>(schema: TSchema) => ForEventDefRecord<TSchema["_EventDefMapType"]>;
export declare const makeEventDefPartialSchema: <TSchema extends LiveStoreSchema>(schema: TSchema) => EventDefPartialSchema<TSchema["_EventDefMapType"]>;
export declare const makeEventDefSchemaMemo: <TSchema extends LiveStoreSchema>(schema: TSchema) => ForEventDefRecord<TSchema["_EventDefMapType"]>;
declare const EncodedWithMeta_base: Schema.Class<EncodedWithMeta, {
    name: typeof Schema.String;
    args: typeof Schema.Any;
    seqNum: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
    parentSeqNum: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
    clientId: typeof Schema.String;
    sessionId: typeof Schema.String;
    meta: Schema.PropertySignature<":", {
        sessionChangeset: {
            readonly _tag: "sessionChangeset";
            readonly debug?: any;
            readonly data: Uint8Array<ArrayBufferLike>;
        } | {
            readonly _tag: "no-op";
        } | {
            readonly _tag: "unset";
        };
        syncMetadata: Option.Option<Schema.JsonValue>;
        materializerHashLeader: Option.Option<number>;
        materializerHashSession: Option.Option<number>;
    }, never, "?:", {
        sessionChangeset: {
            readonly _tag: "sessionChangeset";
            readonly data: readonly number[];
            readonly debug?: any;
        } | {
            readonly _tag: "no-op";
        } | {
            readonly _tag: "unset";
        };
        syncMetadata: {
            readonly _tag: "None";
        } | {
            readonly _tag: "Some";
            readonly value: Schema.JsonValue;
        };
        materializerHashLeader: {
            readonly _tag: "None";
        } | {
            readonly _tag: "Some";
            readonly value: number;
        };
        materializerHashSession: {
            readonly _tag: "None";
        } | {
            readonly _tag: "Some";
            readonly value: number;
        };
    } | undefined, true, never>;
}, Schema.Struct.Encoded<{
    name: typeof Schema.String;
    args: typeof Schema.Any;
    seqNum: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
    parentSeqNum: Schema.Struct<{
        global: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        client: Schema.BrandSchema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
    }>;
    clientId: typeof Schema.String;
    sessionId: typeof Schema.String;
    meta: Schema.PropertySignature<":", {
        sessionChangeset: {
            readonly _tag: "sessionChangeset";
            readonly debug?: any;
            readonly data: Uint8Array<ArrayBufferLike>;
        } | {
            readonly _tag: "no-op";
        } | {
            readonly _tag: "unset";
        };
        syncMetadata: Option.Option<Schema.JsonValue>;
        materializerHashLeader: Option.Option<number>;
        materializerHashSession: Option.Option<number>;
    }, never, "?:", {
        sessionChangeset: {
            readonly _tag: "sessionChangeset";
            readonly data: readonly number[];
            readonly debug?: any;
        } | {
            readonly _tag: "no-op";
        } | {
            readonly _tag: "unset";
        };
        syncMetadata: {
            readonly _tag: "None";
        } | {
            readonly _tag: "Some";
            readonly value: Schema.JsonValue;
        };
        materializerHashLeader: {
            readonly _tag: "None";
        } | {
            readonly _tag: "Some";
            readonly value: number;
        };
        materializerHashSession: {
            readonly _tag: "None";
        } | {
            readonly _tag: "Some";
            readonly value: number;
        };
    } | undefined, true, never>;
}>, never, {
    readonly clientId: string;
} & {
    readonly sessionId: string;
} & {
    readonly name: string;
} & {
    readonly args: any;
} & {
    readonly seqNum: {
        readonly global: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
        readonly client: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    };
} & {
    readonly parentSeqNum: {
        readonly global: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
        readonly client: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    };
} & {
    readonly meta?: {
        sessionChangeset: {
            readonly _tag: "sessionChangeset";
            readonly debug?: any;
            readonly data: Uint8Array<ArrayBufferLike>;
        } | {
            readonly _tag: "no-op";
        } | {
            readonly _tag: "unset";
        };
        syncMetadata: Option.Option<Schema.JsonValue>;
        materializerHashLeader: Option.Option<number>;
        materializerHashSession: Option.Option<number>;
    } | undefined;
}, {}, {}>;
/** Equivalent to AnyEncoded but with a meta field and some convenience methods */
export declare class EncodedWithMeta extends EncodedWithMeta_base {
    toJSON: () => any;
    /**
     * Example: (global event)
     * For event e2 → e1 which should be rebased on event e3 → e2
     * the resulting event num will be e4 → e3
     *
     * Example: (client event)
     * For event e2+1 → e2 which should be rebased on event e3 → e2
     * the resulting event num will be e3+1 → e3
     *
     * Syntax: e2+2 → e2+1
     *          ^ ^    ^ ^
     *          | |    | +- client parent number
     *          | |    +--- global parent number
     *          | +-- client number
     *          +---- global number
     * Client num is ommitted for global events
     */
    rebase: (parentSeqNum: EventSequenceNumber.EventSequenceNumber, isClient: boolean) => EncodedWithMeta;
    static fromGlobal: (event: AnyEncodedGlobal, meta: {
        syncMetadata: Option.Option<Schema.JsonValue>;
        materializerHashLeader: Option.Option<number>;
        materializerHashSession: Option.Option<number>;
    }) => EncodedWithMeta;
    toGlobal: () => AnyEncodedGlobal;
}
/** NOTE `meta` is not considered for equality */
export declare const isEqualEncoded: (a: AnyEncoded, b: AnyEncoded) => boolean;
export {};
//# sourceMappingURL=LiveStoreEvent.d.ts.map