import type { Scope } from '@livestore/utils/effect';
import { Effect } from '@livestore/utils/effect';
import type { SqliteDb } from '../adapter-types.js';
import { UnexpectedError } from '../adapter-types.js';
import type { LiveStoreSchema } from '../schema/mod.js';
import type { InitialBlockingSyncContext, LeaderSyncProcessor } from './types.js';
/**
 * The LeaderSyncProcessor manages synchronization of events between
 * the local state and the sync backend, ensuring efficient and orderly processing.
 *
 * In the LeaderSyncProcessor, pulling always has precedence over pushing.
 *
 * Responsibilities:
 * - Queueing incoming local events in a localPushesQueue.
 * - Broadcasting events to client sessions via pull queues.
 * - Pushing events to the sync backend.
 *
 * Notes:
 *
 * local push processing:
 * - localPushesQueue:
 *   - Maintains events in ascending order.
 *   - Uses `Deferred` objects to resolve/reject events based on application success.
 * - Processes events from the queue, applying events in batches.
 * - Controlled by a `Latch` to manage execution flow.
 * - The latch closes on pull receipt and re-opens post-pull completion.
 * - Processes up to `maxBatchSize` events per cycle.
 *
 * Currently we're advancing the db read model and eventlog in lockstep, but we could also decouple this in the future
 *
 * Tricky concurrency scenarios:
 * - Queued local push batches becoming invalid due to a prior local push item being rejected.
 *   Solution: Introduce a generation number for local push batches which is used to filter out old batches items in case of rejection.
 *
 */
export declare const makeLeaderSyncProcessor: ({ schema, dbEventlogMissing, dbEventlog, dbState, dbStateMissing, initialBlockingSyncContext, onError, params, testing, }: {
    schema: LiveStoreSchema;
    /** Only used to know whether we can safely query dbEventlog during setup execution */
    dbEventlogMissing: boolean;
    dbEventlog: SqliteDb;
    dbState: SqliteDb;
    /** Only used to know whether we can safely query dbState during setup execution */
    dbStateMissing: boolean;
    initialBlockingSyncContext: InitialBlockingSyncContext;
    onError: "shutdown" | "ignore";
    params: {
        /**
         * @default 10
         */
        localPushBatchSize?: number;
        /**
         * @default 50
         */
        backendPushBatchSize?: number;
    };
    testing: {
        delays?: {
            localPushProcessing?: Effect.Effect<void>;
        };
    };
}) => Effect.Effect<LeaderSyncProcessor, UnexpectedError, Scope.Scope>;
//# sourceMappingURL=LeaderSyncProcessor.d.ts.map