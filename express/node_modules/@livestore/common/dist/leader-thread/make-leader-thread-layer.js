import { Deferred, Effect, Layer, Queue, SubscriptionRef } from '@livestore/utils/effect';
import { UnexpectedError } from '../adapter-types.js';
import { LiveStoreEvent } from '../schema/mod.js';
import { sql } from '../util.js';
import * as Eventlog from './eventlog.js';
import { bootDevtools } from './leader-worker-devtools.js';
import { makeLeaderSyncProcessor } from './LeaderSyncProcessor.js';
import { makeMaterializeEvent } from './materialize-event.js';
import { recreateDb } from './recreate-db.js';
import { LeaderThreadCtx } from './types.js';
export const makeLeaderThreadLayer = ({ schema, storeId, clientId, syncPayload, makeSqliteDb, syncOptions, dbState, dbEventlog, devtoolsOptions, shutdownChannel, params, testing, }) => Effect.gen(function* () {
    const bootStatusQueue = yield* Queue.unbounded().pipe(Effect.acquireRelease(Queue.shutdown));
    // TODO do more validation here than just checking the count of tables
    // Either happens on initial boot or if schema changes
    const dbEventlogMissing = dbEventlog.select(sql `select count(*) as count from sqlite_master`)[0].count === 0;
    const dbStateMissing = dbState.select(sql `select count(*) as count from sqlite_master`)[0].count === 0;
    const syncBackend = syncOptions?.backend === undefined
        ? undefined
        : yield* syncOptions.backend({ storeId, clientId, payload: syncPayload });
    if (syncBackend !== undefined) {
        // We're already connecting to the sync backend concurrently
        yield* syncBackend.connect.pipe(Effect.tapCauseLogPretty, Effect.forkScoped);
    }
    const initialBlockingSyncContext = yield* makeInitialBlockingSyncContext({
        initialSyncOptions: syncOptions?.initialSyncOptions ?? { _tag: 'Skip' },
        bootStatusQueue,
    });
    const syncProcessor = yield* makeLeaderSyncProcessor({
        schema,
        dbEventlogMissing,
        dbEventlog,
        dbState,
        dbStateMissing,
        initialBlockingSyncContext,
        onError: syncOptions?.onSyncError ?? 'ignore',
        params: {
            localPushBatchSize: params?.localPushBatchSize,
            backendPushBatchSize: params?.backendPushBatchSize,
        },
        testing: {
            delays: testing?.syncProcessor?.delays,
        },
    });
    const extraIncomingMessagesQueue = yield* Queue.unbounded().pipe(Effect.acquireRelease(Queue.shutdown));
    const devtoolsContext = devtoolsOptions.enabled
        ? {
            enabled: true,
            syncBackendLatch: yield* Effect.makeLatch(true),
            syncBackendLatchState: yield* SubscriptionRef.make({ latchClosed: false }),
        }
        : { enabled: false };
    const materializeEvent = yield* makeMaterializeEvent({ schema, dbState, dbEventlog });
    const ctx = {
        schema,
        bootStatusQueue,
        storeId,
        clientId,
        dbState,
        dbEventlog,
        makeSqliteDb,
        eventSchema: LiveStoreEvent.makeEventDefSchema(schema),
        shutdownStateSubRef: yield* SubscriptionRef.make('running'),
        shutdownChannel,
        syncBackend,
        syncProcessor,
        materializeEvent,
        extraIncomingMessagesQueue,
        devtools: devtoolsContext,
        // State will be set during `bootLeaderThread`
        initialState: {},
    };
    // @ts-expect-error For debugging purposes
    globalThis.__leaderThreadCtx = ctx;
    const layer = Layer.succeed(LeaderThreadCtx, ctx);
    ctx.initialState = yield* bootLeaderThread({
        dbStateMissing,
        initialBlockingSyncContext,
        devtoolsOptions,
    }).pipe(Effect.provide(layer));
    return layer;
}).pipe(Effect.withSpan('@livestore/common:leader-thread:boot'), Effect.withSpanScoped('@livestore/common:leader-thread'), UnexpectedError.mapToUnexpectedError, Effect.tapCauseLogPretty, Layer.unwrapScoped);
const makeInitialBlockingSyncContext = ({ initialSyncOptions, bootStatusQueue, }) => Effect.gen(function* () {
    const ctx = {
        isDone: false,
        processedEvents: 0,
        total: -1,
    };
    const blockingDeferred = initialSyncOptions._tag === 'Blocking' ? yield* Deferred.make() : undefined;
    if (blockingDeferred !== undefined && initialSyncOptions._tag === 'Blocking') {
        yield* Deferred.succeed(blockingDeferred, void 0).pipe(Effect.delay(initialSyncOptions.timeout), Effect.forkScoped);
    }
    return {
        blockingDeferred,
        update: ({ processed, remaining }) => Effect.gen(function* () {
            if (ctx.isDone === true)
                return;
            if (ctx.total === -1) {
                ctx.total = remaining + processed;
            }
            ctx.processedEvents += processed;
            yield* Queue.offer(bootStatusQueue, {
                stage: 'syncing',
                progress: { done: ctx.processedEvents, total: ctx.total },
            });
            if (remaining === 0 && blockingDeferred !== undefined) {
                yield* Deferred.succeed(blockingDeferred, void 0);
                ctx.isDone = true;
            }
        }),
    };
});
/**
 * Blocks until the leader thread has finished its initial setup.
 * It also starts various background processes (e.g. syncing)
 */
const bootLeaderThread = ({ dbStateMissing, initialBlockingSyncContext, devtoolsOptions, }) => Effect.gen(function* () {
    const { dbEventlog, bootStatusQueue, syncProcessor } = yield* LeaderThreadCtx;
    yield* Eventlog.initEventlogDb(dbEventlog);
    const { migrationsReport } = dbStateMissing ? yield* recreateDb : { migrationsReport: { migrations: [] } };
    // NOTE the sync processor depends on the dbs being initialized properly
    const { initialLeaderHead } = yield* syncProcessor.boot;
    if (initialBlockingSyncContext.blockingDeferred !== undefined) {
        // Provides a syncing status right away before the first pull response comes in
        yield* Queue.offer(bootStatusQueue, {
            stage: 'syncing',
            progress: { done: 0, total: -1 },
        });
        yield* initialBlockingSyncContext.blockingDeferred.pipe(Effect.withSpan('@livestore/common:leader-thread:initial-sync-blocking'));
    }
    yield* Queue.offer(bootStatusQueue, { stage: 'done' });
    yield* bootDevtools(devtoolsOptions).pipe(Effect.tapCauseLogPretty, Effect.forkScoped);
    return { migrationsReport, leaderHead: initialLeaderHead };
});
//# sourceMappingURL=make-leader-thread-layer.js.map