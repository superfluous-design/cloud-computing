import { Effect, Option, Schema } from '@livestore/utils/effect';
import type { SqliteDb } from '../adapter-types.js';
import * as EventSequenceNumber from '../schema/EventSequenceNumber.js';
import * as LiveStoreEvent from '../schema/LiveStoreEvent.js';
import { LeaderThreadCtx } from './types.js';
export declare const initEventlogDb: (dbEventlog: SqliteDb) => Effect.Effect<void, import("../adapter-types.js").SqliteError, never>;
/** Exclusive of the "since event" */
export declare const getEventsSince: (since: EventSequenceNumber.EventSequenceNumber) => Effect.Effect<ReadonlyArray<LiveStoreEvent.EncodedWithMeta>, never, LeaderThreadCtx>;
export declare const getClientHeadFromDb: (dbEventlog: SqliteDb) => EventSequenceNumber.EventSequenceNumber;
export declare const getBackendHeadFromDb: (dbEventlog: SqliteDb) => EventSequenceNumber.GlobalEventSequenceNumber;
export declare const updateBackendHead: (dbEventlog: SqliteDb, head: EventSequenceNumber.EventSequenceNumber) => void;
export declare const insertIntoEventlog: (eventEncoded: LiveStoreEvent.EncodedWithMeta, dbEventlog: SqliteDb, eventDefSchemaHash: number, clientId: string, sessionId: string) => Effect.Effect<void, import("../adapter-types.js").SqliteError, never>;
export declare const updateSyncMetadata: (items: ReadonlyArray<LiveStoreEvent.EncodedWithMeta>) => Effect.Effect<void, import("../adapter-types.js").SqliteError, LeaderThreadCtx>;
export declare const getSyncBackendCursorInfo: (remoteHead: EventSequenceNumber.GlobalEventSequenceNumber) => Effect.Effect<Option.None<{
    cursor: {
        global: EventSequenceNumber.GlobalEventSequenceNumber;
        client: EventSequenceNumber.ClientEventSequenceNumber;
    };
    metadata: Option.Option<Schema.JsonValue>;
}> | Option.Some<{
    cursor: {
        global: EventSequenceNumber.GlobalEventSequenceNumber;
        client: EventSequenceNumber.ClientEventSequenceNumber;
    };
    metadata: Option.Option<Schema.JsonValue>;
}>, never, LeaderThreadCtx>;
//# sourceMappingURL=eventlog.d.ts.map