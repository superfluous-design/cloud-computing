import { Schema } from '@livestore/utils/effect';
import { liveStoreVersion as pkgVersion } from '../version.js';
export const NetworkStatus = Schema.Struct({
    isConnected: Schema.Boolean,
    timestampMs: Schema.Number,
    /** Whether the network status devtools latch is closed. Used to simulate network disconnection. */
    latchClosed: Schema.Boolean,
});
export const requestId = Schema.String;
export const clientId = Schema.String;
export const sessionId = Schema.String;
export const liveStoreVersion = Schema.Literal(pkgVersion);
export const LSDMessage = (tag, fields) => Schema.TaggedStruct(tag, {
    liveStoreVersion,
    ...fields,
}).annotations({ identifier: tag });
export const LSDChannelMessage = (tag, fields) => LSDMessage(tag, {
    clientId,
    ...fields,
});
export const LSDClientSessionChannelMessage = (tag, fields) => LSDMessage(tag, {
    clientId,
    sessionId,
    ...fields,
});
export const LSDClientSessionReqResMessage = (tag, fields) => LSDMessage(tag, {
    clientId,
    sessionId,
    requestId,
    ...fields,
});
export const LSDReqResMessage = (tag, fields) => LSDChannelMessage(tag, {
    requestId,
    ...fields,
});
export const LeaderReqResMessage = (tag, fields) => {
    const Success = Schema.TaggedStruct(`${tag}.Response.Success`, {
        requestId,
        liveStoreVersion,
        ...fields.success,
    }).annotations({ identifier: `${tag}.Response.Success` });
    const Error = fields.error
        ? Schema.TaggedStruct(`${tag}.Response.Error`, {
            requestId,
            liveStoreVersion,
            ...fields.error,
        }).annotations({ identifier: `${tag}.Response.Error` })
        : Schema.Never;
    return {
        Request: Schema.TaggedStruct(`${tag}.Request`, {
            requestId,
            liveStoreVersion,
            ...fields.payload,
        }).annotations({ identifier: `${tag}.Request` }),
        Response: Schema.Union(Success, Error),
        Success,
        Error,
    };
};
//# sourceMappingURL=devtools-messages-common.js.map