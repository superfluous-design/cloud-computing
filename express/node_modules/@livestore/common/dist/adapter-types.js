import { Effect, Schema, Stream } from '@livestore/utils/effect';
import * as EventSequenceNumber from './schema/EventSequenceNumber.js';
export const LeaderPullCursor = Schema.Struct({
    mergeCounter: Schema.Number,
    eventNum: EventSequenceNumber.EventSequenceNumber,
});
export const PersistenceInfo = Schema.Struct({
    fileName: Schema.String,
}, { key: Schema.String, value: Schema.Any }).annotations({ title: 'LiveStore.PersistenceInfo' });
export const BootStateProgress = Schema.Struct({
    done: Schema.Number,
    total: Schema.Number,
});
export const BootStatus = Schema.Union(Schema.Struct({ stage: Schema.Literal('loading') }), Schema.Struct({ stage: Schema.Literal('migrating'), progress: BootStateProgress }), Schema.Struct({ stage: Schema.Literal('rehydrating'), progress: BootStateProgress }), Schema.Struct({ stage: Schema.Literal('syncing'), progress: BootStateProgress }), Schema.Struct({ stage: Schema.Literal('done') })).annotations({ title: 'BootStatus' });
/**
 * Can be used in queries to refer to the current session id.
 * Will be replaced with the actual session id at runtime
 *
 * In client document table:
 * ```ts
 * const uiState = State.SQLite.clientDocument({
 *   name: 'ui_state',
 *   schema: Schema.Struct({
 *     theme: Schema.Literal('dark', 'light', 'system'),
 *     user: Schema.String,
 *     showToolbar: Schema.Boolean,
 *   }),
 *   default: { value: defaultFrontendState, id: SessionIdSymbol },
 * })
 * ```
 *
 * Or in a client document query:
 * ```ts
 * const query$ = queryDb(tables.uiState.get(SessionIdSymbol))
 * ```
 */
export const SessionIdSymbol = Symbol.for('@livestore/session-id');
export class UnexpectedError extends Schema.TaggedError()('LiveStore.UnexpectedError', {
    cause: Schema.Defect,
    note: Schema.optional(Schema.String),
    payload: Schema.optional(Schema.Any),
}) {
    static mapToUnexpectedError = (effect) => effect.pipe(Effect.mapError((cause) => (Schema.is(UnexpectedError)(cause) ? cause : new UnexpectedError({ cause }))), Effect.catchAllDefect((cause) => new UnexpectedError({ cause })));
    static mapToUnexpectedErrorStream = (stream) => stream.pipe(Stream.mapError((cause) => (Schema.is(UnexpectedError)(cause) ? cause : new UnexpectedError({ cause }))));
}
export class IntentionalShutdownCause extends Schema.TaggedError()('LiveStore.IntentionalShutdownCause', {
    reason: Schema.Literal('devtools-reset', 'devtools-import', 'adapter-reset', 'manual'),
}) {
}
export class StoreInterrupted extends Schema.TaggedError()('LiveStore.StoreInterrupted', {
    reason: Schema.String,
}) {
}
export class SqliteError extends Schema.TaggedError()('LiveStore.SqliteError', {
    query: Schema.optional(Schema.Struct({
        sql: Schema.String,
        bindValues: Schema.Union(Schema.Record({ key: Schema.String, value: Schema.Any }), Schema.Array(Schema.Any)),
    })),
    /** The SQLite result code */
    // code: Schema.optional(Schema.Number),
    // Added string support for Expo SQLite (we should refactor this to have a unified error type)
    code: Schema.optional(Schema.Union(Schema.Number, Schema.String)),
    /** The original SQLite3 error */
    cause: Schema.Defect,
    note: Schema.optional(Schema.String),
}) {
}
export const MigrationsReportEntry = Schema.Struct({
    tableName: Schema.String,
    hashes: Schema.Struct({
        expected: Schema.Number,
        actual: Schema.optional(Schema.Number),
    }),
});
export const MigrationsReport = Schema.Struct({
    migrations: Schema.Array(MigrationsReportEntry),
});
//# sourceMappingURL=adapter-types.js.map