import { type ClientSession, type ClientSessionSyncProcessor, type ParamsObject, type QueryBuilder, UnexpectedError } from '@livestore/common';
import type { LiveStoreSchema } from '@livestore/common/schema';
import { LiveStoreEvent } from '@livestore/common/schema';
import type { Scope } from '@livestore/utils/effect';
import { Cause, Effect, Inspectable, Stream } from '@livestore/utils/effect';
import * as otel from '@opentelemetry/api';
import type { LiveQuery, LiveQueryDef, ReactivityGraph, ReactivityGraphContext, SignalDef } from '../live-queries/base-class.js';
import type { Ref } from '../reactive.js';
import { SqliteDbWrapper } from '../SqliteDbWrapper.js';
import { ReferenceCountedSet } from '../utils/data-structures.js';
import type { StackInfo } from '../utils/stack-info.js';
import type { RefreshReason, StoreCommitOptions, StoreEventsOptions, StoreOptions, StoreOtel, Unsubscribe } from './store-types.js';
export declare class Store<TSchema extends LiveStoreSchema = LiveStoreSchema, TContext = {}> extends Inspectable.Class {
    readonly storeId: string;
    reactivityGraph: ReactivityGraph;
    sqliteDbWrapper: SqliteDbWrapper;
    clientSession: ClientSession;
    schema: LiveStoreSchema;
    context: TContext;
    otel: StoreOtel;
    /**
     * Note we're using `Ref<null>` here as we don't care about the value but only about *that* something has changed.
     * This only works in combination with `equal: () => false` which will always trigger a refresh.
     */
    tableRefs: {
        [key: string]: Ref<null, ReactivityGraphContext, RefreshReason>;
    };
    private effectContext;
    /** RC-based set to see which queries are currently subscribed to */
    activeQueries: ReferenceCountedSet<LiveQuery<any>>;
    readonly __eventSchema: LiveStoreEvent.ForEventDefRecord<TSchema["_EventDefMapType"]>;
    readonly syncProcessor: ClientSessionSyncProcessor;
    readonly boot: Effect.Effect<void, UnexpectedError, Scope.Scope>;
    constructor({ clientSession, schema, otelOptions, context, batchUpdates, storeId, effectContext, params, confirmUnsavedChanges, __runningInDevtools, }: StoreOptions<TSchema, TContext>);
    get sessionId(): string;
    get clientId(): string;
    /**
     * Subscribe to the results of a query
     * Returns a function to cancel the subscription.
     *
     * @example
     * ```ts
     * const unsubscribe = store.subscribe(query$, { onUpdate: (result) => console.log(result) })
     * ```
     */
    subscribe: <TResult>(query: LiveQueryDef<TResult, "def" | "signal-def"> | LiveQuery<TResult>, options: {
        /** Called when the query result has changed */
        onUpdate: (value: TResult) => void;
        onSubscribe?: (query$: LiveQuery<TResult>) => void;
        /** Gets called after the query subscription has been removed */
        onUnsubsubscribe?: () => void;
        label?: string;
        /**
         * Skips the initial `onUpdate` callback
         * @default false
         */
        skipInitialRun?: boolean;
        otelContext?: otel.Context;
        /** If provided, the stack info will be added to the `activeSubscriptions` set of the query */
        stackInfo?: StackInfo;
    }) => Unsubscribe;
    subscribeStream: <TResult>(query$: LiveQueryDef<TResult>, options?: {
        label?: string;
        skipInitialRun?: boolean;
    } | undefined) => Stream.Stream<TResult>;
    /**
     * Synchronously queries the database without creating a LiveQuery.
     * This is useful for queries that don't need to be reactive.
     *
     * Example: Query builder
     * ```ts
     * const completedTodos = store.query(tables.todo.where({ complete: true }))
     * ```
     *
     * Example: Raw SQL query
     * ```ts
     * const completedTodos = store.query({ query: 'SELECT * FROM todo WHERE complete = 1', bindValues: {} })
     * ```
     */
    query: <TResult>(query: QueryBuilder<TResult, any, any> | LiveQuery<TResult> | LiveQueryDef<TResult> | SignalDef<TResult> | {
        query: string;
        bindValues: ParamsObject;
    }, options?: {
        otelContext?: otel.Context;
        debugRefreshReason?: RefreshReason;
    }) => TResult;
    /**
     * Set the value of a signal
     *
     * @example
     * ```ts
     * const count$ = signal(0, { label: 'count$' })
     * store.setSignal(count$, 2)
     * ```
     *
     * @example
     * ```ts
     * const count$ = signal(0, { label: 'count$' })
     * store.setSignal(count$, (prev) => prev + 1)
     * ```
     */
    setSignal: <T>(signalDef: SignalDef<T>, value: T | ((prev: T) => T)) => void;
    /**
     * Commit a list of events to the store which will immediately update the local database
     * and sync the events across other clients (similar to a `git commit`).
     *
     * @example
     * ```ts
     * store.commit(events.todoCreated({ id: nanoid(), text: 'Make coffee' }))
     * ```
     *
     * You can call `commit` with multiple events to apply them in a single database transaction.
     *
     * @example
     * ```ts
     * const todoId = nanoid()
     * store.commit(
     *   events.todoCreated({ id: todoId, text: 'Make coffee' }),
     *   events.todoCompleted({ id: todoId }))
     * ```
     *
     * For more advanced transaction scenarios, you can pass a synchronous function to `commit` which will receive a callback
     * to which you can pass multiple events to be committed in the same database transaction.
     * Under the hood this will simply collect all events and apply them in a single database transaction.
     *
     * @example
     * ```ts
     * store.commit((commit) => {
     *   const todoId = nanoid()
     *   if (Math.random() > 0.5) {
     *     commit(events.todoCreated({ id: todoId, text: 'Make coffee' }))
     *   } else {
     *     commit(events.todoCompleted({ id: todoId }))
     *   }
     * })
     * ```
     *
     * When committing a large batch of events, you can also skip the database refresh to improve performance
     * and call `store.manualRefresh()` after all events have been committed.
     *
     * @example
     * ```ts
     * const todos = [
     *   { id: nanoid(), text: 'Make coffee' },
     *   { id: nanoid(), text: 'Buy groceries' },
     *   // ... 1000 more todos
     * ]
     * for (const todo of todos) {
     *   store.commit({ skipRefresh: true }, events.todoCreated({ id: todo.id, text: todo.text }))
     * }
     * store.manualRefresh()
     * ```
     */
    commit: {
        <const TCommitArg extends ReadonlyArray<LiveStoreEvent.PartialForSchema<TSchema>>>(...list: TCommitArg): void;
        (txn: <const TCommitArg extends ReadonlyArray<LiveStoreEvent.PartialForSchema<TSchema>>>(...list: TCommitArg) => void): void;
        <const TCommitArg extends ReadonlyArray<LiveStoreEvent.PartialForSchema<TSchema>>>(options: StoreCommitOptions, ...list: TCommitArg): void;
        (options: StoreCommitOptions, txn: <const TCommitArg extends ReadonlyArray<LiveStoreEvent.PartialForSchema<TSchema>>>(...list: TCommitArg) => void): void;
    };
    /**
     * Returns an async iterable of events.
     *
     * @example
     * ```ts
     * for await (const event of store.events()) {
     *   console.log(event)
     * }
     * ```
     *
     * @example
     * ```ts
     * // Get all events from the beginning of time
     * for await (const event of store.events({ cursor: EventSequenceNumber.ROOT })) {
     *   console.log(event)
     * }
     * ```
     */
    events: (_options?: StoreEventsOptions<TSchema>) => AsyncIterable<LiveStoreEvent.ForSchema<TSchema>>;
    eventsStream: (_options?: StoreEventsOptions<TSchema>) => Stream.Stream<LiveStoreEvent.ForSchema<TSchema>>;
    /**
     * This can be used in combination with `skipRefresh` when committing events.
     * We might need a better solution for this. Let's see.
     */
    manualRefresh: (options?: {
        label?: string;
    }) => void;
    /**
     * Shuts down the store and closes the client session.
     *
     * This is called automatically when the store was created using the React or Effect API.
     */
    shutdown: (cause?: Cause.Cause<UnexpectedError>) => Promise<void>;
    toJSON: () => {
        _tag: string;
        reactivityGraph: import("../reactive.js").ReactiveGraphSnapshot;
    };
    private runEffectFork;
    private getCommitArgs;
}
//# sourceMappingURL=store.d.ts.map