import type { Adapter, BootStatus, MigrationsReport } from '@livestore/common';
import { UnexpectedError } from '@livestore/common';
import type { LiveStoreSchema } from '@livestore/common/schema';
import type { Schema } from '@livestore/utils/effect';
import { Context, Deferred, Effect, Layer, OtelTracer, Scope } from '@livestore/utils/effect';
import * as otel from '@opentelemetry/api';
import { Store } from './store.js';
import type { LiveStoreContextRunning as LiveStoreContextRunning_, OtelOptions, ShutdownDeferred } from './store-types.js';
export declare const DEFAULT_PARAMS: {
    leaderPushBatchSize: number;
};
declare const LiveStoreContextRunning_base: Context.TagClass<LiveStoreContextRunning, "@livestore/livestore/effect/LiveStoreContextRunning", LiveStoreContextRunning_>;
export declare class LiveStoreContextRunning extends LiveStoreContextRunning_base {
    static fromDeferred: Layer.Layer<LiveStoreContextRunning, UnexpectedError, DeferredStoreContext>;
}
declare const DeferredStoreContext_base: Context.TagClass<DeferredStoreContext, "@livestore/livestore/effect/DeferredStoreContext", Deferred.Deferred<LiveStoreContextRunning_, UnexpectedError>>;
export declare class DeferredStoreContext extends DeferredStoreContext_base {
}
export type LiveStoreContextProps<TSchema extends LiveStoreSchema, TContext = {}> = {
    schema: TSchema;
    /**
     * The `storeId` can be used to isolate multiple stores from each other.
     * So it can be useful for multi-tenancy scenarios.
     *
     * The `storeId` is also used for persistence.
     *
     * @default 'default'
     */
    storeId?: string;
    /** Can be useful for custom live query implementations (e.g. see `@livestore/graphql`) */
    context?: TContext;
    boot?: (store: Store<TSchema, TContext>) => Effect.Effect<void, unknown, OtelTracer.OtelTracer | LiveStoreContextRunning>;
    adapter: Adapter;
    /**
     * Whether to disable devtools.
     *
     * @default 'auto'
     */
    disableDevtools?: boolean | 'auto';
    onBootStatus?: (status: BootStatus) => void;
    batchUpdates: (run: () => void) => void;
};
export interface CreateStoreOptions<TSchema extends LiveStoreSchema, TContext = {}> {
    schema: TSchema;
    adapter: Adapter;
    storeId: string;
    context?: TContext;
    boot?: (store: Store<TSchema, TContext>, ctx: {
        migrationsReport: MigrationsReport;
        parentSpan: otel.Span;
    }) => void | Promise<void> | Effect.Effect<void, unknown, OtelTracer.OtelTracer | LiveStoreContextRunning>;
    batchUpdates?: (run: () => void) => void;
    /**
     * Whether to disable devtools.
     *
     * @default 'auto'
     */
    disableDevtools?: boolean | 'auto';
    onBootStatus?: (status: BootStatus) => void;
    shutdownDeferred?: ShutdownDeferred;
    /**
     * Currently only used in the web adapter:
     * If true, registers a beforeunload event listener to confirm unsaved changes.
     *
     * @default true
     */
    confirmUnsavedChanges?: boolean;
    /**
     * Payload that will be passed to the sync backend when connecting
     *
     * @default undefined
     */
    syncPayload?: Schema.JsonValue;
    params?: {
        leaderPushBatchSize?: number;
    };
    debug?: {
        instanceId?: string;
    };
}
/** Create a new LiveStore Store */
export declare const createStorePromise: <TSchema extends LiveStoreSchema = LiveStoreSchema, TContext = {}>({ signal, otelOptions, ...options }: CreateStoreOptions<TSchema, TContext> & {
    signal?: AbortSignal;
    otelOptions?: Partial<OtelOptions>;
}) => Promise<Store<TSchema, TContext>>;
export declare const createStore: <TSchema extends LiveStoreSchema = LiveStoreSchema, TContext = {}>({ schema, adapter, storeId, context, boot, batchUpdates, disableDevtools, onBootStatus, shutdownDeferred, params, debug, confirmUnsavedChanges, syncPayload, }: CreateStoreOptions<TSchema, TContext>) => Effect.Effect<Store<TSchema, TContext>, UnexpectedError, Scope.Scope | OtelTracer.OtelTracer>;
export {};
//# sourceMappingURL=create-store.d.ts.map