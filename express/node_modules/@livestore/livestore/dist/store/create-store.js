import { provideOtel, UnexpectedError } from '@livestore/common';
import { isDevEnv, LS_DEV } from '@livestore/utils';
import { Context, Deferred, Effect, Exit, Fiber, identity, Layer, Logger, LogLevel, OtelTracer, Queue, Runtime, Scope, TaskTracing, } from '@livestore/utils/effect';
import { nanoid } from '@livestore/utils/nanoid';
import * as otel from '@opentelemetry/api';
import { connectDevtoolsToStore } from './devtools.js';
import { Store } from './store.js';
export const DEFAULT_PARAMS = {
    leaderPushBatchSize: 100,
};
export class LiveStoreContextRunning extends Context.Tag('@livestore/livestore/effect/LiveStoreContextRunning')() {
    static fromDeferred = Effect.gen(function* () {
        const deferred = yield* DeferredStoreContext;
        const ctx = yield* deferred;
        return Layer.succeed(LiveStoreContextRunning, ctx);
    }).pipe(Layer.unwrapScoped);
}
export class DeferredStoreContext extends Context.Tag('@livestore/livestore/effect/DeferredStoreContext')() {
}
/** Create a new LiveStore Store */
export const createStorePromise = async ({ signal, otelOptions, ...options }) => Effect.gen(function* () {
    const scope = yield* Scope.make();
    const runtime = yield* Effect.runtime();
    if (signal !== undefined) {
        signal.addEventListener('abort', () => {
            Scope.close(scope, Exit.void).pipe(Effect.tapCauseLogPretty, Runtime.runFork(runtime));
        });
    }
    return yield* createStore({ ...options }).pipe(Scope.extend(scope));
}).pipe(Effect.withSpan('createStore', {
    attributes: { storeId: options.storeId, disableDevtools: options.disableDevtools },
}), provideOtel({ parentSpanContext: otelOptions?.rootSpanContext, otelTracer: otelOptions?.tracer }), Effect.tapCauseLogPretty, Effect.annotateLogs({ thread: 'window' }), Effect.provide(Logger.prettyWithThread('window')), Logger.withMinimumLogLevel(LogLevel.Debug), Effect.runPromise);
export const createStore = ({ schema, adapter, storeId, context = {}, boot, batchUpdates, disableDevtools, onBootStatus, shutdownDeferred, params, debug, confirmUnsavedChanges = true, syncPayload, }) => Effect.gen(function* () {
    const lifetimeScope = yield* Scope.make();
    yield* validateStoreId(storeId);
    yield* Effect.addFinalizer((_) => Scope.close(lifetimeScope, _));
    const debugInstanceId = debug?.instanceId ?? nanoid(10);
    return yield* Effect.gen(function* () {
        const span = yield* OtelTracer.currentOtelSpan.pipe(Effect.orDie);
        const otelRootSpanContext = otel.trace.setSpan(otel.context.active(), span);
        const otelTracer = yield* OtelTracer.OtelTracer;
        const bootStatusQueue = yield* Queue.unbounded().pipe(Effect.acquireRelease(Queue.shutdown));
        yield* Queue.take(bootStatusQueue).pipe(Effect.tapSync((status) => onBootStatus?.(status)), Effect.tap((status) => (status.stage === 'done' ? Queue.shutdown(bootStatusQueue) : Effect.void)), Effect.forever, Effect.tapCauseLogPretty, Effect.forkScoped);
        const storeDeferred = yield* Deferred.make();
        const connectDevtoolsToStore_ = (storeDevtoolsChannel) => Effect.gen(function* () {
            const store = yield* storeDeferred;
            yield* connectDevtoolsToStore({ storeDevtoolsChannel, store });
        });
        const runtime = yield* Effect.runtime();
        const shutdown = (cause) => Effect.gen(function* () {
            yield* Scope.close(lifetimeScope, Exit.failCause(cause)).pipe(Effect.logWarnIfTakesLongerThan({ label: '@livestore/livestore:shutdown', duration: 500 }), Effect.timeout(1000), Effect.catchTag('TimeoutException', () => Effect.logError('@livestore/livestore:shutdown: Timed out after 1 second')));
            if (shutdownDeferred) {
                yield* Deferred.failCause(shutdownDeferred, cause);
            }
            yield* Effect.logDebug('LiveStore shutdown complete');
        }).pipe(Effect.withSpan('@livestore/livestore:shutdown'), Effect.provide(runtime), Effect.tapCauseLogPretty, 
        // Given that the shutdown flow might also interrupt the effect that is calling the shutdown,
        // we want to detach the shutdown effect so it's not interrupted by itself
        Effect.runFork, Fiber.join);
        const clientSession = yield* adapter({
            schema,
            storeId,
            devtoolsEnabled: getDevtoolsEnabled(disableDevtools),
            bootStatusQueue,
            shutdown,
            connectDevtoolsToStore: connectDevtoolsToStore_,
            debugInstanceId,
            syncPayload,
        }).pipe(Effect.withPerformanceMeasure('livestore:makeAdapter'), Effect.withSpan('createStore:makeAdapter'));
        if (LS_DEV && clientSession.leaderThread.initialState.migrationsReport.migrations.length > 0) {
            yield* Effect.logDebug('[@livestore/livestore:createStore] migrationsReport', ...clientSession.leaderThread.initialState.migrationsReport.migrations.map((m) => m.hashes.actual === undefined
                ? `Table '${m.tableName}' doesn't exist yet. Creating table...`
                : `Schema hash mismatch for table '${m.tableName}' (DB: ${m.hashes.actual}, expected: ${m.hashes.expected}), migrating table...`));
        }
        const store = new Store({
            clientSession,
            schema,
            context,
            otelOptions: { tracer: otelTracer, rootSpanContext: otelRootSpanContext },
            effectContext: { lifetimeScope, runtime },
            // TODO find a better way to detect if we're running LiveStore in the LiveStore devtools
            // But for now this is a good enough approximation with little downsides
            __runningInDevtools: getDevtoolsEnabled(disableDevtools) === false,
            confirmUnsavedChanges,
            // NOTE during boot we're not yet executing events in a batched context
            // but only set the provided `batchUpdates` function after boot
            batchUpdates: (run) => run(),
            storeId,
            params: {
                leaderPushBatchSize: params?.leaderPushBatchSize ?? DEFAULT_PARAMS.leaderPushBatchSize,
            },
        });
        // Starts background fibers (syncing, event processing, etc) for store
        yield* store.boot;
        if (boot !== undefined) {
            // TODO also incorporate `boot` function progress into `bootStatusQueue`
            yield* Effect.tryAll(() => boot(store, { migrationsReport: clientSession.leaderThread.initialState.migrationsReport, parentSpan: span })).pipe(UnexpectedError.mapToUnexpectedError, Effect.provide(Layer.succeed(LiveStoreContextRunning, { stage: 'running', store: store })), Effect.withSpan('createStore:boot'));
        }
        // NOTE it's important to yield here to allow the forked Effect in the store constructor to run
        yield* Effect.yieldNow();
        if (batchUpdates !== undefined) {
            // Replacing the default batchUpdates function with the provided one after boot
            store.reactivityGraph.context.effectsWrapper = batchUpdates;
        }
        yield* Deferred.succeed(storeDeferred, store);
        return store;
    }).pipe(Effect.withSpan('createStore', { attributes: { debugInstanceId, storeId } }), Effect.annotateLogs({ debugInstanceId, storeId }), LS_DEV ? TaskTracing.withAsyncTaggingTracing((name) => console.createTask(name)) : identity, Scope.extend(lifetimeScope));
});
const validateStoreId = (storeId) => Effect.gen(function* () {
    const validChars = /^[a-zA-Z0-9_-]+$/;
    if (!validChars.test(storeId)) {
        return yield* UnexpectedError.make({
            cause: `Invalid storeId: ${storeId}. Only alphanumeric characters, underscores, and hyphens are allowed.`,
            payload: { storeId },
        });
    }
});
const getDevtoolsEnabled = (disableDevtools) => {
    // If an explicit value is provided, use that
    if (disableDevtools === true || disableDevtools === false) {
        return !disableDevtools;
    }
    if (isDevEnv() === true) {
        return true;
    }
    return false;
};
//# sourceMappingURL=create-store.js.map