import { BoundArray } from '@livestore/common';
import type { Types } from '@livestore/utils/effect';
import type * as otel from '@opentelemetry/api';
export declare const NOT_REFRESHED_YET: unique symbol;
export type NOT_REFRESHED_YET = typeof NOT_REFRESHED_YET;
export type GetAtom = <T>(atom: Atom<T, any, any>, otelContext?: otel.Context | undefined, debugRefreshReason?: TODO | undefined) => T;
export type Ref<T, TContext, TDebugRefreshReason extends DebugRefreshReason> = {
    _tag: 'ref';
    id: string;
    isDirty: false;
    isDestroyed: boolean;
    previousResult: T;
    computeResult: () => T;
    sub: Set<Atom<any, TContext, TDebugRefreshReason>>;
    super: Set<Thunk<any, TContext, TDebugRefreshReason> | Effect<TDebugRefreshReason>>;
    label?: string;
    /** Container for meta information (e.g. the LiveStore Store) */
    meta?: any;
    equal: (a: T, b: T) => boolean;
    refreshes: number;
};
export type Thunk<TResult, TContext, TDebugRefreshReason extends DebugRefreshReason> = {
    _tag: 'thunk';
    id: string;
    isDirty: boolean;
    isDestroyed: boolean;
    computeResult: (otelContext?: otel.Context, debugRefreshReason?: TDebugRefreshReason) => TResult;
    previousResult: TResult | NOT_REFRESHED_YET;
    sub: Set<Atom<any, TContext, TDebugRefreshReason>>;
    super: Set<Thunk<any, TContext, TDebugRefreshReason> | Effect<TDebugRefreshReason>>;
    label?: string;
    /** Container for meta information (e.g. the LiveStore Store) */
    meta?: any;
    equal: (a: TResult, b: TResult) => boolean;
    recomputations: number;
    __getResult: any;
};
export type Atom<T, TContext, TDebugRefreshReason extends DebugRefreshReason> = Ref<T, TContext, TDebugRefreshReason> | Thunk<T, TContext, TDebugRefreshReason>;
export type Effect<TDebugRefreshReason extends DebugRefreshReason> = {
    _tag: 'effect';
    id: string;
    isDestroyed: boolean;
    doEffect: (otelContext?: otel.Context | undefined, debugRefreshReason?: TDebugRefreshReason | undefined) => void;
    sub: Set<Atom<any, TODO, TODO>>;
    label?: string;
    invocations: number;
};
export type Node<T, TContext, TDebugRefreshReason extends DebugRefreshReason> = Atom<T, TContext, TDebugRefreshReason> | Effect<TDebugRefreshReason>;
export declare const isThunk: <T, TContext, TDebugRefreshReason extends DebugRefreshReason>(obj: unknown) => obj is Thunk<T, TContext, TDebugRefreshReason>;
export type DebugThunkInfo<T extends string = string> = {
    _tag: T;
    durationMs: number;
};
export type DebugRefreshReasonBase = 
/** Usually in response to some `commit` calls with `skipRefresh: true` */
{
    _tag: 'runDeferredEffects';
    originalRefreshReasons?: ReadonlyArray<DebugRefreshReasonBase>;
    manualRefreshReason?: DebugRefreshReasonBase;
} | {
    _tag: 'makeThunk';
    label?: string;
} | {
    _tag: 'unknown';
};
export type DebugRefreshReason<T extends string = string> = DebugRefreshReasonBase | {
    _tag: T;
};
export type AtomDebugInfo<TDebugThunkInfo extends DebugThunkInfo> = {
    atom: SerializedAtom;
    resultChanged: boolean;
    debugInfo: TDebugThunkInfo;
};
export type RefreshDebugInfo<TDebugRefreshReason extends DebugRefreshReason, TDebugThunkInfo extends DebugThunkInfo> = {
    /** Currently only used for easier handling in React (e.g. as key) */
    id: string;
    reason: TDebugRefreshReason;
    refreshedAtoms: AtomDebugInfo<TDebugThunkInfo>[];
    skippedRefresh: boolean;
    durationMs: number;
    /** Note we're using a regular `Date.now()` timestamp here as it's faster to produce and we don't need the fine accuracy */
    completedTimestamp: number;
    graphSnapshot: ReactiveGraphSnapshot;
};
export type EncodedOption<A> = {
    _tag: 'Some';
    value?: A;
} | {
    _tag: 'None';
};
export type SerializedAtom = SerializedRef | SerializedThunk;
export type SerializedRef = Readonly<Types.Simplify<Pick<Ref<unknown, unknown, any>, '_tag' | 'id' | 'label' | 'meta' | 'isDirty' | 'isDestroyed' | 'refreshes'> & {
    /** Is `None` if `getSnapshot` was called with `includeResults: false` which is the default */
    previousResult: EncodedOption<string>;
    sub: ReadonlyArray<string>;
    super: ReadonlyArray<string>;
}>>;
export type SerializedThunk = Readonly<Types.Simplify<Pick<Thunk<unknown, unknown, any>, '_tag' | 'id' | 'label' | 'meta' | 'isDirty' | 'isDestroyed' | 'recomputations'> & {
    /** Is `None` if `getSnapshot` was called with `includeResults: false` which is the default */
    previousResult: EncodedOption<string>;
    sub: ReadonlyArray<string>;
    super: ReadonlyArray<string>;
}>>;
export type SerializedEffect = Readonly<Types.Simplify<Pick<Effect<any>, '_tag' | 'id' | 'label' | 'invocations' | 'isDestroyed'> & {
    sub: ReadonlyArray<string>;
}>>;
export type ReactiveGraphSnapshot = {
    readonly atoms: ReadonlyArray<SerializedAtom>;
    readonly effects: ReadonlyArray<SerializedEffect>;
    /** IDs of deferred effects */
    readonly deferredEffects: ReadonlyArray<string>;
};
/** Used for testing */
export declare const __resetIds: () => void;
export declare class ReactiveGraph<TDebugRefreshReason extends DebugRefreshReason, TDebugThunkInfo extends DebugThunkInfo, TContext extends {
    effectsWrapper?: (runEffects: () => void) => void;
} = {}> {
    id: string;
    readonly atoms: Set<Atom<any, TContext, TDebugRefreshReason>>;
    readonly effects: Set<Effect<TDebugRefreshReason>>;
    context: TContext | undefined;
    debugRefreshInfos: BoundArray<RefreshDebugInfo<TDebugRefreshReason, TDebugThunkInfo>>;
    private currentDebugRefresh;
    private deferredEffects;
    private refreshCallbacks;
    private nodeIdCounter;
    private uniqueNodeId;
    private refreshInfoIdCounter;
    private uniqueRefreshInfoId;
    makeRef<T>(val: T, options?: {
        label?: string;
        meta?: unknown;
        equal?: (a: T, b: T) => boolean;
    }): Ref<T, TContext, TDebugRefreshReason>;
    makeThunk<T>(getResult: (get: GetAtom, setDebugInfo: (debugInfo: TDebugThunkInfo) => void, ctx: TContext, otelContext: otel.Context | undefined, debugRefreshReason: TDebugRefreshReason | undefined) => T, options?: {
        label?: string;
        meta?: any;
        equal?: (a: T, b: T) => boolean;
    } | undefined): Thunk<T, TContext, TDebugRefreshReason>;
    destroyNode(node: Node<any, TContext, TDebugRefreshReason>): void;
    destroy(): void;
    makeEffect(doEffect: (get: GetAtom, otelContext: otel.Context | undefined, debugRefreshReason: DebugRefreshReason | undefined) => void, options?: {
        label?: string;
    } | undefined): Effect<TDebugRefreshReason>;
    setRef<T>(ref: Ref<T, TContext, TDebugRefreshReason>, val: T, options?: {
        skipRefresh?: boolean;
        debugRefreshReason?: TDebugRefreshReason;
        otelContext?: otel.Context;
    } | undefined): void;
    setRefs<T>(refs: [Ref<T, TContext, TDebugRefreshReason>, T][], options?: {
        skipRefresh?: boolean;
        debugRefreshReason?: TDebugRefreshReason;
        otelContext?: otel.Context;
    } | undefined): void;
    private runEffects;
    runDeferredEffects: (options?: {
        debugRefreshReason?: TDebugRefreshReason;
        otelContext?: otel.Context;
    }) => void;
    runRefreshCallbacks: () => void;
    addEdge(superComp: Thunk<any, TContext, TDebugRefreshReason> | Effect<TDebugRefreshReason>, subComp: Atom<any, TContext, TDebugRefreshReason>): void;
    removeEdge(superComp: Thunk<any, TContext, TDebugRefreshReason> | Effect<TDebugRefreshReason>, subComp: Atom<any, TContext, TDebugRefreshReason>): void;
    getSnapshot: (opts?: {
        includeResults: boolean;
    }) => ReactiveGraphSnapshot;
    subscribeToRefresh: (cb: () => void) => () => void;
}
export declare const throwContextNotSetError: (graph: ReactiveGraph<any, any, any>) => never;
//# sourceMappingURL=reactive.d.ts.map