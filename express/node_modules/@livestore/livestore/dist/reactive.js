// This is a simple implementation of a reactive dependency graph.
// Key Terminology:
// Ref: a mutable cell where values can be set
// Thunk: a pure computation that depends on other values
// Effect: a side effect that runs when a value changes; return value is ignored
// Atom: a node returning a value that can be depended on: Ref | Thunk
// Super computation: Nodes that depend on a given node ("downstream")
// Sub computation: Nodes that a given node depends on ("upstream")
// This vocabulary comes from the MiniAdapton paper linked below, although
// we don't actually implement the MiniAdapton algorithm because we don't need lazy recomputation.
// https://arxiv.org/abs/1609.05337
// Features:
// - Dependencies are tracked automatically in thunk computations by using a getter function
//   to reference other atoms.
// - Whenever a ref is updated, the graph is eagerly refreshed to be consistent with the new values.
// - We minimize recomputation by refreshing the graph in topological sort order. (The topological height
//   is maintained eagerly as edges are added and removed.)
// - At every thunk we check value equality with the previous value and cutoff propagation if possible.
/* eslint-disable prefer-arrow/prefer-arrow-functions */
import { BoundArray } from '@livestore/common';
import { deepEqual, shouldNeverHappen } from '@livestore/utils';
// import { getDurationMsFromSpan } from './otel.js'
export const NOT_REFRESHED_YET = Symbol.for('NOT_REFRESHED_YET');
export const isThunk = (obj) => {
    return typeof obj === 'object' && obj !== null && '_tag' in obj && obj._tag === 'thunk';
};
const unknownRefreshReason = () => {
    // debugger
    return { _tag: 'unknown' };
};
const encodedOptionSome = (value) => ({ _tag: 'Some', value });
const encodedOptionNone = () => ({ _tag: 'None' });
let globalGraphIdCounter = 0;
const uniqueGraphId = () => `graph-${++globalGraphIdCounter}`;
/** Used for testing */
export const __resetIds = () => {
    globalGraphIdCounter = 0;
};
export class ReactiveGraph {
    id = uniqueGraphId();
    atoms = new Set();
    effects = new Set();
    context;
    debugRefreshInfos = new BoundArray(200);
    currentDebugRefresh;
    deferredEffects = new Map();
    refreshCallbacks = new Set();
    nodeIdCounter = 0;
    uniqueNodeId = () => `node-${++this.nodeIdCounter}`;
    refreshInfoIdCounter = 0;
    uniqueRefreshInfoId = () => `refresh-info-${++this.refreshInfoIdCounter}`;
    makeRef(val, options) {
        const ref = {
            _tag: 'ref',
            id: this.uniqueNodeId(),
            isDirty: false,
            isDestroyed: false,
            previousResult: val,
            computeResult: () => ref.previousResult,
            sub: new Set(),
            super: new Set(),
            label: options?.label,
            meta: options?.meta,
            equal: options?.equal ?? deepEqual,
            refreshes: 0,
        };
        this.atoms.add(ref);
        return ref;
    }
    makeThunk(getResult, options) {
        const thunk = {
            _tag: 'thunk',
            id: this.uniqueNodeId(),
            previousResult: NOT_REFRESHED_YET,
            isDirty: true,
            isDestroyed: false,
            computeResult: (otelContext, debugRefreshReason) => {
                if (thunk.isDirty) {
                    const neededCurrentRefresh = this.currentDebugRefresh === undefined;
                    if (neededCurrentRefresh) {
                        this.currentDebugRefresh = { refreshedAtoms: [], startMs: performance.now() };
                    }
                    // Reset previous subcomputations as we're about to re-add them as part of the `doEffect` call below
                    thunk.sub = new Set();
                    const getAtom = (atom, otelContext) => {
                        this.addEdge(thunk, atom);
                        return compute(atom, otelContext, debugRefreshReason);
                    };
                    let debugInfo = undefined;
                    const setDebugInfo = (debugInfo_) => {
                        debugInfo = debugInfo_;
                    };
                    const result = getResult(getAtom, setDebugInfo, this.context ?? throwContextNotSetError(this), otelContext, debugRefreshReason);
                    const resultChanged = thunk.equal(thunk.previousResult, result) === false;
                    const debugInfoForAtom = {
                        atom: serializeAtom(thunk, false),
                        resultChanged,
                        debugInfo: debugInfo ?? unknownRefreshReason(),
                    };
                    this.currentDebugRefresh.refreshedAtoms.push(debugInfoForAtom);
                    thunk.isDirty = false;
                    thunk.previousResult = result;
                    thunk.recomputations++;
                    if (neededCurrentRefresh) {
                        const refreshedAtoms = this.currentDebugRefresh.refreshedAtoms;
                        const durationMs = performance.now() - this.currentDebugRefresh.startMs;
                        this.currentDebugRefresh = undefined;
                        this.debugRefreshInfos.push({
                            id: this.uniqueRefreshInfoId(),
                            reason: debugRefreshReason ?? { _tag: 'makeThunk', label: options?.label },
                            skippedRefresh: false,
                            refreshedAtoms,
                            durationMs,
                            completedTimestamp: Date.now(),
                            graphSnapshot: this.getSnapshot({ includeResults: false }),
                        });
                    }
                    return result;
                }
                else {
                    return thunk.previousResult;
                }
            },
            sub: new Set(),
            super: new Set(),
            recomputations: 0,
            label: options?.label,
            meta: options?.meta,
            equal: options?.equal ?? deepEqual,
            __getResult: getResult,
        };
        this.atoms.add(thunk);
        return thunk;
    }
    destroyNode(node) {
        // console.debug(`destroying node (${node._tag})`, node.id, node.label)
        // Recursively destroy any supercomputations
        if (node._tag === 'ref' || node._tag === 'thunk') {
            for (const superComp of node.super) {
                this.destroyNode(superComp);
            }
        }
        // Destroy this node
        if (node._tag !== 'ref') {
            for (const subComp of node.sub) {
                this.removeEdge(node, subComp);
            }
        }
        if (node._tag === 'effect') {
            this.deferredEffects.delete(node);
            this.effects.delete(node);
        }
        else {
            this.atoms.delete(node);
        }
        node.isDestroyed = true;
    }
    destroy() {
        // NOTE we don't need to sort the atoms first, as `destroyNode` will recursively destroy all supercomputations
        for (const node of this.atoms) {
            this.destroyNode(node);
        }
    }
    makeEffect(doEffect, options) {
        const effect = {
            _tag: 'effect',
            id: this.uniqueNodeId(),
            isDestroyed: false,
            doEffect: (otelContext, debugRefreshReason) => {
                effect.invocations++;
                // NOTE we're not tracking any debug refresh info for effects as they're tracked by the thunks they depend on
                // Reset previous subcomputations as we're about to re-add them as part of the `doEffect` call below
                effect.sub = new Set();
                const getAtom = (atom, otelContext, debugRefreshReason) => {
                    this.addEdge(effect, atom);
                    return compute(atom, otelContext, debugRefreshReason);
                };
                doEffect(getAtom, otelContext, debugRefreshReason);
            },
            sub: new Set(),
            label: options?.label,
            invocations: 0,
        };
        this.effects.add(effect);
        return effect;
    }
    setRef(ref, val, options) {
        this.setRefs([[ref, val]], options);
    }
    setRefs(refs, options) {
        const effectsToRefresh = new Set();
        for (const [ref, val] of refs) {
            ref.previousResult = val;
            ref.refreshes++;
            markSuperCompDirtyRec(ref, effectsToRefresh);
        }
        if (options?.skipRefresh) {
            for (const effect of effectsToRefresh) {
                if (this.deferredEffects.has(effect) === false) {
                    this.deferredEffects.set(effect, new Set());
                }
                if (options?.debugRefreshReason !== undefined) {
                    this.deferredEffects.get(effect).add(options.debugRefreshReason);
                }
            }
        }
        else {
            this.runEffects(effectsToRefresh, {
                debugRefreshReason: options?.debugRefreshReason ?? unknownRefreshReason(),
                otelContext: options?.otelContext,
            });
        }
    }
    runEffects = (effectsToRefresh, options) => {
        const effectsWrapper = this.context?.effectsWrapper ?? ((runEffects) => runEffects());
        effectsWrapper(() => {
            this.currentDebugRefresh = { refreshedAtoms: [], startMs: performance.now() };
            for (const effect of effectsToRefresh) {
                effect.doEffect(options?.otelContext, options.debugRefreshReason);
            }
            const refreshedAtoms = this.currentDebugRefresh.refreshedAtoms;
            const durationMs = performance.now() - this.currentDebugRefresh.startMs;
            this.currentDebugRefresh = undefined;
            const refreshDebugInfo = {
                id: this.uniqueRefreshInfoId(),
                reason: options.debugRefreshReason,
                skippedRefresh: false,
                refreshedAtoms,
                durationMs,
                completedTimestamp: Date.now(),
                graphSnapshot: this.getSnapshot({ includeResults: false }),
            };
            this.debugRefreshInfos.push(refreshDebugInfo);
            this.runRefreshCallbacks();
        });
    };
    runDeferredEffects = (options) => {
        // TODO improve how refresh reasons are propagated for deferred effect execution
        // TODO also improve "batching" of running deferred effects (i.e. in a single `this.runEffects` call)
        // but need to be careful to not overwhelm the main thread
        for (const [effect, debugRefreshReasons] of this.deferredEffects) {
            this.runEffects(new Set([effect]), {
                debugRefreshReason: {
                    _tag: 'runDeferredEffects',
                    originalRefreshReasons: Array.from(debugRefreshReasons),
                    manualRefreshReason: options?.debugRefreshReason,
                },
                otelContext: options?.otelContext,
            });
        }
    };
    runRefreshCallbacks = () => {
        for (const cb of this.refreshCallbacks) {
            cb();
        }
    };
    addEdge(superComp, subComp) {
        superComp.sub.add(subComp);
        subComp.super.add(superComp);
        if (this.currentDebugRefresh === undefined) {
            this.runRefreshCallbacks();
        }
    }
    removeEdge(superComp, subComp) {
        superComp.sub.delete(subComp);
        const effectsToRefresh = new Set();
        markSuperCompDirtyRec(subComp, effectsToRefresh);
        for (const effect of effectsToRefresh) {
            this.deferredEffects.set(effect, new Set());
        }
        subComp.super.delete(superComp);
        if (this.currentDebugRefresh === undefined) {
            this.runRefreshCallbacks();
        }
    }
    // NOTE This function is performance-optimized (i.e. not using `Array.from`)
    getSnapshot = (opts) => {
        const { includeResults = false } = opts ?? {};
        const atoms = [];
        for (const atom of this.atoms) {
            atoms.push(serializeAtom(atom, includeResults));
        }
        const effects = [];
        for (const effect of this.effects) {
            effects.push(serializeEffect(effect));
        }
        const deferredEffects = [];
        for (const [effect] of this.deferredEffects) {
            deferredEffects.push(effect.id);
        }
        return { atoms, effects, deferredEffects };
    };
    subscribeToRefresh = (cb) => {
        this.refreshCallbacks.add(cb);
        return () => {
            this.refreshCallbacks.delete(cb);
        };
    };
}
const compute = (atom, otelContext, debugRefreshReason) => {
    // const __getResult = atom._tag === 'thunk' ? atom.__getResult.toString() : ''
    if (atom.isDestroyed) {
        shouldNeverHappen(`LiveStore Error: Attempted to compute destroyed ${atom._tag} (${atom.id}): ${atom.label ?? ''}`);
    }
    if (atom.isDirty) {
        // console.log('atom is dirty', atom.id, atom.label ?? '', atom._tag, __getResult)
        const result = atom.computeResult(otelContext, debugRefreshReason);
        atom.isDirty = false;
        atom.previousResult = result;
        return result;
    }
    else {
        // console.log('atom is clean', atom.id, atom.label ?? '', atom._tag, __getResult)
        return atom.previousResult;
    }
};
const markSuperCompDirtyRec = (atom, effectsToRefresh) => {
    for (const superComp of atom.super) {
        if (superComp._tag === 'thunk') {
            superComp.isDirty = true;
            markSuperCompDirtyRec(superComp, effectsToRefresh);
        }
        else {
            effectsToRefresh.add(superComp);
        }
    }
};
export const throwContextNotSetError = (graph) => {
    throw new Error(`LiveStore Error: \`context\` not set on ReactiveGraph (${graph.id})`);
};
// NOTE This function is performance-optimized (i.e. not using `pick` and `Array.from`)
const serializeAtom = (atom, includeResult) => {
    const sub = [];
    for (const a of atom.sub) {
        sub.push(a.id);
    }
    const super_ = [];
    for (const a of atom.super) {
        super_.push(a.id);
    }
    const previousResult = includeResult
        ? encodedOptionSome(atom.previousResult === NOT_REFRESHED_YET ? '"SYMBOL_NOT_REFRESHED_YET"' : JSON.stringify(atom.previousResult))
        : encodedOptionNone();
    if (atom._tag === 'ref') {
        return {
            _tag: atom._tag,
            id: atom.id,
            label: atom.label,
            meta: atom.meta,
            isDirty: atom.isDirty,
            sub,
            super: super_,
            isDestroyed: atom.isDestroyed,
            refreshes: atom.refreshes,
            previousResult,
        };
    }
    return {
        _tag: 'thunk',
        id: atom.id,
        label: atom.label,
        meta: atom.meta,
        isDirty: atom.isDirty,
        sub,
        super: super_,
        isDestroyed: atom.isDestroyed,
        recomputations: atom.recomputations,
        previousResult,
    };
};
// NOTE This function is performance-optimized (i.e. not using `pick` and `Array.from`)
const serializeEffect = (effect) => {
    const sub = [];
    for (const a of effect.sub) {
        sub.push(a.id);
    }
    return {
        _tag: effect._tag,
        id: effect.id,
        label: effect.label,
        sub,
        invocations: effect.invocations,
        isDestroyed: effect.isDestroyed,
    };
};
//# sourceMappingURL=reactive.js.map