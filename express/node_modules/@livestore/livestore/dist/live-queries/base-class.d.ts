import type * as otel from '@opentelemetry/api';
import * as RG from '../reactive.js';
import type { Store } from '../store/store.js';
import type { QueryDebugInfo, RefreshReason } from '../store/store-types.js';
import type { StackInfo } from '../utils/stack-info.js';
export type ReactivityGraph = RG.ReactiveGraph<RefreshReason, QueryDebugInfo, ReactivityGraphContext>;
export declare const makeReactivityGraph: () => ReactivityGraph;
export type ReactivityGraphContext = {
    store: Store;
    /** Maps from the hash of the query definition to the RcRef of the query */
    defRcMap: Map<string, RcRef<LiveQuery.Any | ISignal<any>>>;
    /** Back-reference to the reactivity graph for convenience */
    reactivityGraph: WeakRef<ReactivityGraph>;
    otelTracer: otel.Tracer;
    rootOtelContext: otel.Context;
    effectsWrapper: (run: () => void) => void;
};
export type GetResult<TQuery extends LiveQueryDef.Any | LiveQuery.Any | SignalDef<any>> = TQuery extends LiveQuery<infer TResult> ? TResult : TQuery extends LiveQueryDef<infer TResult> ? TResult : TQuery extends SignalDef<infer TResult> ? TResult : unknown;
export interface SignalDef<T> extends LiveQueryDef<T, 'signal-def'> {
    _tag: 'signal-def';
    defaultValue: T;
    hash: string;
    label: string;
    make: (ctx: ReactivityGraphContext) => RcRef<ISignal<T>>;
}
export interface ISignal<T> extends LiveQuery<T> {
    _tag: 'signal';
    reactivityGraph: ReactivityGraph;
    ref: RG.Ref<T, ReactivityGraphContext, RefreshReason>;
    set: (value: T) => void;
    get: () => T;
    destroy: () => void;
}
export declare const TypeId: unique symbol;
export type TypeId = typeof TypeId;
export interface RcRef<T> {
    rc: number;
    value: T;
    deref: () => void;
}
export type DepKey = string | number | ReadonlyArray<string | number | undefined | null>;
export declare const depsToString: (deps: DepKey) => string;
export interface LiveQueryDef<TResult, TTag extends string = 'def'> {
    _tag: TTag;
    /** Creates a new LiveQuery instance bound to a specific store/reactivityGraph */
    make: (ctx: ReactivityGraphContext, otelContext?: otel.Context) => RcRef<LiveQuery<TResult> | ISignal<TResult>>;
    label: string;
    hash: string;
}
export declare namespace LiveQueryDef {
    type Any = LiveQueryDef<any, 'def' | 'signal-def'>;
}
/**
 * A LiveQuery is stateful
 */
export interface LiveQuery<TResult> {
    id: number;
    _tag: 'computed' | 'db' | 'graphql' | 'signal';
    [TypeId]: TypeId;
    /** This should only be used on a type-level and doesn't hold any value during runtime */
    '__result!': TResult;
    /** A reactive thunk representing the query results */
    results$: RG.Atom<TResult, ReactivityGraphContext, RefreshReason>;
    label: string;
    run: (args: {
        otelContext?: otel.Context;
        debugRefreshReason?: RefreshReason;
    }) => TResult;
    destroy: () => void;
    isDestroyed: boolean;
    activeSubscriptions: Set<StackInfo>;
    runs: number;
    executionTimes: number[];
    def: LiveQueryDef<TResult> | SignalDef<TResult>;
}
export declare namespace LiveQuery {
    type Any = LiveQuery<any>;
}
export declare abstract class LiveStoreQueryBase<TResult> implements LiveQuery<TResult> {
    '__result!': TResult;
    id: number;
    [TypeId]: TypeId;
    abstract _tag: 'computed' | 'db' | 'graphql' | 'signal';
    /** Human-readable label for the query for debugging */
    abstract label: string;
    abstract def: LiveQueryDef<TResult> | SignalDef<TResult>;
    abstract results$: RG.Atom<TResult, ReactivityGraphContext, RefreshReason>;
    activeSubscriptions: Set<StackInfo>;
    abstract readonly reactivityGraph: ReactivityGraph;
    get runs(): number;
    executionTimes: number[];
    isDestroyed: boolean;
    abstract destroy: () => void;
    run: (args: {
        otelContext?: otel.Context;
        debugRefreshReason?: RefreshReason;
    }) => TResult;
    protected dependencyQueriesRef: DependencyQueriesRef;
}
export type GetAtomResult = <T>(atom: RG.Atom<T, any, RefreshReason> | LiveQueryDef<T> | LiveQuery<T> | ISignal<T> | SignalDef<T>, otelContext?: otel.Context | undefined, debugRefreshReason?: RefreshReason | undefined) => T;
export type DependencyQueriesRef = Set<RcRef<LiveQuery.Any | ISignal<any>>>;
export declare const makeGetAtomResult: (get: RG.GetAtom, ctx: ReactivityGraphContext, otelContext: otel.Context, dependencyQueriesRef: DependencyQueriesRef) => GetAtomResult;
export declare const withRCMap: <T extends LiveQuery.Any | ISignal<any>>(id: string, make: (ctx: ReactivityGraphContext, otelContext?: otel.Context) => T) => ((ctx: ReactivityGraphContext, otelContext?: otel.Context) => RcRef<T>);
//# sourceMappingURL=base-class.d.ts.map