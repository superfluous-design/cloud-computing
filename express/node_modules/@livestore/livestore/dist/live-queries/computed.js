import { getDurationMsFromSpan } from '@livestore/common';
import * as otel from '@opentelemetry/api';
import { isValidFunctionString } from '../utils/function-string.js';
import { depsToString, LiveStoreQueryBase, makeGetAtomResult, withRCMap } from './base-class.js';
export const computed = (fn, options) => {
    const hash = options?.deps ? depsToString(options.deps) : fn.toString();
    if (isValidFunctionString(hash)._tag === 'invalid') {
        throw new Error(`On Expo/React Native, computed queries must provide a \`deps\` option`);
    }
    const def = {
        _tag: 'def',
        make: withRCMap(hash, (ctx, _otelContext) => {
            // TODO onDestroy
            return new LiveStoreComputedQuery({
                fn,
                label: options?.label ?? fn.toString(),
                reactivityGraph: ctx.reactivityGraph.deref(),
                def,
            });
        }),
        label: options?.label ?? fn.toString(),
        // NOTE We're using the `makeQuery` function body string to make sure the key is unique across the app
        // TODO we should figure out whether this could cause some problems and/or if there's a better way to do this
        // NOTE `fn.toString()` doesn't work in Expo as it always produces `[native code]`
        hash,
    };
    return def;
};
export class LiveStoreComputedQuery extends LiveStoreQueryBase {
    _tag = 'computed';
    /** A reactive thunk representing the query results */
    results$;
    label;
    reactivityGraph;
    def;
    constructor({ fn, label, reactivityGraph, def, }) {
        super();
        this.label = label;
        this.reactivityGraph = reactivityGraph;
        this.def = def;
        const queryLabel = `${label}:results`;
        this.results$ = this.reactivityGraph.makeThunk((get, setDebugInfo, ctx, otelContext) => ctx.otelTracer.startActiveSpan(`js:${label}`, {}, otelContext ?? ctx.rootOtelContext, (span) => {
            const otelContext = otel.trace.setSpan(otel.context.active(), span);
            const res = fn(makeGetAtomResult(get, ctx, otelContext, this.dependencyQueriesRef));
            span.end();
            const durationMs = getDurationMsFromSpan(span);
            this.executionTimes.push(durationMs);
            setDebugInfo({ _tag: 'computed', label, query: fn.toString(), durationMs });
            return res;
        }), { label: queryLabel, meta: { liveStoreThunkType: 'computed' } });
    }
    destroy = () => {
        this.isDestroyed = true;
        this.reactivityGraph.destroyNode(this.results$);
        for (const query of this.dependencyQueriesRef) {
            query.deref();
        }
    };
}
//# sourceMappingURL=computed.js.map