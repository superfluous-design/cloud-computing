import type { Bindable, QueryBuilder } from '@livestore/common';
import { Schema } from '@livestore/utils/effect';
import * as otel from '@opentelemetry/api';
import type { Thunk } from '../reactive.js';
import type { RefreshReason } from '../store/store-types.js';
import type { DepKey, GetAtomResult, LiveQueryDef, ReactivityGraph, ReactivityGraphContext } from './base-class.js';
import { LiveStoreQueryBase } from './base-class.js';
export type QueryInputRaw<TDecoded, TEncoded> = {
    query: string;
    schema: Schema.Schema<TDecoded, TEncoded>;
    bindValues?: Bindable;
    /**
     * Can be provided explicitly to slightly speed up initial query performance
     *
     * NOTE In the future we want to do this automatically at build time
     */
    queriedTables?: Set<string>;
    execBeforeFirstRun?: (ctx: ReactivityGraphContext) => void;
};
export declare const isQueryInputRaw: (value: unknown) => value is QueryInputRaw<any, any>;
export type QueryInput<TDecoded, TEncoded> = QueryInputRaw<TDecoded, TEncoded> | QueryBuilder<TDecoded, any, any>;
/**
 * NOTE `queryDb` is only supposed to read data. Don't use it to insert/update/delete data but use events instead.
 *
 * When using contextual data when constructing the query, please make sure to include it in the `deps` option.
 *
 * @example
 * ```ts
 * const todos$ = queryDb(tables.todos.where({ complete: true }))
 * ```
 *
 * @example
 * ```ts
 * // Group-by raw SQL query
 * const colorCounts$ = queryDb({
 *   query: sql`SELECT color, COUNT(*) as count FROM todos WHERE complete = ? GROUP BY color`,
 *   schema: Schema.Array(Schema.Struct({
 *     color: Schema.String,
 *     count: Schema.Number,
 *   })),
 *   bindValues: [1],
 * })
 * ```
 *
 * @example
 * ```ts
 * // Using contextual data when constructing the query
 * const makeFilteredQuery = (filter: string) =>
 *   queryDb(tables.todos.where({ title: { op: 'like', value: filter } }), { deps: [filter] })
 *
 * const filteredTodos$ = makeFilteredQuery('buy coffee')
 * ```
 */
export declare const queryDb: {
    <TResultSchema, TResult = TResultSchema>(queryInput: QueryInputRaw<TResultSchema, ReadonlyArray<any>> | QueryBuilder<TResultSchema, any, any>, options?: {
        map?: (rows: TResultSchema) => TResult;
        /**
         * Used for debugging / devtools
         */
        label?: string;
        deps?: DepKey;
    }): LiveQueryDef<TResult>;
    <TResultSchema, TResult = TResultSchema>(queryInput: ((get: GetAtomResult) => QueryInputRaw<TResultSchema, ReadonlyArray<any>>) | ((get: GetAtomResult) => QueryBuilder<TResultSchema, any, any>), options?: {
        map?: (rows: TResultSchema) => TResult;
        /**
         * Used for debugging / devtools
         */
        label?: string;
        deps?: DepKey;
    }): LiveQueryDef<TResult>;
};
export declare class LiveStoreDbQuery<TResultSchema, TResult = TResultSchema> extends LiveStoreQueryBase<TResult> {
    _tag: "db";
    /** A reactive thunk representing the query text */
    queryInput$: Thunk<QueryInputRaw<any, any>, ReactivityGraphContext, RefreshReason> | undefined;
    /** A reactive thunk representing the query results */
    results$: Thunk<TResult, ReactivityGraphContext, RefreshReason>;
    label: string;
    readonly reactivityGraph: ReactivityGraph;
    private mapResult;
    def: LiveQueryDef<TResult>;
    constructor({ queryInput, label: inputLabel, reactivityGraph, map, otelContext, def, }: {
        label?: string;
        queryInput: QueryInput<TResultSchema, ReadonlyArray<any>> | ((get: GetAtomResult, ctx: ReactivityGraphContext) => QueryInput<TResultSchema, ReadonlyArray<any>>);
        reactivityGraph: ReactivityGraph;
        map?: (rows: TResultSchema) => TResult;
        /** Only used for the initial query execution */
        otelContext?: otel.Context;
        def: LiveQueryDef<TResult>;
    });
    destroy: () => void;
}
//# sourceMappingURL=db-query.d.ts.map