import { isNotNil } from '@livestore/utils';
import { Predicate } from '@livestore/utils/effect';
import * as RG from '../reactive.js';
export const makeReactivityGraph = () => new RG.ReactiveGraph();
let queryIdCounter = 0;
export const TypeId = Symbol.for('LiveQuery');
export const depsToString = (deps) => {
    if (typeof deps === 'string' || typeof deps === 'number') {
        return deps.toString();
    }
    return deps.filter(isNotNil).join(',');
};
export class LiveStoreQueryBase {
    '__result!';
    id = queryIdCounter++;
    [TypeId] = TypeId;
    activeSubscriptions = new Set();
    get runs() {
        if (this.results$._tag === 'thunk') {
            return this.results$.recomputations;
        }
        return 0;
    }
    executionTimes = [];
    // TODO double check if this is needed
    isDestroyed = false;
    run = (args) => {
        return this.results$.computeResult(args.otelContext, args.debugRefreshReason);
    };
    dependencyQueriesRef = new Set();
}
export const makeGetAtomResult = (get, ctx, otelContext, dependencyQueriesRef) => {
    // NOTE we're using the `otelContext` from `makeGetAtomResult` here, not the `otelContext` from `getAtom`
    const getAtom = (atom, _otelContext, debugRefreshReason) => {
        // ReactivityGraph atoms case
        if (atom._tag === 'thunk' || atom._tag === 'ref')
            return get(atom, otelContext, debugRefreshReason);
        // def case
        if (atom._tag === 'def' || atom._tag === 'signal-def') {
            const query = atom.make(ctx);
            dependencyQueriesRef.add(query);
            // TODO deref the query on destroy
            return getAtom(query.value, _otelContext, debugRefreshReason);
        }
        // Signal case
        if (atom._tag === 'signal' && Predicate.hasProperty(atom, 'ref')) {
            return get(atom.ref, otelContext, debugRefreshReason);
        }
        // LiveQuery case
        return get(atom.results$, otelContext, debugRefreshReason);
    };
    return getAtom;
};
export const withRCMap = (id, make) => {
    return (ctx, otelContext) => {
        let item = ctx.defRcMap.get(id);
        if (item) {
            item.rc++;
            return item;
        }
        const query$ = make(ctx, otelContext);
        item = {
            rc: 1,
            value: query$,
            deref: () => {
                item.rc--;
                if (item.rc === 0) {
                    item.value.destroy();
                    ctx.defRcMap.delete(id);
                }
            },
        };
        ctx.defRcMap.set(id, item);
        return item;
    };
};
//# sourceMappingURL=base-class.js.map