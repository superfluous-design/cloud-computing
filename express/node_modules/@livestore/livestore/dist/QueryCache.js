import { BoundMap, BoundSet } from '@livestore/common';
var Symbols;
(function (Symbols) {
})(Symbols || (Symbols = {}));
const ignore = ['begin', 'rollback', 'commit', 'savepoint', 'release'];
// TODO: profile to see how big we need this cache to be.
const cacheSize = 200;
export default class QueryCache {
    #entries = new BoundMap(cacheSize);
    #dependencies = new Map();
    getKey = (sql, bindValues) => {
        if (bindValues == null) {
            return sql;
        }
        if (Array.isArray(bindValues)) {
            return (sql + '\n' + bindValues.join('\n'));
        }
        return (sql + '\n' + Object.values(bindValues).join('\n'));
    };
    get = (key) => {
        return this.#entries.get(key);
    };
    set = (queriedTables, key, results) => {
        this.#entries.set(key, results);
        for (const table of queriedTables) {
            let keys = this.#dependencies.get(table);
            if (keys == null) {
                keys = new BoundSet(cacheSize);
                keys.onEvict = this.#dependencyTrackerEvicted;
                this.#dependencies.set(table, keys);
            }
            keys.add(key);
        }
    };
    #dependencyTrackerEvicted = (key) => {
        this.#entries.delete(key);
    };
    ignoreQuery = (query) => {
        return ignore.some((prefix) => query.startsWith(prefix));
    };
    // The next simplest step is to create a specific implementation for invalidating
    // the expensive track list queries only when constraints data in a write overlaps with read constraints.
    //
    // As well as either:
    // a. removeing the big view (since we'll have our cache)
    // b. incrementally updating the view on insert by the EventImporter
    //
    // We'll not try to tackle any generalized approach until we have a proof of concept working.
    invalidate = (queriedTables) => {
        for (const table of queriedTables) {
            const keys = this.#dependencies.get(table);
            if (keys == null) {
                continue;
            }
            for (const k of keys) {
                this.#entries.delete(k);
            }
        }
    };
}
//# sourceMappingURL=QueryCache.js.map