import { State } from '@livestore/livestore';
import { Effect, Schema } from '@livestore/utils/effect';
import type * as otel from '@opentelemetry/api';
export type Todo = {
    id: string;
    text: string;
    completed: boolean;
};
export type Filter = 'all' | 'active' | 'completed';
export type AppState = {
    newTodoText: string;
    filter: Filter;
};
export declare const todos: State.SQLite.TableDef<State.SQLite.SqliteTableDefForInput<"todos", {
    readonly id: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
    };
    readonly text: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").Some<"">;
        nullable: false;
        primaryKey: false;
    };
    readonly completed: {
        columnType: "integer";
        schema: Schema.Schema<boolean, number, never>;
        default: import("effect/Option").Some<false>;
        nullable: false;
        primaryKey: false;
    };
}>, {
    isClientDocumentTable: false;
    requiredInsertColumnNames: "id";
}, Schema.Schema<{
    readonly id: string;
    readonly text: string;
    readonly completed: boolean;
}, {
    readonly id: string;
    readonly text: string;
    readonly completed: number;
}, never>>;
export declare const app: State.SQLite.ClientDocumentTableDef<"app", {
    readonly filter: string;
    readonly newTodoText: string;
}, {
    readonly filter: string;
    readonly newTodoText: string;
}, {
    partialSet: true;
    default: {
        id: undefined;
        value: {
            readonly newTodoText: "";
            readonly filter: "all";
        };
    };
}>;
export declare const tables: {
    todos: State.SQLite.TableDef<State.SQLite.SqliteTableDefForInput<"todos", {
        readonly id: {
            columnType: "text";
            schema: Schema.Schema<string, string, never>;
            default: import("effect/Option").None<never>;
            nullable: false;
            primaryKey: true;
        };
        readonly text: {
            columnType: "text";
            schema: Schema.Schema<string, string, never>;
            default: import("effect/Option").Some<"">;
            nullable: false;
            primaryKey: false;
        };
        readonly completed: {
            columnType: "integer";
            schema: Schema.Schema<boolean, number, never>;
            default: import("effect/Option").Some<false>;
            nullable: false;
            primaryKey: false;
        };
    }>, {
        isClientDocumentTable: false;
        requiredInsertColumnNames: "id";
    }, Schema.Schema<{
        readonly id: string;
        readonly text: string;
        readonly completed: boolean;
    }, {
        readonly id: string;
        readonly text: string;
        readonly completed: number;
    }, never>>;
    app: State.SQLite.ClientDocumentTableDef<"app", {
        readonly filter: string;
        readonly newTodoText: string;
    }, {
        readonly filter: string;
        readonly newTodoText: string;
    }, {
        partialSet: true;
        default: {
            id: undefined;
            value: {
                readonly newTodoText: "";
                readonly filter: "all";
            };
        };
    }>;
};
export declare const state: import("@livestore/livestore").InternalState;
export declare const schema: import("@livestore/livestore").FromInputSchema.DeriveSchema<{
    state: import("@livestore/livestore").InternalState;
    events: {};
}>;
export declare const makeTodoMvc: ({ otelTracer, otelContext, }?: {
    otelTracer?: otel.Tracer;
    otelContext?: otel.Context;
}) => Effect.Effect<import("@livestore/livestore").Store<import("@livestore/livestore").FromInputSchema.DeriveSchema<{
    state: import("@livestore/livestore").InternalState;
    events: {};
}>, {}>, import("@livestore/common").UnexpectedError, import("effect/Scope").Scope>;
//# sourceMappingURL=fixture.d.ts.map