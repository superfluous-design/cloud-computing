/* eslint-disable prefer-arrow/prefer-arrow-functions */
import { Duration, Effect } from '@livestore/utils/effect';
/**
 * A set of values that expire after a given timeout
 * The timeout cleanup is performed in a batched way to avoid excessive setTimeout calls
 */
export class TimeoutSet {
    values = new Map();
    timeoutHandle;
    timeoutMs;
    constructor({ timeout }) {
        this.timeoutMs = Duration.toMillis(timeout);
    }
    static make = (timeout) => Effect.gen(function* () {
        const timeoutSet = new TimeoutSet({ timeout });
        yield* Effect.addFinalizer(() => Effect.sync(() => timeoutSet.onShutdown()));
        return timeoutSet;
    });
    add(value) {
        this.values.set(value, Date.now());
        this.scheduleCleanup();
    }
    has(value) {
        return this.values.has(value);
    }
    delete(value) {
        this.values.delete(value);
    }
    scheduleCleanup() {
        if (this.timeoutHandle === undefined) {
            this.timeoutHandle = setTimeout(() => {
                this.cleanup();
                this.timeoutHandle = undefined;
            }, this.timeoutMs);
        }
    }
    cleanup() {
        const now = Date.now();
        for (const [value, timestamp] of this.values.entries()) {
            if (now - timestamp >= this.timeoutMs) {
                this.values.delete(value);
            }
        }
    }
    onShutdown = () => clearTimeout(this.timeoutHandle);
}
//# sourceMappingURL=utils.js.map