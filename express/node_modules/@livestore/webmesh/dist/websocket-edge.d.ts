import type { HttpClient } from '@livestore/utils/effect';
import { Effect, Schema, Scope, Socket, WebChannel } from '@livestore/utils/effect';
import * as WebmeshSchema from './mesh-schema.js';
import type { MeshNode } from './node.js';
declare const WSEdgeInit_base: Schema.TaggedStruct<"WSEdgeInit", {
    from: typeof Schema.String;
}>;
export declare class WSEdgeInit extends WSEdgeInit_base {
}
declare const WSEdgePayload_base: Schema.TaggedStruct<"WSEdgePayload", {
    from: typeof Schema.String;
    payload: typeof Schema.Any;
}>;
export declare class WSEdgePayload extends WSEdgePayload_base {
}
declare const WSEdgeMessage_base: Schema.Union<[typeof WSEdgeInit, typeof WSEdgePayload]>;
export declare class WSEdgeMessage extends WSEdgeMessage_base {
}
export declare const MessageMsgPack: Schema.transform<typeof Schema.Uint8ArrayFromSelf, Schema.Schema<{
    readonly _tag: "WSEdgeInit";
    readonly from: string;
} | {
    readonly _tag: "WSEdgePayload";
    readonly payload: any;
    readonly from: string;
}, {
    readonly _tag: "WSEdgeInit";
    readonly from: string;
} | {
    readonly _tag: "WSEdgePayload";
    readonly payload: any;
    readonly from: string;
}, never>>;
export type SocketType = {
    _tag: 'leaf';
    from: string;
} | {
    _tag: 'relay';
};
export declare const connectViaWebSocket: ({ node, url, openTimeout, }: {
    node: MeshNode;
    url: string;
    openTimeout?: number;
}) => Effect.Effect<void, never, Scope.Scope | HttpClient.HttpClient>;
export declare const makeWebSocketEdge: ({ socket, socketType, debug: debugInfo, }: {
    socket: Socket.Socket;
    socketType: SocketType;
    debug?: {
        id?: string;
    };
}) => Effect.Effect<{
    webChannel: WebChannel.WebChannel<typeof WebmeshSchema.Packet.Type, typeof WebmeshSchema.Packet.Type>;
    from: string;
}, never, Scope.Scope | HttpClient.HttpClient>;
export {};
//# sourceMappingURL=websocket-edge.d.ts.map