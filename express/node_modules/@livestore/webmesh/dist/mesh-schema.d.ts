import { Schema } from '@livestore/utils/effect';
declare const DirectChannelRequest_base: Schema.TaggedStruct<"DirectChannelRequest", {
    remainingHops: Schema.optional<Schema.Array$<typeof Schema.String>>;
    channelVersion: typeof Schema.Number;
    /** Only set if the request is in response to an incoming request */
    reqId: Schema.UndefinedOr<typeof Schema.String>;
    /**
     * Additionally to the `source` field, we use this field to track whether the instance of a
     * source has changed.
     */
    sourceId: typeof Schema.String;
    id: Schema.PropertySignature<":", string, never, "?:", string | undefined, true, never>;
    target: typeof Schema.String;
    source: typeof Schema.String;
    channelName: typeof Schema.String;
    hops: Schema.Array$<typeof Schema.String>;
}>;
/**
 * Needs to go through already existing DirectChannel edges, times out otherwise
 *
 * Can't yet contain the `port` because the request might be duplicated while forwarding to multiple nodes.
 * We need a clear path back to the sender to avoid this, thus we respond with a separate
 * `DirectChannelResponseSuccess` which contains the `port`.
 */
export declare class DirectChannelRequest extends DirectChannelRequest_base {
}
declare const DirectChannelResponseSuccess_base: Schema.TaggedStruct<"DirectChannelResponseSuccess", {
    reqId: typeof Schema.String;
    port: Schema.Schema<MessagePort, MessagePort, never>;
    remainingHops: Schema.Array$<typeof Schema.String>;
    channelVersion: typeof Schema.Number;
    id: Schema.PropertySignature<":", string, never, "?:", string | undefined, true, never>;
    target: typeof Schema.String;
    source: typeof Schema.String;
    channelName: typeof Schema.String;
    hops: Schema.Array$<typeof Schema.String>;
}>;
export declare class DirectChannelResponseSuccess extends DirectChannelResponseSuccess_base {
}
declare const DirectChannelResponseNoTransferables_base: Schema.TaggedStruct<"DirectChannelResponseNoTransferables", {
    reqId: typeof Schema.String;
    remainingHops: Schema.Array$<typeof Schema.String>;
    id: Schema.PropertySignature<":", string, never, "?:", string | undefined, true, never>;
    target: typeof Schema.String;
    source: typeof Schema.String;
    channelName: typeof Schema.String;
    hops: Schema.Array$<typeof Schema.String>;
}>;
export declare class DirectChannelResponseNoTransferables extends DirectChannelResponseNoTransferables_base {
}
declare const ProxyChannelRequest_base: Schema.TaggedStruct<"ProxyChannelRequest", {
    remainingHops: Schema.optional<typeof Schema.Undefined>;
    channelIdCandidate: typeof Schema.String;
    id: Schema.PropertySignature<":", string, never, "?:", string | undefined, true, never>;
    target: typeof Schema.String;
    source: typeof Schema.String;
    channelName: typeof Schema.String;
    hops: Schema.Array$<typeof Schema.String>;
}>;
export declare class ProxyChannelRequest extends ProxyChannelRequest_base {
}
declare const ProxyChannelResponseSuccess_base: Schema.TaggedStruct<"ProxyChannelResponseSuccess", {
    reqId: typeof Schema.String;
    remainingHops: Schema.Array$<typeof Schema.String>;
    combinedChannelId: typeof Schema.String;
    channelIdCandidate: typeof Schema.String;
    id: Schema.PropertySignature<":", string, never, "?:", string | undefined, true, never>;
    target: typeof Schema.String;
    source: typeof Schema.String;
    channelName: typeof Schema.String;
    hops: Schema.Array$<typeof Schema.String>;
}>;
export declare class ProxyChannelResponseSuccess extends ProxyChannelResponseSuccess_base {
}
declare const ProxyChannelPayload_base: Schema.TaggedStruct<"ProxyChannelPayload", {
    remainingHops: Schema.optional<typeof Schema.Undefined>;
    payload: typeof Schema.Any;
    combinedChannelId: typeof Schema.String;
    id: Schema.PropertySignature<":", string, never, "?:", string | undefined, true, never>;
    target: typeof Schema.String;
    source: typeof Schema.String;
    channelName: typeof Schema.String;
    hops: Schema.Array$<typeof Schema.String>;
}>;
export declare class ProxyChannelPayload extends ProxyChannelPayload_base {
}
declare const ProxyChannelPayloadAck_base: Schema.TaggedStruct<"ProxyChannelPayloadAck", {
    reqId: typeof Schema.String;
    remainingHops: Schema.Array$<typeof Schema.String>;
    combinedChannelId: typeof Schema.String;
    id: Schema.PropertySignature<":", string, never, "?:", string | undefined, true, never>;
    target: typeof Schema.String;
    source: typeof Schema.String;
    channelName: typeof Schema.String;
    hops: Schema.Array$<typeof Schema.String>;
}>;
export declare class ProxyChannelPayloadAck extends ProxyChannelPayloadAck_base {
}
declare const NetworkEdgeAdded_base: Schema.TaggedStruct<"NetworkEdgeAdded", {
    id: Schema.PropertySignature<":", string, never, "?:", string | undefined, true, never>;
    source: typeof Schema.String;
    target: typeof Schema.String;
}>;
/**
 * Broadcast to all nodes when a new edge is added.
 * Mostly used for auto-reconnect purposes.
 */
export declare class NetworkEdgeAdded extends NetworkEdgeAdded_base {
}
declare const NetworkTopologyRequest_base: Schema.TaggedStruct<"NetworkTopologyRequest", {
    id: Schema.PropertySignature<":", string, never, "?:", string | undefined, true, never>;
    hops: Schema.Array$<typeof Schema.String>;
    /** Always fixed to who requested the topology */
    source: typeof Schema.String;
    target: Schema.Literal<["-"]>;
}>;
export declare class NetworkTopologyRequest extends NetworkTopologyRequest_base {
}
declare const NetworkTopologyResponse_base: Schema.TaggedStruct<"NetworkTopologyResponse", {
    id: Schema.PropertySignature<":", string, never, "?:", string | undefined, true, never>;
    reqId: typeof Schema.String;
    remainingHops: Schema.Array$<typeof Schema.String>;
    nodeName: typeof Schema.String;
    edges: Schema.Array$<typeof Schema.String>;
    /** Always fixed to who requested the topology */
    source: typeof Schema.String;
    target: Schema.Literal<["-"]>;
}>;
export declare class NetworkTopologyResponse extends NetworkTopologyResponse_base {
}
export declare const BroadcastChannelPacket: Schema.TaggedStruct<"BroadcastChannelPacket", {
    id: Schema.PropertySignature<":", string, never, "?:", string | undefined, true, never>;
    channelName: typeof Schema.String;
    /**
     * The payload is expected to be encoded/decoded by the send/listen schema.
     * Transferables are not supported.
     */
    payload: typeof Schema.Any;
    hops: Schema.Array$<typeof Schema.String>;
    source: typeof Schema.String;
    target: Schema.Literal<["-"]>;
}>;
declare const DirectChannelPacket_base: Schema.Union<[typeof DirectChannelRequest, typeof DirectChannelResponseSuccess, typeof DirectChannelResponseNoTransferables]>;
export declare class DirectChannelPacket extends DirectChannelPacket_base {
}
declare const ProxyChannelPacket_base: Schema.Union<[typeof ProxyChannelRequest, typeof ProxyChannelResponseSuccess, typeof ProxyChannelPayload, typeof ProxyChannelPayloadAck]>;
export declare class ProxyChannelPacket extends ProxyChannelPacket_base {
}
declare const Packet_base: Schema.Union<[typeof DirectChannelPacket, typeof ProxyChannelPacket, typeof NetworkEdgeAdded, typeof NetworkTopologyRequest, typeof NetworkTopologyResponse, Schema.TaggedStruct<"BroadcastChannelPacket", {
    id: Schema.PropertySignature<":", string, never, "?:", string | undefined, true, never>;
    channelName: typeof Schema.String;
    /**
     * The payload is expected to be encoded/decoded by the send/listen schema.
     * Transferables are not supported.
     */
    payload: typeof Schema.Any;
    hops: Schema.Array$<typeof Schema.String>;
    source: typeof Schema.String;
    target: Schema.Literal<["-"]>;
}>]>;
export declare class Packet extends Packet_base {
}
declare const DirectChannelPing_base: Schema.TaggedStruct<"DirectChannelPing", {}>;
export declare class DirectChannelPing extends DirectChannelPing_base {
}
declare const DirectChannelPong_base: Schema.TaggedStruct<"DirectChannelPong", {}>;
export declare class DirectChannelPong extends DirectChannelPong_base {
}
export {};
//# sourceMappingURL=mesh-schema.d.ts.map