import { type Effect, Schema } from '@livestore/utils/effect';
import type { DirectChannelPacket, Packet, ProxyChannelPacket } from './mesh-schema.js';
export type ProxyQueueItem = {
    packet: typeof ProxyChannelPacket.Type;
    respondToSender: (msg: typeof ProxyChannelPacket.Type) => Effect.Effect<void>;
};
export type MessageQueueItem = {
    packet: typeof DirectChannelPacket.Type;
    respondToSender: (msg: typeof DirectChannelPacket.Type) => Effect.Effect<void>;
};
export type MeshNodeName = string;
export type ChannelName = string;
export type ChannelKey = `target:${MeshNodeName}, channelName:${ChannelName}`;
declare const EdgeAlreadyExistsError_base: Schema.TaggedErrorClass<EdgeAlreadyExistsError, "EdgeAlreadyExistsError", {
    readonly _tag: Schema.tag<"EdgeAlreadyExistsError">;
} & {
    target: typeof Schema.String;
}>;
export declare class EdgeAlreadyExistsError extends EdgeAlreadyExistsError_base {
}
export declare const packetAsOtelAttributes: (packet: typeof Packet.Type) => {
    packet?: {
        readonly remainingHops?: readonly string[] | undefined;
        readonly channelVersion: number;
        readonly reqId: string | undefined;
        readonly sourceId: string;
        readonly id: string;
        readonly target: string;
        readonly source: string;
        readonly channelName: string;
        readonly hops: readonly string[];
        readonly _tag: "DirectChannelRequest";
    } | {
        readonly remainingHops: readonly string[];
        readonly reqId: string;
        readonly id: string;
        readonly target: string;
        readonly source: string;
        readonly channelName: string;
        readonly hops: readonly string[];
        readonly _tag: "DirectChannelResponseNoTransferables";
    } | {
        readonly remainingHops?: undefined;
        readonly id: string;
        readonly target: string;
        readonly source: string;
        readonly channelName: string;
        readonly hops: readonly string[];
        readonly _tag: "ProxyChannelRequest";
        readonly channelIdCandidate: string;
    } | {
        readonly remainingHops: readonly string[];
        readonly reqId: string;
        readonly id: string;
        readonly target: string;
        readonly source: string;
        readonly channelName: string;
        readonly hops: readonly string[];
        readonly _tag: "ProxyChannelResponseSuccess";
        readonly channelIdCandidate: string;
        readonly combinedChannelId: string;
    } | {
        readonly remainingHops: readonly string[];
        readonly reqId: string;
        readonly id: string;
        readonly target: string;
        readonly source: string;
        readonly channelName: string;
        readonly hops: readonly string[];
        readonly _tag: "ProxyChannelPayloadAck";
        readonly combinedChannelId: string;
    } | {
        readonly id: string;
        readonly target: string;
        readonly source: string;
        readonly _tag: "NetworkEdgeAdded";
    } | {
        readonly id: string;
        readonly target: "-";
        readonly source: string;
        readonly hops: readonly string[];
        readonly _tag: "NetworkTopologyRequest";
    } | {
        readonly remainingHops: readonly string[];
        readonly reqId: string;
        readonly id: string;
        readonly target: "-";
        readonly source: string;
        readonly _tag: "NetworkTopologyResponse";
        readonly nodeName: string;
        readonly edges: readonly string[];
    } | {
        readonly id: string;
        readonly target: "-";
        readonly source: string;
        readonly channelName: string;
        readonly hops: readonly string[];
        readonly _tag: "BroadcastChannelPacket";
        readonly payload: any;
    } | undefined;
    packetId: string;
    'span.label': string;
};
export declare const ListenForChannelResult: Schema.Struct<{
    channelName: typeof Schema.String;
    source: typeof Schema.String;
    mode: Schema.Union<[Schema.Literal<["proxy"]>, Schema.Literal<["direct"]>]>;
}>;
export type ListenForChannelResult = typeof ListenForChannelResult.Type;
export {};
//# sourceMappingURL=common.d.ts.map