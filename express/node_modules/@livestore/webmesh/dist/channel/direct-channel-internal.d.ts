import type { PubSub } from '@livestore/utils/effect';
import { Effect, Queue, Scope, WebChannel } from '@livestore/utils/effect';
import { type ChannelName, type MeshNodeName, type MessageQueueItem } from '../common.js';
import * as MeshSchema from '../mesh-schema.js';
export interface MakeDirectChannelArgs {
    nodeName: MeshNodeName;
    /** Queue of incoming messages for this channel */
    incomingPacketsQueue: Queue.Queue<MessageQueueItem>;
    newEdgeAvailablePubSub: PubSub.PubSub<MeshNodeName>;
    channelName: ChannelName;
    target: MeshNodeName;
    sendPacket: (packet: typeof MeshSchema.DirectChannelPacket.Type) => Effect.Effect<void>;
    checkTransferableEdges: (packet: typeof MeshSchema.DirectChannelPacket.Type) => typeof MeshSchema.DirectChannelResponseNoTransferables.Type | undefined;
    schema: WebChannel.OutputSchema<any, any, any, any>;
}
/**
 * The channel version is important here, as a channel will only be established once both sides have the same version.
 * The version is used to avoid concurrency issues where both sides have different incompatible message ports.
 */
export declare const makeDirectChannelInternal: ({ nodeName, incomingPacketsQueue, target, checkTransferableEdges, channelName, schema: schema_, sendPacket, channelVersion, scope, sourceId, }: MakeDirectChannelArgs & {
    channelVersion: number;
    /** We're passing in the closeable scope from the wrapping direct channel */
    scope: Scope.CloseableScope;
    sourceId: string;
}) => Effect.Effect<WebChannel.WebChannel<any, any>, typeof MeshSchema.DirectChannelResponseNoTransferables.Type, Scope.Scope>;
//# sourceMappingURL=direct-channel-internal.d.ts.map