"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.width = exports.vsep = exports.vcat = exports.vbar = exports.union = exports.unAnnotate = exports.tupled = exports.textSpaces = exports.text = exports.surround = exports.string = exports.squote = exports.squareBracketed = exports.spaces = exports.space = exports.softLineBreak = exports.softLine = exports.slash = exports.singleQuoted = exports.seps = exports.semi = exports.rparen = exports.renderStream = exports.render = exports.reflow = exports.reAnnotate = exports.rbracket = exports.rbrace = exports.rangle = exports.punctuate = exports.parenthesized = exports.pageWidth = exports.nesting = exports.nest = exports.match = exports.map = exports.lparen = exports.list = exports.lineBreak = exports.line = exports.lbracket = exports.lbrace = exports.langle = exports.isWithPageWidth = exports.isUnion = exports.isText = exports.isNesting = exports.isNest = exports.isLine = exports.isFlatAlt = exports.isFail = exports.isEmpty = exports.isDoc = exports.isColumn = exports.isChar = exports.isCat = exports.isAnnotated = exports.indent = exports.hsep = exports.hcat = exports.hardLine = exports.hang = exports.group = exports.getSemigroup = exports.getMonoid = exports.flatten = exports.flatAlt = exports.fillSep = exports.fillCat = exports.fillBreak = exports.fill = exports.fail = exports.equalSign = exports.encloseSep = exports.empty = exports.dquote = exports.doubleQuoted = exports.dot = exports.curlyBraced = exports.concatWith = exports.comma = exports.column = exports.colon = exports.char = exports.changesUponFlattening = exports.cats = exports.catWithSpace = exports.catWithSoftLineBreak = exports.catWithSoftLine = exports.catWithLineBreak = exports.catWithLine = exports.cat = exports.backslash = exports.annotate = exports.angleBracketed = exports.alterAnnotations = exports.align = exports.Invariant = exports.DocTypeId = exports.Covariant = void 0;
exports.words = void 0;
var internal = _interopRequireWildcard(require("./internal/doc.js"));
var InternalRender = _interopRequireWildcard(require("./internal/render.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * The abstract data type `Doc<A>` represents prettified documents that have
 * been annotated with data of type `A`.
 *
 * More specifically, a value of type `Doc` represents a non-empty set of
 * possible layouts for a given document. The layout algorithms select one of
 * these possibilities, taking into account variables such as the width of the
 * document.
 *
 * The annotation is an arbitrary piece of data associated with (part of) a
 * document. Annotations may be used by rendering algorithms to display
 * documents differently by providing information such as:
 * - color information (e.g., when rendering to the terminal)
 * - mouseover text (e.g., when rendering to rich HTML)
 * - whether to show something or not (to allow simple or detailed versions)
 *
 * @since 1.0.0
 */

// -----------------------------------------------------------------------------
// Models
// -----------------------------------------------------------------------------
/**
 * @since 1.0.0
 * @category symbol
 */
const DocTypeId = exports.DocTypeId = internal.DocTypeId;
// -----------------------------------------------------------------------------
// Refinements
// -----------------------------------------------------------------------------
/**
 * Returns `true` if the specified value is a `Doc`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
const isDoc = exports.isDoc = internal.isDoc;
/**
 * Returns `true` if the specified `Doc` is a `Fail`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
const isFail = exports.isFail = internal.isFail;
/**
 * Returns `true` if the specified `Doc` is an `Empty`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
const isEmpty = exports.isEmpty = internal.isEmpty;
/**
 * Returns `true` if the specified `Doc` is a `Char`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
const isChar = exports.isChar = internal.isChar;
/**
 * Returns `true` if the specified `Doc` is a `Text`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
const isText = exports.isText = internal.isText;
/**
 * Returns `true` if the specified `Doc` is a `Line`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
const isLine = exports.isLine = internal.isLine;
/**
 * Returns `true` if the specified `Doc` is a `FlatAlt`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
const isFlatAlt = exports.isFlatAlt = internal.isFlatAlt;
/**
 * Returns `true` if the specified `Doc` is a `Cat`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
const isCat = exports.isCat = internal.isCat;
/**
 * Returns `true` if the specified `Doc` is a `Nest`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
const isNest = exports.isNest = internal.isNest;
/**
 * Returns `true` if the specified `Doc` is a `Union`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
const isUnion = exports.isUnion = internal.isUnion;
/**
 * Returns `true` if the specified `Doc` is a `Column`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
const isColumn = exports.isColumn = internal.isColumn;
/**
 * Returns `true` if the specified `Doc` is a `WithPageWidth`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
const isWithPageWidth = exports.isWithPageWidth = internal.isWithPageWidth;
/**
 * Returns `true` if the specified `Doc` is a `Nesting`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
const isNesting = exports.isNesting = internal.isNesting;
/**
 * Returns `true` if the specified `Doc` is a `Annotated`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
const isAnnotated = exports.isAnnotated = internal.isAnnotated;
// -----------------------------------------------------------------------------
// Constructors
// -----------------------------------------------------------------------------
/**
 * A document containing a single character.
 *
 * **Invariants**
 * - Cannot be the newline (`"\n"`) character
 *
 * @since 1.0.0
 * @category constructors
 */
const char = exports.char = internal.char;
/**
 * A document containing a string of text.
 *
 * **Invariants**
 * - Text cannot be less than two characters long
 * - Text cannot contain a newline (`"\n"`) character
 *
 * @since 1.0.0
 * @category constructors
 */
const text = exports.text = internal.text;
/**
 * Constructs a document containing a string of text.
 *
 * **Note**: newline characters (`\n`) contained in the provided string will be
 * disregarded (i.e. not rendered) in the output document.
 *
 * @since 1.0.0
 * @category constructors
 */
const string = exports.string = internal.string;
// -----------------------------------------------------------------------------
// Primitives
// -----------------------------------------------------------------------------
/**
 * The `empty` document behaves like a document containing the empty string
 * (`""`), so it has a height of `1`.
 *
 * This may lead to surprising behavior if the empty document is expected to
 * bear no weight inside certain layout functions, such as`vcat`, where it will
 * render an empty line of output.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * const doc = Doc.vsep([
 *   Doc.text("hello"),
 *   // `parentheses` for visibility purposes only
 *   Doc.parenthesized(Doc.empty),
 *   Doc.text("world")
 * ])
 *
 * const expected = `|hello
 *                   |()
 *                   |world`
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   String.stripMargin(expected)
 * )
 * ```
 *
 * @since 1.0.0
 * @category primitives
 */
const empty = exports.empty = internal.empty;
/**
 * The `fail` document is a document that cannot be rendered.
 *
 * Generally occurs when flattening a line. The layout algorithms will reject
 * this document and choose a more suitable rendering.
 *
 * @since 1.0.0
 * @category primitives
 */
const fail = exports.fail = internal.fail;
/**
 * The `line` document advances to the next line and indents to the current
 * nesting level. However, `line` will behave like `space` if the line break is
 * undone by `group`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * const doc: Doc.Doc<never> = Doc.hcat([
 *   Doc.text("lorem ipsum"),
 *   Doc.line,
 *   Doc.text("dolor sit amet")
 * ])
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   String.stripMargin(
 *     `|lorem ipsum
 *      |dolor sit amet`
 *   )
 * )
 * assert.strictEqual(
 *   Doc.render(Doc.group(doc), { style: "pretty" }),
 *   "lorem ipsum dolor sit amet"
 * )
 * ```
 *
 * @since 1.0.0
 * @category primitives
 */
const line = exports.line = internal.line;
/**
 * The `lineBreak` document is like `line` but behaves like `empty` if the line
 * break is undone by `group` (instead of `space`).
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * const doc: Doc.Doc<never> = Doc.hcat([
 *   Doc.text("lorem ipsum"),
 *   Doc.lineBreak,
 *   Doc.text("dolor sit amet")
 * ])
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   String.stripMargin(
 *     `|lorem ipsum
 *      |dolor sit amet`
 *   )
 * )
 * assert.strictEqual(
 *   Doc.render(Doc.group(doc), { style: "pretty" }),
 *   "lorem ipsumdolor sit amet"
 * )
 * ```
 *
 * @since 1.0.0
 * @category primitives
 */
const lineBreak = exports.lineBreak = internal.lineBreak;
/**
 * The `softLine` document behaves like `space` if the resulting output fits
 * onto the page, otherwise it behaves like `line`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * const doc: Doc.Doc<never> = Doc.hcat([
 *   Doc.text("lorem ipsum"),
 *   Doc.softLine,
 *   Doc.text("dolor sit amet")
 * ])
 *
 * // Here we have enough space to put everything onto one line
 * assert.strictEqual(
 *   Doc.render(doc, {
 *     style: "pretty",
 *     options: { lineWidth: 80 }
 *   }),
 *   "lorem ipsum dolor sit amet"
 * )
 *
 * // If the page width is narrowed to `10`, the layout algorithm will
 * // introduce a line break
 * assert.strictEqual(
 *   Doc.render(Doc.group(doc), {
 *     style: "pretty",
 *     options: { lineWidth: 10 }
 *   }),
 *   String.stripMargin(
 *     `|lorem ipsum
 *      |dolor sit amet`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category primitives
 */
const softLine = exports.softLine = internal.softLine;
/**
 * The `softLineBreak` document is similar to `softLine`, but behaves like
 * `empty` if the resulting output does not fit onto the page (instead of
 * `space`).
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * const doc: Doc.Doc<never> = Doc.hcat([
 *   Doc.text("ThisText"),
 *   Doc.softLineBreak,
 *   Doc.text("IsWayTooLong")
 * ])
 *
 * // With enough space, we get direct concatenation of documents:
 * assert.strictEqual(
 *   Doc.render(doc, {
 *     style: "pretty",
 *     options: { lineWidth: 80 }
 *   }),
 *   "ThisTextIsWayTooLong"
 * )
 *
 * // If the page width is narrowed to `10`, the layout algorithm will
 * // introduce a line break
 * assert.strictEqual(
 *   Doc.render(Doc.group(doc), {
 *     style: "pretty",
 *     options: { lineWidth: 10 }
 *   }),
 *   String.stripMargin(
 *     `|ThisText
 *      |IsWayTooLong`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category primitives
 */
const softLineBreak = exports.softLineBreak = internal.softLineBreak;
/**
 * The `hardLine` document is always laid out as a line break, regardless of
 * space or whether or not the document was `group`"ed.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * const doc: Doc.Doc<never> = Doc.hcat([
 *   Doc.text("lorem ipsum"),
 *   Doc.hardLine,
 *   Doc.text("dolor sit amet")
 * ])
 *
 * // Even with enough space, a line break is introduced
 * assert.strictEqual(
 *   Doc.render(doc, {
 *     style: "pretty",
 *     options: { lineWidth: 1000 }
 *   }),
 *   String.stripMargin(
 *     `|lorem ipsum
 *      |dolor sit amet`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category primitives
 */
const hardLine = exports.hardLine = internal.hardLine;
/**
 * A document containing a single `\` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const backslash = exports.backslash = internal.backslash;
/**
 * A document containing a single `:` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const colon = exports.colon = internal.colon;
/**
 * A document containing a single `,` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const comma = exports.comma = internal.comma;
/**
 * A document containing a single `.` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const dot = exports.dot = internal.dot;
/**
 * A document containing a single `"` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const dquote = exports.dquote = internal.dquote;
/**
 * A document containing a single `=` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const equalSign = exports.equalSign = internal.equalSign;
/**
 * A document containing a single `<` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const langle = exports.langle = internal.langle;
/**
 * A document containing a single `{` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const lbrace = exports.lbrace = internal.lbrace;
/**
 * A document containing a single `[` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const lbracket = exports.lbracket = internal.lbracket;
/**
 * A document containing a single `(` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const lparen = exports.lparen = internal.lparen;
/**
 * A document containing a single `>` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const rangle = exports.rangle = internal.rangle;
/**
 * A document containing a single `}` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const rbrace = exports.rbrace = internal.rbrace;
/**
 * A document containing a single `]` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const rbracket = exports.rbracket = internal.rbracket;
/**
 * A document containing a single `)` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const rparen = exports.rparen = internal.rparen;
/**
 * A document containing a single `;` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const semi = exports.semi = internal.semi;
/**
 * A document containing a single `/` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const slash = exports.slash = internal.slash;
/**
 * A document containing a single `"` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const squote = exports.squote = internal.squote;
/**
 * A document containing a single ` ` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const space = exports.space = internal.space;
/**
 * A document containing a single `|` character.
 *
 * @since 1.0.0
 * @category primitives
 */
const vbar = exports.vbar = internal.vbar;
// -----------------------------------------------------------------------------
// Concatenation
// -----------------------------------------------------------------------------
/**
 * The `cat` combinator lays out two documents separated by nothing.
 *
 * @since 1.0.0
 * @category concatenation
 */
const cat = exports.cat = internal.cat;
/**
 * The `cats` combinator will attempt to lay out a collection of documents
 * separated by nothing. If the output does not fit the page, then the documents
 * will be separated by newlines. This is what differentiates it from `vcat`,
 * which always lays out documents beneath one another.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * const doc: Doc.Doc<never> = Doc.hsep([
 *   Doc.text("Docs:"),
 *   Doc.cats(Doc.words("lorem ipsum dolor"))
 * ])
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   "Docs: loremipsumdolor"
 * )
 *
 * // If the document exceeds the width of the page, the documents are rendered
 * // one above another
 * assert.strictEqual(
 *   Doc.render(doc, {
 *     style: "pretty",
 *     options: { lineWidth: 10 }
 *   }),
 *   String.stripMargin(
 *     `|Docs: lorem
 *      |ipsum
 *      |dolor`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category concatenation
 */
const cats = exports.cats = internal.cats;
/**
 * The `catWithLine` combinator concatenates two documents by placing a `line`
 * document between them.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 * import * as String from "effect/String"
 *
 * const doc: Doc.Doc<never> = pipe(
 *   Doc.char("a"),
 *   Doc.catWithLine(Doc.char("b"))
 * )
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   String.stripMargin(
 *     `|a
 *      |b`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category concatenation
 */
const catWithLine = exports.catWithLine = internal.catWithLine;
/**
 * The `catWithLineBreak` combinator concatenates two documents by placing a
 * `lineBreak` document between them.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 * import * as String from "effect/String"
 *
 * const doc: Doc.Doc<never> = pipe(
 *   Doc.char("a"),
 *   Doc.catWithLineBreak(Doc.char("b"))
 * )
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   String.stripMargin(
 *     `|a
 *      |b`
 *   )
 * )
 *
 * assert.strictEqual(
 *   Doc.render(Doc.group(doc), { style: "pretty" }),
 *   "ab"
 * )
 * ```
 *
 * @since 1.0.0
 * @category concatenation
 */
const catWithLineBreak = exports.catWithLineBreak = internal.catWithLineBreak;
/**
 * The `catWithSoftLine` combinator concatenates two documents by placing a
 * `softLine` document between them.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 * import * as String from "effect/String"
 *
 * const doc: Doc.Doc<never> = pipe(
 *   Doc.char("a"),
 *   Doc.catWithSoftLine(Doc.char("b"))
 * )
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   "a b"
 * )
 *
 * assert.strictEqual(
 *   Doc.render(doc, {
 *     style: "pretty",
 *     options: { lineWidth: 1 }
 *   }),
 *   String.stripMargin(
 *     `|a
 *      |b`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category concatenation
 */
const catWithSoftLine = exports.catWithSoftLine = internal.catWithSoftLine;
/**
 * The `catWithSoftLineBreak` combinator concatenates two documents by
 * placing a `softLineBreak` document between them.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 * import * as String from "effect/String"
 *
 * const doc: Doc.Doc<never> = pipe(
 *   Doc.char("a"),
 *   Doc.catWithSoftLineBreak(Doc.char("b"))
 * )
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   "ab"
 * )
 *
 * assert.strictEqual(
 *   Doc.render(doc, {
 *     style: "pretty",
 *     options: { lineWidth: 1 }
 *   }),
 *   String.stripMargin(
 *     `|a
 *      |b`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category concatenation
 */
const catWithSoftLineBreak = exports.catWithSoftLineBreak = internal.catWithSoftLineBreak;
/**
 * The `catWithSpace` combinator concatenates two documents by placing a
 * `space` document between them.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 *
 * const doc: Doc.Doc<never> = pipe(
 *   Doc.char("a"),
 *   Doc.catWithSpace(Doc.char("b"))
 * )
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   "a b"
 * )
 * ```
 *
 * @since 1.0.0
 * @category concatenation
 */
const catWithSpace = exports.catWithSpace = internal.catWithSpace;
/**
 * The `concatWith` combinator concatenates all documents in a collection
 * element-wise with the specified binary function.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 *
 * const doc: Doc.Doc<never> = pipe(
 *   [Doc.char("a"), Doc.char("b")],
 *   Doc.concatWith((x, y) => Doc.catWithSpace(y)(x))
 * )
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   "a b"
 * )
 * ```
 *
 * @since 1.0.0
 * @category concatenation
 */
const concatWith = exports.concatWith = internal.concatWith;
/**
 * The `vcat` combinator concatenates all documents in a collection vertically.
 * If the output is grouped then the line breaks are removed.
 *
 * In other words `vcat` is like `vsep`, with newlines removed instead of
 * replaced by spaces.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * const doc: Doc.Doc<never> = Doc.vcat(Doc.words("lorem ipsum dolor"))
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   String.stripMargin(
 *     `|lorem
 *      |ipsum
 *      |dolor`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category concatenation
 */
const vcat = exports.vcat = internal.vcat;
/**
 * The `hcat` combinator concatenates all documents in a collection horizontally
 * without any spacing.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * const doc: Doc.Doc<never> = Doc.hcat(Doc.words("lorem ipsum dolor"))
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   "loremipsumdolor"
 * )
 * ```
 *
 * @since 1.0.0
 * @category concatenation
 */
const hcat = exports.hcat = internal.hcat;
/**
 * The `fillCat` combinator concatenates all documents in a collection
 * horizontally by placing a `empty` between each pair of documents as long as
 * they fit the page. Once the page width is exceeded, a `lineBreak` is inserted
 * and the process is repeated for all documents in the collection.
 *
 * **Note**: the use of `lineBreak` means that if `group`ed, the documents will
 * be separated with `empty` instead of newlines. See `fillSep` if you want a
 * `space` instead.
 *
 * @since 1.0.0
 * @category concatenation
 */
const fillCat = exports.fillCat = internal.fillCat;
// -----------------------------------------------------------------------------
// Separation
// -----------------------------------------------------------------------------
/**
 * The `hsep` combinator concatenates all documents in a collection horizontally
 * by placing a `space` between each pair of documents.
 *
 * For automatic line breaks, consider using `fillSep`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 *
 * const doc: Doc.Doc<never> = Doc.hsep(Doc.words("lorem ipsum dolor sit amet"))
 *
 * assert.strictEqual(
 *   Doc.render(doc, {
 *     style: "pretty",
 *     options: { lineWidth: 80 }
 *   }),
 *   "lorem ipsum dolor sit amet"
 * )
 *
 * // The `hsep` combinator will not introduce line breaks on its own, even when
 * // the page is too narrow
 * assert.strictEqual(
 *   Doc.render(doc, {
 *     style: "pretty",
 *     options: { lineWidth: 5 }
 *   }),
 *   "lorem ipsum dolor sit amet"
 * )
 * ```
 *
 * @since 1.0.0
 * @category separation
 */
const hsep = exports.hsep = internal.hsep;
/**
 * The `vsep` combinator concatenates all documents in a collection vertically.
 * If a `group` undoes the line breaks inserted by `vsep`, the documents are
 * separated with a space instead.
 *
 * When a `vsep` is `group`ed, the documents are separated with a `space` if the
 * layoutfits the page, otherwise nothing is done. See the `sep` convenience
 * function for this use case.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * const unaligned = Doc.hsep([
 *   Doc.text("prefix"),
 *   Doc.vsep(Doc.words("text to lay out"))
 * ])
 *
 * assert.strictEqual(
 *   Doc.render(unaligned, { style: "pretty" }),
 *   String.stripMargin(
 *     `|prefix text
 *      |to
 *      |lay
 *      |out`
 *   )
 * )
 *
 * // The `align` function can be used to align the documents under their first
 * // element
 * const aligned = Doc.hsep([
 *   Doc.text("prefix"),
 *   Doc.align(Doc.vsep(Doc.words("text to lay out")))
 * ])
 *
 * assert.strictEqual(
 *   Doc.render(aligned, { style: "pretty" }),
 *   String.stripMargin(
 *     `|prefix text
 *      |       to
 *      |       lay
 *      |       out`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category separation
 */
const vsep = exports.vsep = internal.vsep;
/**
 * The `fillSep` combinator concatenates all documents in a collection
 * horizontally by placing a `space` between each pair of documents as long as
 * they fit the page. Once the page width is exceeded, a `line` is inserted and
 * the process is repeated for all documents in the collection.
 *
 * **Note**: the use of `line` means that if `group`ed, the documents will be
 * separated with a `space` instead of newlines. See `fillCat` if you do not
 * want a `space`.
 *
 * @since 1.0.0
 * @category separation
 */
const fillSep = exports.fillSep = internal.fillSep;
/**
 * The `seps` combinator will attempt to lay out a collection of documents
 * separated by `space`s. If the output does not fit the page, then the
 * documents will be separated by newlines. This is what differentiates it from
 * `vsep`, which always lays out documents beneath one another.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * const doc: Doc.Doc<never> = Doc.hsep([
 *   Doc.text("prefix"),
 *   Doc.seps(Doc.words("text to lay out"))
 * ])
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   "prefix text to lay out"
 * )
 *
 * // If the page width is too narrow, documents are separated by newlines
 * assert.strictEqual(
 *   Doc.render(doc, {
 *     style: "pretty",
 *     options: { lineWidth: 20 }
 *   }),
 *   String.stripMargin(
 *     `|prefix text
 *      |to
 *      |lay
 *      |out`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category separation
 */
const seps = exports.seps = internal.seps;
// -----------------------------------------------------------------------------
// Alternative Layouts
// -----------------------------------------------------------------------------
/**
 * The `flatAlt` document will render `left` by default. However, when
 * `group`ed, `y` will be preferred with `left` as the fallback for cases where
 * `y` does not fit onto the page.
 *
 * **NOTE**:
 * Users should be careful to ensure that `left` is less wide than `right`.
 * Otherwise, if `right` ends up not fitting the page, then the layout
 * algorithms will fall back to an even wider layout.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 * import * as String from "effect/String"
 *
 * const open = pipe(Doc.empty, Doc.flatAlt(Doc.text("{ ")))
 * const close = pipe(Doc.empty, Doc.flatAlt(Doc.text(" }")))
 * const separator = pipe(Doc.empty, Doc.flatAlt(Doc.text("; ")))
 *
 * const prettyDo = <A>(documents: Array<Doc.Doc<A>>): Doc.Doc<A> => {
 *   return pipe(
 *     Doc.hsep([
 *       Doc.text("do"),
 *       pipe(
 *         documents,
 *         Doc.encloseSep(open, close, separator),
 *         Doc.align
 *       )
 *     ]),
 *     Doc.group
 *   )
 * }
 *
 * const statements = [
 *   Doc.text("name:_ <- getArgs"),
 *   Doc.text("let greet = \"Hello, \" <> name"),
 *   Doc.text("putStrLn greet")
 * ]
 *
 * // If it fits, then the content is put onto a single line with the `{;}` style
 * assert.strictEqual(
 *   pipe(
 *     prettyDo(statements),
 *     Doc.render({
 *       style: "pretty",
 *       options: { lineWidth: 80 }
 *     })
 *   ),
 *   "do { name:_ <- getArgs; let greet = \"Hello, \" <> name; putStrLn greet }"
 * )
 *
 * // When there is not enough space, the content is broken up onto multiple lines
 * assert.strictEqual(
 *   pipe(
 *     prettyDo(statements),
 *     Doc.render({
 *       style: "pretty",
 *       options: { lineWidth: 10 }
 *     })
 *   ),
 *   String.stripMargin(
 *     `|do name:_ <- getArgs
 *      |   let greet = "Hello, " <> name
 *      |   putStrLn greet`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category alternative layouts
 */
const flatAlt = exports.flatAlt = internal.flatAlt;
/**
 * @since 1.0.0
 * @category alternative layouts
 */
const union = exports.union = internal.union;
/**
 * The `group` combinator attempts to lay out a document onto a single line by
 * removing the contained line breaks. If the result does not fit the page, or
 * if a `hardLine` prevents flattening the document, `x` is laid out without
 * any changes.
 *
 * The `group` function is key to layouts that adapt to available space nicely.
 *
 * @since 1.0.0
 * @category alternative layouts
 */
const group = exports.group = internal.group;
// -----------------------------------------------------------------------------
// Reactive Layouts
// -----------------------------------------------------------------------------
/**
 * Lays out a document depending upon the column at which the document starts.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * // Example 1:
 * const example1 = Doc.column((l) =>
 *   Doc.hsep([Doc.text("Columns are"), Doc.text(`${l}-based`)])
 * )
 *
 * assert.strictEqual(
 *   Doc.render(example1, { style: "pretty" }),
 *   "Columns are 0-based"
 * )
 *
 * // Example 2:
 * const doc = Doc.hsep([
 *   Doc.text("prefix"),
 *   Doc.column((l) => Doc.text(`| <- column ${l}`))
 * ])
 *
 * const example2 = Doc.vsep([0, 4, 8].map((n) => Doc.indent(n)(doc)))
 *
 * assert.strictEqual(
 *   Doc.render(example2, { style: "pretty" }),
 *   String.stripMargin(
 *     `|prefix | <- column 7
 *      |    prefix | <- column 11
 *      |        prefix | <- column 15`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category reactive layouts
 */
const column = exports.column = internal.column;
/**
 * Lays out a document depending upon the current nesting level (i.e., the
 * current indentation of the document).
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * const doc = Doc.hsep([
 *   Doc.text("prefix"),
 *   Doc.nesting((l) => Doc.squareBracketed(Doc.text(`Nested: ${l}`)))
 * ])
 *
 * const example = Doc.vsep([0, 4, 8].map((n) => Doc.indent(n)(doc)))
 *
 * assert.strictEqual(
 *   Doc.render(example, { style: "pretty" }),
 *   String.stripMargin(
 *     `|prefix [Nested: 0]
 *      |    prefix [Nested: 4]
 *      |        prefix [Nested: 8]`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category reactive layouts
 */
const nesting = exports.nesting = internal.nesting;
/**
 * The `width` combinator makes the column width of a document available to the
 * document while rendering.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 * import * as String from "effect/String"
 *
 * const annotate = <A>(doc: Doc.Doc<A>): Doc.Doc<A> =>
 *   pipe(
 *     Doc.squareBracketed(doc),
 *     Doc.width((w) => Doc.text(` <- width: ${w}`))
 *   )
 *
 * const docs = [
 *   Doc.text("---"),
 *   Doc.text("------"),
 *   Doc.indent(Doc.text("---"), 3),
 *   Doc.vsep([Doc.text("---"), Doc.indent(Doc.text("---"), 4)])
 * ]
 *
 * const doc = Doc.align(Doc.vsep(docs.map(annotate)))
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   String.stripMargin(
 *     `|[---] <- width: 5
 *      |[------] <- width: 8
 *      |[   ---] <- width: 8
 *      |[---
 *      |    ---] <- width: 8`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category reactive layouts
 */
const width = exports.width = internal.width;
/**
 * Lays out a document according to the document"s`PageWidth`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * const doc = Doc.hsep([
 *   Doc.text("prefix"),
 *   Doc.pageWidth((pageWidth) => {
 *     switch (pageWidth._tag) {
 *       case "AvailablePerLine": {
 *         const { lineWidth, ribbonFraction } = pageWidth
 *         return Doc.squareBracketed(
 *           Doc.text(`Width: ${lineWidth}, Ribbon Fraction: ${ribbonFraction}`)
 *         )
 *       }
 *       case "Unbounded": {
 *         return Doc.empty
 *       }
 *     }
 *   })
 * ])
 *
 * const example = Doc.vsep([0, 4, 8].map((n) => Doc.indent(n)(doc)))
 *
 * assert.strictEqual(
 *   Doc.render(example, {
 *     style: "pretty",
 *     options: { lineWidth: 32 }
 *   }),
 *   String.stripMargin(
 *     `|prefix [Width: 32, Ribbon Fraction: 1]
 *      |    prefix [Width: 32, Ribbon Fraction: 1]
 *      |        prefix [Width: 32, Ribbon Fraction: 1]`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category constructors
 */
const pageWidth = exports.pageWidth = internal.pageWidth;
// -----------------------------------------------------------------------------
// Alignment
// -----------------------------------------------------------------------------
/**
 * Lays out a document with the current nesting level (indentation
 * of the following lines) increased by the specified `indent`.
 * Negative values are allowed and will decrease the nesting level
 * accordingly.
 *
 * See also:
 * * `hang`: nest a document relative to the current cursor
 * position instead of the current nesting level
 * * `align`: set the nesting level to the current cursor
 * position
 * * `indent`: increase the indentation on the spot, padding
 * any empty space with spaces
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 * import * as String from "effect/String"
 *
 * const doc = Doc.vsep([
 *   pipe(Doc.vsep(Doc.words("lorem ipsum dolor")), Doc.nest(4)),
 *   Doc.text("sit"),
 *   Doc.text("amet")
 * ])
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   String.stripMargin(
 *     `|lorem
 *      |    ipsum
 *      |    dolor
 *      |sit
 *      |amet`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category alignment
 */
const nest = exports.nest = internal.nest;
/**
 * The `align` combinator lays out a document with the nesting level set to the
 * current column.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * // As an example, the documents below will be placed one above the other
 * // regardless of the current nesting level
 *
 * // Without `align`ment, the second line is simply placed below everything
 * // that has been laid out so far
 * const unaligned = Doc.hsep([
 *   Doc.text("lorem"),
 *   Doc.vsep([Doc.text("ipsum"), Doc.text("dolor")])
 * ])
 *
 * assert.strictEqual(
 *   Doc.render(unaligned, { style: "pretty" }),
 *   String.stripMargin(
 *     `|lorem ipsum
 *      |dolor`
 *   )
 * )
 *
 * // With `align`ment, the `vsep`ed documents all start at the same column
 * const aligned = Doc.hsep([
 *   Doc.text("lorem"),
 *   Doc.align(Doc.vsep([Doc.text("ipsum"), Doc.text("dolor")]))
 * ])
 *
 * assert.strictEqual(
 *   Doc.render(aligned, { style: "pretty" }),
 *   String.stripMargin(
 *     `|lorem ipsum
 *      |      dolor`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category alignment
 */
const align = exports.align = internal.align;
/**
 * The `hang` combinator lays out a document with the nesting level set to
 * the *current column* plus the specified `indent`. Negative values for
 * `indent` are allowed and decrease the nesting level accordingly.
 *
 * This differs from the `nest` combinator, which is based on the *current
 * nesting level* plus the specified `indent`. When you"re not sure, try the
 * more efficient combinator (`nest`) first.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 * import * as String from "effect/String"
 *
 * const doc = Doc.hsep([
 *   Doc.text("prefix"),
 *   pipe(Doc.reflow("Indenting these words with hang"), Doc.hang(4))
 * ])
 *
 * assert.strictEqual(
 *   Doc.render(doc, {
 *     style: "pretty",
 *     options: { lineWidth: 24 }
 *   }),
 *   String.stripMargin(
 *     `|prefix Indenting these
 *      |           words with
 *      |           hang`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category alignment
 */
const hang = exports.hang = internal.hang;
/**
 * The `indent` combinator indents a document by the specified `indent`
 * beginning from the current cursor position.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 * import * as String from "effect/String"
 *
 * const doc = Doc.hcat([
 *   Doc.text("prefix"),
 *   pipe(Doc.reflow("The indent function indents these words!"), Doc.indent(4))
 * ])
 *
 * assert.strictEqual(
 *   Doc.render(doc, {
 *     style: "pretty",
 *     options: { lineWidth: 24 }
 *   }),
 *   String.stripMargin(
 *     `|prefix    The indent
 *      |          function
 *      |          indents these
 *      |          words!`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category alignment
 */
const indent = exports.indent = internal.indent;
/**
 * The `encloseSep` combinator concatenates a collection of documents,
 * separating each document in the collection using the specified `sep`
 * document. After concatenation, the resulting document is enclosed by the
 * specified `left` and `right` documents.
 *
 * To place the `sep` document at the end of each entry, see the `punctuate`
 * combinator.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 * import * as String from "effect/String"
 *
 * const doc = Doc.hsep([
 *   Doc.text("list"),
 *   Doc.align(
 *     pipe(
 *       ["1", "20", "300", "4000"].map(
 *         (n) => n.length === 1 ? Doc.char(n) : Doc.text(n)
 *       ),
 *       Doc.encloseSep(Doc.lbracket, Doc.rbracket, Doc.comma)
 *     )
 *   )
 * ])
 *
 * // The documents are laid out horizontally if the document fits the page
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   "list [1,20,300,4000]"
 * )
 *
 * // Otherwise they are laid out vertically, with separators put in the front
 * assert.strictEqual(
 *   Doc.render(doc, {
 *     style: "pretty",
 *     options: { lineWidth: 10 }
 *   }),
 *   String.stripMargin(
 *     `|list [1
 *      |     ,20
 *      |     ,300
 *      |     ,4000]`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category alignment
 */
const encloseSep = exports.encloseSep = internal.encloseSep;
/**
 * A Haskell-inspired variant of `encloseSep` that uses a comma as the separator
 * and braces as the enclosure for a collection of documents.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 *
 * const doc = Doc.list(
 *   ["1", "20", "300", "4000"].map(
 *     (n) => (n.length === 1 ? Doc.char(n) : Doc.text(n))
 *   )
 * )
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   "[1, 20, 300, 4000]"
 * )
 * ```
 *
 * @since 1.0.0
 * @category alignment
 */
const list = exports.list = internal.list;
/**
 * A Haskell-inspired variant of `encloseSep` that uses a comma as the separator
 * and parentheses as the enclosure for a collection of documents.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 *
 * const doc = Doc.tupled(
 *   ["1", "20", "300", "4000"].map(
 *     (n) => (n.length === 1 ? Doc.char(n) : Doc.text(n))
 *   )
 * )
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   "(1, 20, 300, 4000)"
 * )
 * ```
 *
 * @since 1.0.0
 * @category alignment
 */
const tupled = exports.tupled = internal.tupled;
// -----------------------------------------------------------------------------
// Filling
// -----------------------------------------------------------------------------
/**
 * The `fill` combinator first lays out the document `x` and then appends
 * `space`s until the width of the document is equal to the specified `width`.
 * If the width of `x` is already larger than the specified `width`, nothing is
 * appended.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 * import * as String from "effect/String"
 *
 * type Signature = [name: string, type: string]
 *
 * const signatures: Array<Signature> = [
 *   ["empty", "Doc"],
 *   ["nest", "Int -> Doc -> Doc"],
 *   ["fillSep", "[Doc] -> Doc"]
 * ]
 *
 * const prettySignature = <A>([name, type]: Signature): Doc.Doc<A> =>
 *   Doc.hsep([
 *     pipe(Doc.text(name), Doc.fill(5)),
 *     Doc.text("::"),
 *     Doc.text(type)
 *   ])
 *
 * const doc = Doc.hsep([
 *   Doc.text("let"),
 *   Doc.align(Doc.vcat(signatures.map(prettySignature)))
 * ])
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   String.stripMargin(
 *     `|let empty :: Doc
 *      |    nest  :: Int -> Doc -> Doc
 *      |    fillSep :: [Doc] -> Doc`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category filling
 */
const fill = exports.fill = internal.fill;
/**
 * The `fillBreak` combinator first lays out the document `x` and then appends
 * `space`s until the width of the document is equal to the specified `width`.
 * If the width of `x` is already larger than the specified `width`, the nesting
 * level is increased by the specified `width` and a `line` is appended.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 * import * as String from "effect/String"
 *
 * type Signature = [name: string, type: string]
 *
 * const signatures: Array<Signature> = [
 *   ["empty", "Doc"],
 *   ["nest", "Int -> Doc -> Doc"],
 *   ["fillSep", "[Doc] -> Doc"]
 * ]
 *
 * const prettySignature = <A>([name, type]: Signature): Doc.Doc<A> =>
 *   Doc.hsep([
 *     pipe(Doc.text(name), Doc.fillBreak(5)),
 *     Doc.text("::"),
 *     Doc.text(type)
 *   ])
 *
 * const doc = Doc.hsep([
 *   Doc.text("let"),
 *   Doc.align(Doc.vcat(signatures.map(prettySignature)))
 * ])
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   String.stripMargin(
 *     `|let empty :: Doc
 *      |    nest  :: Int -> Doc -> Doc
 *      |    fillSep
 *      |          :: [Doc] -> Doc`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category filling
 */
const fillBreak = exports.fillBreak = internal.fillBreak;
// -----------------------------------------------------------------------------
// Flattening
// -----------------------------------------------------------------------------
/**
 * Flattens a document but does not report changes.
 *
 * @since 1.0.0
 * @category flattening
 */
const flatten = exports.flatten = internal.flatten;
/**
 * Select the first element of each `Union` and discard the first element of
 * each `FlatAlt` to produce a "flattened" version of the input document.
 *
 * The result is `Flattened` if the element might change depending on the chosen
 * layout algorithm (i.e., the resulting document contains sub-documents that
 * may be rendered differently).
 *
 * The result is `AlreadyFlat` if the document is static (i.e., the resulting
 * document contains only a plain `Empty` node).
 *
 * `NeverFlat` is returned when the document cannot be flattened because it
 * contains either a hard `Line` or a `Fail`.
 *
 * @since 1.0.0
 * @category flattening
 */
const changesUponFlattening = exports.changesUponFlattening = internal.changesUponFlattening;
// -----------------------------------------------------------------------------
// Annotations
// -----------------------------------------------------------------------------
/**
 * Adds an annotation to a `Doc`. The annotation can then be used by the rendering
 * algorithm to, for example, add color to certain parts of the output.
 *
 * **Note** This function is relevant only for custom formats with their own annotations,
 * and is not relevant for basic pretty printing.
 *
 * @since 1.0.0
 * @category annotations
 */
const annotate = exports.annotate = internal.annotate;
/**
 * Change the annotations of a document. Individual annotations can be removed,
 * changed, or replaced by multiple ones.
 *
 * This is a general function that combines `unAnnotate` and `reAnnotate`, and
 * is useful for mapping semantic annotations (such as »this is a keyword«) to
 * display annotations (such as »this is red and underlined«) because some
 * backends may not care about certain annotations while others may.
 *
 * Annotations earlier in the new list will be applied earlier, so returning
 * `[Bold, Green]` will result in a bold document that contains green text, and
 * not vice versa.
 *
 * Since this traverses the entire document tree, including the parts that are
 * not rendered (due to other layouts having better fit), it is preferable to
 * reannotate a document **after** producing the layout by using
 * `alterAnnotations` from the `SimpleDocStream` module.
 *
 * @since 1.0.0
 * @category annotations
 */
const alterAnnotations = exports.alterAnnotations = internal.alterAnnotations;
/**
 * Changes the annotation of a document. Useful for modifying documents embedded
 * with one form of annotation with a more general annotation.
 *
 * **Note** that with each invocation, the entire document tree is traversed.
 * If possible, it is preferable to reannotate a document after producing the
 * layout using `reAnnotateS`.
 *
 * @since 1.0.0
 * @category annotations
 */
const reAnnotate = exports.reAnnotate = internal.reAnnotate;
/**
 * Removes all annotations from a document.
 *
 * **Note**: with each invocation, the entire document tree is traversed.
 * If possible, it is preferable to unannotate a document after producing the
 * layout using `unAnnotateS`.
 *
 * @since 1.0.0
 * @category annotations
 */
const unAnnotate = exports.unAnnotate = internal.unAnnotate;
// -----------------------------------------------------------------------------
// Folding
// -----------------------------------------------------------------------------
/**
 * @since 1.0.0
 * @category folding
 */
const match = exports.match = internal.match;
// -----------------------------------------------------------------------------
// Instances
// -----------------------------------------------------------------------------
/**
 * @since 1.0.0
 * @category rendering
 */
const render = exports.render = InternalRender.render;
/**
 * @since 1.0.0
 * @category rendering
 */
const renderStream = exports.renderStream = InternalRender.renderStream;
// -----------------------------------------------------------------------------
// Instances
// -----------------------------------------------------------------------------
/**
 * @since 1.0.0
 * @category combinators
 */
const map = exports.map = internal.map;
/**
 * @since 1.0.0
 * @category instances
 */
const getSemigroup = exports.getSemigroup = internal.getSemigroup;
/**
 * @since 1.0.0
 * @category instances
 */
const getMonoid = exports.getMonoid = internal.getMonoid;
/**
 * @since 1.0.0
 * @category instances
 */
const Covariant = exports.Covariant = internal.Covariant;
/**
 * @since 1.0.0
 * @category instances
 */
const Invariant = exports.Invariant = internal.Invariant;
// -----------------------------------------------------------------------------
// Utilities
// -----------------------------------------------------------------------------
/**
 * The `surround` combinator encloses a document in between `left` and `right`
 * documents.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 *
 * const doc = pipe(
 *   Doc.char("-"),
 *   Doc.surround(Doc.char("A"), Doc.char("Z"))
 * )
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   "A-Z"
 * )
 * ```
 *
 * @since 1.0.0
 * @category utilities
 */
const surround = exports.surround = internal.surround;
/**
 * Encloses the input document in single quotes (`""`).
 *
 * @since 1.0.0
 * @category utilities
 */
const singleQuoted = exports.singleQuoted = internal.singleQuoted;
/**
 * Encloses the input document in double quotes (`""`).
 *
 * @since 1.0.0
 * @category utilities
 */
const doubleQuoted = exports.doubleQuoted = internal.doubleQuoted;
/**
 * Encloses the input document in parentheses (`()`).
 *
 * @since 1.0.0
 * @category utilities
 */
const parenthesized = exports.parenthesized = internal.parenthesized;
/**
 * Encloses the input document in angle brackets (`<>`).
 *
 * @since 1.0.0
 * @category utilities
 */
const angleBracketed = exports.angleBracketed = internal.angleBracketed;
/**
 * Encloses the input document in square brackets (`[]`).
 *
 * @since 1.0.0
 * @category utilities
 */
const squareBracketed = exports.squareBracketed = internal.squareBracketed;
/**
 * Encloses the input document in curly braces (`{}`).
 *
 * @since 1.0.0
 * @category utilities
 */
const curlyBraced = exports.curlyBraced = internal.curlyBraced;
/**
 * The `spaces` combinator lays out a document containing `n` spaces. Negative
 * values for `n` count as `0` spaces.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 *
 * const doc = Doc.squareBracketed(Doc.doubleQuoted(Doc.spaces(5)))
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   "[\"     \"]"
 * )
 * ```
 *
 * @since 1.0.0
 * @category utilities
 */
const spaces = exports.spaces = internal.spaces;
/**
 * @since 1.0.0
 * @category utilities
 */
const textSpaces = exports.textSpaces = internal.textSpaces;
/**
 * Splits a string of words into individual `Text` documents using the
 * specified `char` to split on (defaults to `" "`).
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 *
 * const doc = Doc.tupled(Doc.words("lorem ipsum dolor"))
 *
 * assert.strictEqual(
 *   Doc.render(doc, { style: "pretty" }),
 *   "(lorem, ipsum, dolor)"
 * )
 * ```
 *
 * @since 1.0.0
 * @category utilities
 */
const words = exports.words = internal.words;
/**
 * Splits a string of words into individual `Text` documents using the specified
 * `char` to split on (defaults to `" "`). In addition, a `softLine` is inserted
 * in between each word so that if the text exceeds the available width it will
 * be broken into multiple lines.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import * as String from "effect/String"
 *
 * const doc = Doc.reflow(
 *   "Lorem ipsum dolor sit amet, consectetur adipisicing elit, " +
 *     "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
 * )
 *
 * assert.strictEqual(
 *   Doc.render(doc, {
 *     style: "pretty",
 *     options: { lineWidth: 32 }
 *   }),
 *   String.stripMargin(
 *     `|Lorem ipsum dolor sit amet,
 *      |consectetur adipisicing elit,
 *      |sed do eiusmod tempor incididunt
 *      |ut labore et dolore magna
 *      |aliqua.`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category utilities
 */
const reflow = exports.reflow = internal.reflow;
/**
 * The `punctuate` combinator appends the `punctuator` document to all but the
 * last document in a collection of documents. The separators are places after
 * the document entries, which can be observed if the result is oriented
 * vertically.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Doc from "@effect/printer/Doc"
 * import { pipe } from "effect/Function"
 * import * as String from "effect/String"
 *
 * const docs = pipe(
 *   Doc.words("lorem ipsum dolor sit amet"),
 *   Doc.punctuate(Doc.comma)
 * )
 *
 * assert.strictEqual(
 *   Doc.render(Doc.hsep(docs), { style: "pretty" }),
 *   "lorem, ipsum, dolor, sit, amet"
 * )
 *
 * // The separators are put at the end of the entries, which can be better
 * // visualzied if the documents are rendered vertically
 * assert.strictEqual(
 *   Doc.render(Doc.vsep(docs), { style: "pretty" }),
 *   String.stripMargin(
 *     `|lorem,
 *      |ipsum,
 *      |dolor,
 *      |sit,
 *      |amet`
 *   )
 * )
 * ```
 *
 * @since 1.0.0
 * @category utilities
 */
const punctuate = exports.punctuate = internal.punctuate;
//# sourceMappingURL=Doc.js.map