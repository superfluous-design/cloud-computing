"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unAnnotate = exports.treeForm = exports.text = exports.renderSimplyDecorated = exports.reAnnotate = exports.parser = exports.map = exports.line = exports.isTextTree = exports.isLineTree = exports.isEmptyTree = exports.isDocTree = exports.isConcatTree = exports.isCharTree = exports.isAnnotationTree = exports.getSemigroup = exports.getMonoid = exports.foldMap = exports.empty = exports.concat = exports.char = exports.annotation = exports.alterAnnotations = exports.Invariant = exports.DocTreeTypeId = exports.Covariant = void 0;
var covariant = _interopRequireWildcard(require("@effect/typeclass/Covariant"));
var Arr = _interopRequireWildcard(require("effect/Array"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Equal = _interopRequireWildcard(require("effect/Equal"));
var _Function = require("effect/Function");
var Hash = _interopRequireWildcard(require("effect/Hash"));
var Option = _interopRequireWildcard(require("effect/Option"));
var doc = _interopRequireWildcard(require("./doc.js"));
var docTreeToken = _interopRequireWildcard(require("./docTreeToken.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
// -----------------------------------------------------------------------------
// Models
// -----------------------------------------------------------------------------
const DocTreeSymbolKey = "@effect/printer/DocTree";
/** @internal */
const DocTreeTypeId = exports.DocTreeTypeId = /*#__PURE__*/Symbol.for(DocTreeSymbolKey);
const protoHash = {
  EmptyTree: _ => (0, _Function.pipe)(Hash.string("@effect/printer/DocTree/EmptyTree"), Hash.combine(Hash.string(DocTreeSymbolKey))),
  CharTree: self => (0, _Function.pipe)(Hash.string("@effect/printer/DocTree/CharTree"), Hash.combine(Hash.string(DocTreeSymbolKey)), Hash.combine(Hash.string(self.char))),
  TextTree: self => (0, _Function.pipe)(Hash.string("@effect/printer/DocTree/TextTree"), Hash.combine(Hash.string(DocTreeSymbolKey)), Hash.combine(Hash.string(self.text))),
  LineTree: self => (0, _Function.pipe)(Hash.string("@effect/printer/DocTree/LineTree"), Hash.combine(Hash.string(DocTreeSymbolKey)), Hash.combine(Hash.number(self.indentation))),
  AnnotationTree: self => (0, _Function.pipe)(Hash.string("@effect/printer/DocTree/AnnotationTree"), Hash.combine(Hash.string(DocTreeSymbolKey)), Hash.combine(Hash.hash(self.annotation)), Hash.combine(Hash.hash(self.tree))),
  ConcatTree: self => (0, _Function.pipe)(Hash.string("@effect/printer/DocTree/ConcatTree"), Hash.combine(Hash.string(DocTreeSymbolKey)), Hash.combine(Hash.hash(self.trees)))
};
const protoEqual = {
  EmptyTree: (_, that) => isDocTree(that) && that._tag === "EmptyTree",
  CharTree: (self, that) => isDocTree(that) && that._tag === "CharTree" && self.char === that.char,
  TextTree: (self, that) => isDocTree(that) && that._tag === "TextTree" && self.text === that.text,
  LineTree: (self, that) => isDocTree(that) && that._tag === "LineTree" && self.indentation === that.indentation,
  AnnotationTree: (self, that) => isDocTree(that) && that._tag === "AnnotationTree" && Equal.equals(self.annotation, that.annotation) && Equal.equals(self.tree, that.tree),
  ConcatTree: (self, that) => isDocTree(that) && that._tag === "ConcatTree" && Equal.equals(self.trees, that.trees)
};
const proto = {
  [DocTreeTypeId]: {
    _A: _ => _
  },
  [Hash.symbol]() {
    return Hash.cached(this, protoHash[this._tag](this));
  },
  [Equal.symbol](that) {
    return protoEqual[this._tag](this, that);
  }
};
// -----------------------------------------------------------------------------
// Refinements
// -----------------------------------------------------------------------------
/** @internal */
const isDocTree = u => typeof u === "object" && u != null && DocTreeTypeId in u;
/** @internal */
exports.isDocTree = isDocTree;
const isEmptyTree = self => self._tag === "EmptyTree";
/** @internal */
exports.isEmptyTree = isEmptyTree;
const isCharTree = self => self._tag === "CharTree";
/** @internal */
exports.isCharTree = isCharTree;
const isTextTree = self => self._tag === "TextTree";
/** @internal */
exports.isTextTree = isTextTree;
const isLineTree = self => self._tag === "LineTree";
/** @internal */
exports.isLineTree = isLineTree;
const isAnnotationTree = self => self._tag === "AnnotationTree";
/** @internal */
exports.isAnnotationTree = isAnnotationTree;
const isConcatTree = self => self._tag === "ConcatTree";
// -----------------------------------------------------------------------------
// Constructors
// -----------------------------------------------------------------------------
/** @internal */
exports.isConcatTree = isConcatTree;
const empty = exports.empty = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "EmptyTree";
  return op;
})();
/** @internal */
const char = char => {
  const op = Object.create(proto);
  op._tag = "CharTree";
  op.char = char;
  return op;
};
/** @internal */
exports.char = char;
const text = text => {
  const op = Object.create(proto);
  op._tag = "TextTree";
  op.text = text;
  return op;
};
/** @internal */
exports.text = text;
const line = indentation => {
  const op = Object.create(proto);
  op._tag = "LineTree";
  op.indentation = indentation;
  return op;
};
/** @internal */
exports.line = line;
const annotation = exports.annotation = /*#__PURE__*/(0, _Function.dual)(2, (self, annotation) => {
  const op = Object.create(proto);
  op._tag = "AnnotationTree";
  op.annotation = annotation;
  op.tree = self;
  return op;
});
/** @internal */
const concat = trees => {
  const op = Object.create(proto);
  op._tag = "ConcatTree";
  op.trees = trees;
  return op;
};
// -----------------------------------------------------------------------------
// Annotations
// -----------------------------------------------------------------------------
/** @internal */
exports.concat = concat;
const alterAnnotations = exports.alterAnnotations = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => Effect.runSync(alterAnnotationsSafe(self, f)));
const alterAnnotationsSafe = (self, f) => {
  switch (self._tag) {
    case "EmptyTree":
      {
        return Effect.succeed(empty);
      }
    case "CharTree":
      {
        return Effect.succeed(char(self.char));
      }
    case "TextTree":
      {
        return Effect.succeed(text(self.text));
      }
    case "LineTree":
      {
        return Effect.succeed(line(self.indentation));
      }
    case "AnnotationTree":
      {
        return Arr.reduce(Arr.fromIterable(f(self.annotation)), Effect.suspend(() => alterAnnotationsSafe(self.tree, f)), (acc, b) => Effect.map(acc, annotation(b)));
      }
    case "ConcatTree":
      {
        return (0, _Function.pipe)(Effect.forEach(self.trees, tree => alterAnnotationsSafe(tree, f)), Effect.map(concat));
      }
  }
};
/** @internal */
const reAnnotate = exports.reAnnotate = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => alterAnnotations(self, a => [f(a)]));
/** @internal */
const unAnnotate = self => alterAnnotations(self, () => []);
// -----------------------------------------------------------------------------
// Folding
// -----------------------------------------------------------------------------
/** @internal */
exports.unAnnotate = unAnnotate;
const foldMap = exports.foldMap = /*#__PURE__*/(0, _Function.dual)(3, (self, M, f) => Effect.runSync(foldMapSafe(self, M, f)));
const foldMapSafe = (self, M, f) => {
  switch (self._tag) {
    case "EmptyTree":
    case "CharTree":
    case "TextTree":
    case "LineTree":
      {
        return Effect.succeed(M.empty);
      }
    case "AnnotationTree":
      {
        return Effect.map(Effect.suspend(() => foldMapSafe(self.tree, M, f)), that => M.combine(f(self.annotation), that));
      }
    case "ConcatTree":
      {
        if (Arr.isEmptyReadonlyArray(self.trees)) {
          return Effect.succeed(M.empty);
        }
        return Effect.map(Effect.forEach(self.trees, tree => foldMapSafe(tree, M, f)), trees => {
          const head = trees[0];
          const tail = trees.slice(1);
          return Arr.reduce(tail, head, M.combine);
        });
      }
  }
};
// -----------------------------------------------------------------------------
// Rendering
// -----------------------------------------------------------------------------
/** @internal */
const renderSimplyDecorated = exports.renderSimplyDecorated = /*#__PURE__*/(0, _Function.dual)(4, (self, M, renderText, renderAnnotation) => Effect.runSync(renderSimplyDecoratedSafe(self, M, renderText, renderAnnotation)));
const renderSimplyDecoratedSafe = (self, M, renderText, renderAnnotation) => {
  switch (self._tag) {
    case "EmptyTree":
      {
        return Effect.succeed(M.empty);
      }
    case "CharTree":
      {
        return Effect.succeed(renderText(self.char));
      }
    case "TextTree":
      {
        return Effect.succeed(renderText(self.text));
      }
    case "LineTree":
      {
        return Effect.succeed(M.combine(renderText("\n"), renderText(doc.textSpaces(self.indentation))));
      }
    case "AnnotationTree":
      {
        return Effect.map(Effect.suspend(() => renderSimplyDecoratedSafe(self.tree, M, renderText, renderAnnotation)), out => renderAnnotation(self.annotation, out));
      }
    case "ConcatTree":
      {
        if (Arr.isEmptyReadonlyArray(self.trees)) {
          return Effect.succeed(M.empty);
        }
        const head = self.trees[0];
        const tail = self.trees.slice(1);
        return Arr.reduce(tail, Effect.suspend(() => renderSimplyDecoratedSafe(head, M, renderText, renderAnnotation)), (acc, tree) => Effect.zipWith(acc, Effect.suspend(() => renderSimplyDecoratedSafe(tree, M, renderText, renderAnnotation)), M.combine));
      }
  }
};
// -----------------------------------------------------------------------------
// Conversions
// -----------------------------------------------------------------------------
/** @internal */
const treeForm = stream => {
  const result = parser()(stream);
  switch (result._tag) {
    case "None":
      {
        throw new Error("BUG: DocTree.treeForm - failed to convert DocStream to DocTree" + " - please report an issue at https://github.com/Effect-TS/printer/issues");
      }
    case "Some":
      {
        const [docTree, remaining] = result.value;
        if (remaining._tag !== "EmptyStream") {
          throw new Error("BUG: DocTree.treeForm - DocStream not fully consumed during DocTree parsing" + " - please report an issue at https://github.com/Effect-TS/printer/issues");
        }
        return docTree;
      }
  }
};
exports.treeForm = treeForm;
const parserSucceed = value => stream => Option.some([value, stream]);
const parserMap = (self, f) => stream => Option.map(self(stream), ([a, s]) => [f(a), s]);
const parserFlatMap = (self, f) => stream => Option.flatMap(self(stream), ([a, s1]) => f(a)(s1));
function many(parser) {
  return stream => (0, _Function.pipe)(parser(stream), Option.map(([head, next]) => {
    const output = [head];
    let input = next;
    let result = parser(next);
    while (result._tag === "Some") {
      const [value, nextInput] = result.value;
      output.push(value);
      input = nextInput;
      result = parser(nextInput);
    }
    return [output, input];
  }));
}
const nextToken = () => {
  return stream => {
    switch (stream._tag) {
      case "FailedStream":
        {
          throw new Error("BUG: DocTree.treeForm - found failed doc stream while parsing" + " - please report an issue at https://github.com/Effect-TS/printer/issues");
        }
      case "EmptyStream":
        {
          return Option.none();
        }
      case "CharStream":
        {
          return Option.some([docTreeToken.char(stream.char), stream.stream]);
        }
      case "TextStream":
        {
          return Option.some([docTreeToken.text(stream.text), stream.stream]);
        }
      case "LineStream":
        {
          return Option.some([docTreeToken.line(stream.indentation), stream.stream]);
        }
      case "PushAnnotationStream":
        {
          return Option.some([docTreeToken.pushAnnotation(stream.annotation), stream.stream]);
        }
      case "PopAnnotationStream":
        {
          return Option.some([docTreeToken.popAnnotation, stream.stream]);
        }
    }
  };
};
const mergeTrees = trees => {
  if (trees.length === 0) {
    return empty;
  }
  const head = trees[0];
  const tail = trees.slice(1);
  return tail.length === 0 ? head : concat(trees);
};
const tree = parser => {
  return parserFlatMap(nextToken(), token => {
    switch (token._tag) {
      case "EmptyToken":
        {
          return parserSucceed(empty);
        }
      case "CharToken":
        {
          return parserSucceed(char(token.char));
        }
      case "TextToken":
        {
          return parserSucceed(text(token.text));
        }
      case "LineToken":
        {
          return parserSucceed(line(token.indentation));
        }
      case "PushAnnotationToken":
        {
          return parserFlatMap(parser(), annotatedContents =>
          // Make sure to handle the subsequent pop annotation token
          parserMap(nextToken(), () => annotation(annotatedContents, token.annotation)));
        }
      case "PopAnnotationToken":
        {
          return () => Option.none();
        }
    }
  });
};
/** @internal */
const parser = () => parserMap(many(tree(() => parser())), mergeTrees);
// -----------------------------------------------------------------------------
// Instances
// -----------------------------------------------------------------------------
exports.parser = parser;
const map = exports.map = reAnnotate;
const imap = /*#__PURE__*/covariant.imap(map);
/** @internal */
const getSemigroup = _ => {
  return {
    combine: (self, that) => concat(Arr.make(self, that)),
    combineMany: (self, trees) => concat(Arr.fromIterable([self, ...trees]))
  };
};
/** @internal */
exports.getSemigroup = getSemigroup;
const getMonoid = _ => {
  return {
    empty,
    combine: (self, that) => concat(Arr.make(self, that)),
    combineMany: (self, trees) => concat(Arr.fromIterable([self, ...trees])),
    combineAll: trees => concat(Arr.fromIterable(trees))
  };
};
/** @internal */
exports.getMonoid = getMonoid;
const Covariant = exports.Covariant = {
  map,
  imap
};
const Invariant = exports.Invariant = {
  imap
};
//# sourceMappingURL=docTree.js.map