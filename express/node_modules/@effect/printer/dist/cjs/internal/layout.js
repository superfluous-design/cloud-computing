"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wadlerLeijen = exports.unbounded = exports.smart = exports.pretty = exports.options = exports.defaultOptions = exports.compact = void 0;
var Effect = _interopRequireWildcard(require("effect/Effect"));
var _Function = require("effect/Function");
var List = _interopRequireWildcard(require("effect/List"));
var Option = _interopRequireWildcard(require("effect/Option"));
var InternalDocStream = _interopRequireWildcard(require("./docStream.js"));
var InternalPipeline = _interopRequireWildcard(require("./layoutPipeline.js"));
var InternalPageWidth = _interopRequireWildcard(require("./pageWidth.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/** @internal */
const options = pageWidth => ({
  pageWidth
});
/** @internal */
exports.options = options;
const defaultOptions = exports.defaultOptions = /*#__PURE__*/options(InternalPageWidth.defaultPageWidth);
// -----------------------------------------------------------------------------
// wadlerLeijen
// -----------------------------------------------------------------------------
/** @internal */
const wadlerLeijen = exports.wadlerLeijen = /*#__PURE__*/(0, _Function.dual)(3, (self, fits, options) => Effect.runSync(wadlerLeijenSafe(InternalPipeline.cons(0, self, InternalPipeline.nil), 0, 0, fits, options)));
const wadlerLeijenSafe = (self, nestingLevel, currentColumn, fits, options) => {
  const best = (self, nl, cc) => Effect.gen(function* () {
    switch (self._tag) {
      case "Nil":
        {
          return InternalDocStream.empty;
        }
      case "Cons":
        {
          switch (self.document._tag) {
            case "Fail":
              {
                return InternalDocStream.failed;
              }
            case "Empty":
              {
                return yield* best(self.pipeline, nl, cc);
              }
            case "Char":
              {
                const stream = yield* best(self.pipeline, nl, cc + 1);
                return InternalDocStream.char(stream, self.document.char);
              }
            case "Text":
              {
                const length = self.document.text.length;
                const stream = yield* best(self.pipeline, nl, cc + length);
                return InternalDocStream.text(stream, self.document.text);
              }
            case "Line":
              {
                const stream = yield* best(self.pipeline, self.indent, self.indent);
                // Do not produce indentation if there is no subsequent text on
                // the same line (prevents trailing whitespace)
                const nextIndent = InternalDocStream.isEmptyStream(stream) || InternalDocStream.isLineStream(stream) ? 0 : self.indent;
                return InternalDocStream.line(stream, nextIndent);
              }
            case "FlatAlt":
              {
                const next = InternalPipeline.cons(self.indent, self.document.left, self.pipeline);
                return yield* best(next, nl, cc);
              }
            case "Cat":
              {
                const inner = InternalPipeline.cons(self.indent, self.document.right, self.pipeline);
                const outer = InternalPipeline.cons(self.indent, self.document.left, inner);
                return yield* best(outer, nl, cc);
              }
            case "Nest":
              {
                const indent = self.indent + self.document.indent;
                const next = InternalPipeline.cons(indent, self.document.doc, self.pipeline);
                return yield* best(next, nl, cc);
              }
            case "Union":
              {
                const leftPipeline = InternalPipeline.cons(self.indent, self.document.left, self.pipeline);
                const rightPipeline = InternalPipeline.cons(self.indent, self.document.right, self.pipeline);
                const left = best(leftPipeline, nl, cc);
                const right = best(rightPipeline, nl, cc);
                return selectNicer(fits, nl, cc, left, right);
              }
            case "Column":
              {
                const doc = self.document.react(cc);
                const next = InternalPipeline.cons(self.indent, doc, self.pipeline);
                return yield* best(next, nl, cc);
              }
            case "WithPageWidth":
              {
                const doc = self.document.react(options.pageWidth);
                const next = InternalPipeline.cons(self.indent, doc, self.pipeline);
                return yield* best(next, nl, cc);
              }
            case "Nesting":
              {
                const doc = self.document.react(self.indent);
                const next = InternalPipeline.cons(self.indent, doc, self.pipeline);
                return yield* best(next, nl, cc);
              }
            case "Annotated":
              {
                const undo = InternalPipeline.undoAnnotation(self.pipeline);
                const next = InternalPipeline.cons(self.indent, self.document.doc, undo);
                const stream = yield* best(next, nl, cc);
                return InternalDocStream.pushAnnotation(stream, self.document.annotation);
              }
          }
        }
      case "UndoAnnotation":
        {
          const stream = yield* best(self.pipeline, nestingLevel, currentColumn);
          return InternalDocStream.popAnnotation(stream);
        }
    }
  });
  return best(self, nestingLevel, currentColumn);
};
const selectNicer = (fits, lineIndent, currentColumn, left, right) => {
  const leftStream = Effect.runSync(left);
  let rightStream = undefined;
  return fits(leftStream, lineIndent, currentColumn, () => rightStream ?? (rightStream = Effect.runSync(right), rightStream)) ? leftStream : rightStream ?? Effect.runSync(right);
};
// -----------------------------------------------------------------------------
// compact
// -----------------------------------------------------------------------------
/** @internal */
const compact = self => Effect.runSync(compactSafe(List.of(self), 0));
exports.compact = compact;
const compactSafe = (docs, i) => Effect.gen(function* () {
  if (List.isNil(docs)) {
    return InternalDocStream.empty;
  }
  const head = docs.head;
  const tail = docs.tail;
  switch (head._tag) {
    case "Fail":
      {
        return InternalDocStream.failed;
      }
    case "Empty":
      {
        return yield* compactSafe(tail, i);
      }
    case "Char":
      {
        const stream = yield* compactSafe(tail, i + 1);
        return InternalDocStream.char(stream, head.char);
      }
    case "Text":
      {
        const stream = yield* compactSafe(tail, i + head.text.length);
        return InternalDocStream.text(stream, head.text);
      }
    case "Line":
      {
        const stream = yield* compactSafe(tail, 0);
        return InternalDocStream.line(stream, 0);
      }
    case "FlatAlt":
      {
        return yield* compactSafe(List.cons(head.left, tail), i);
      }
    case "Cat":
      {
        const list = List.cons(head.left, List.cons(head.right, tail));
        return yield* compactSafe(list, i);
      }
    case "Nest":
      {
        return yield* compactSafe(List.cons(head.doc, tail), i);
      }
    case "Union":
      {
        return yield* compactSafe(List.cons(head.right, tail), i);
      }
    case "Column":
      {
        return yield* compactSafe(List.cons(head.react(i), tail), i);
      }
    case "WithPageWidth":
      {
        return yield* compactSafe(List.cons(head.react(InternalPageWidth.unbounded), tail), i);
      }
    case "Nesting":
      {
        return yield* compactSafe(List.cons(head.react(0), tail), i);
      }
    case "Annotated":
      {
        return yield* compactSafe(List.cons(head.doc, tail), i);
      }
  }
});
// -----------------------------------------------------------------------------
// pretty
// -----------------------------------------------------------------------------
/** @internal */
const pretty = exports.pretty = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  const width = options.pageWidth;
  if (width._tag === "AvailablePerLine") {
    return wadlerLeijen(self, (stream, indentation, currentColumn) => {
      const remainingWidth = InternalPageWidth.remainingWidth(width.lineWidth, width.ribbonFraction, indentation, currentColumn);
      return fitsPretty(stream, remainingWidth);
    }, options);
  }
  return unbounded(self);
});
const fitsPretty = (self, width) => {
  let w = width;
  let stream = self;
  while (w >= 0) {
    switch (stream._tag) {
      case "FailedStream":
        {
          return false;
        }
      case "EmptyStream":
        {
          return true;
        }
      case "CharStream":
        {
          w = w - 1;
          stream = stream.stream;
          break;
        }
      case "TextStream":
        {
          w = w - stream.text.length;
          stream = stream.stream;
          break;
        }
      case "LineStream":
        {
          return true;
        }
      case "PushAnnotationStream":
        {
          stream = stream.stream;
          break;
        }
      case "PopAnnotationStream":
        {
          stream = stream.stream;
          break;
        }
    }
  }
  return false;
};
// -----------------------------------------------------------------------------
// smart
// -----------------------------------------------------------------------------
/** @internal */
const smart = exports.smart = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  const width = options.pageWidth;
  if (width._tag === "AvailablePerLine") {
    return wadlerLeijen(self, fitsSmart(width.lineWidth, width.ribbonFraction), options);
  }
  return unbounded(self);
});
const fitsSmart = (pageWidth, ribbonFraction) => {
  return (stream, indentation, currentColumn, comparator) => {
    const availableWidth = InternalPageWidth.remainingWidth(pageWidth, ribbonFraction, indentation, currentColumn);
    return fitsSmartLoop(stream, comparator, pageWidth, currentColumn, availableWidth);
  };
};
const fitsSmartLoop = (self, comparator, pageWidth, currentColumn, availableWidth) => {
  let minNestingLevel;
  let stream = self;
  let w = availableWidth;
  while (w >= 0) {
    switch (stream._tag) {
      case "FailedStream":
        {
          return false;
        }
      case "EmptyStream":
        {
          return true;
        }
      case "CharStream":
        {
          w = w - 1;
          stream = stream.stream;
          break;
        }
      case "TextStream":
        {
          w = w - stream.text.length;
          stream = stream.stream;
          break;
        }
      case "LineStream":
        {
          if (!minNestingLevel) {
            minNestingLevel = Option.match(getInitialIndentation(comparator()), {
              // Definitely not a hanging layout. Return the same `minNestingLevel` that
              // subsequent lines with the same indentation use
              onNone: () => currentColumn,
              // Could be a (less wide) hanging layout, so take the minimum of the indent
              // and the current column
              onSome: value => Math.min(value, currentColumn)
            });
          }
          if (minNestingLevel < stream.indentation) {
            return false;
          }
          w = pageWidth - stream.indentation;
          stream = stream.stream;
          break;
        }
      case "PushAnnotationStream":
        {
          stream = stream.stream;
          break;
        }
      case "PopAnnotationStream":
        {
          stream = stream.stream;
          break;
        }
    }
  }
  return false;
};
const getInitialIndentation = self => {
  let stream = self;
  while (stream._tag === "LineStream" || stream._tag === "PushAnnotationStream" || stream._tag === "PopAnnotationStream") {
    if (stream._tag === "LineStream") {
      return Option.some(stream.indentation);
    }
    stream = stream.stream;
  }
  return Option.none();
};
// -----------------------------------------------------------------------------
// unbounded
// -----------------------------------------------------------------------------
/** @internal */
const unbounded = self => wadlerLeijen(self, stream => !failsOnFirstLine(stream), {
  pageWidth: InternalPageWidth.unbounded
});
exports.unbounded = unbounded;
const failsOnFirstLine = self => {
  let stream = self;
  // eslint-disable-next-line no-constant-condition
  while (1) {
    switch (stream._tag) {
      case "FailedStream":
        {
          return true;
        }
      case "EmptyStream":
        {
          return false;
        }
      case "CharStream":
        {
          stream = stream.stream;
          break;
        }
      case "TextStream":
        {
          stream = stream.stream;
          break;
        }
      case "LineStream":
        {
          return false;
        }
      case "PushAnnotationStream":
        {
          stream = stream.stream;
          break;
        }
      case "PopAnnotationStream":
        {
          stream = stream.stream;
          break;
        }
    }
  }
  throw new Error("bug");
};
//# sourceMappingURL=layout.js.map