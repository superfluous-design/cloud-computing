"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unAnnotate = exports.text = exports.reAnnotate = exports.pushAnnotation = exports.popAnnotation = exports.match = exports.map = exports.line = exports.isTextStream = exports.isPushAnnotationStream = exports.isPopAnnotationStream = exports.isLineStream = exports.isFailedStream = exports.isEmptyStream = exports.isDocStream = exports.isCharStream = exports.imap = exports.foldMap = exports.failed = exports.empty = exports.char = exports.alterAnnotations = exports.Invariant = exports.DocStreamTypeId = exports.Covariant = void 0;
var covariant = _interopRequireWildcard(require("@effect/typeclass/Covariant"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Equal = _interopRequireWildcard(require("effect/Equal"));
var _Function = require("effect/Function");
var Hash = _interopRequireWildcard(require("effect/Hash"));
var List = _interopRequireWildcard(require("effect/List"));
var Option = _interopRequireWildcard(require("effect/Option"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
// -----------------------------------------------------------------------------
// Models
// -----------------------------------------------------------------------------
const DocStreamSymbolKey = "@effect/printer/DocStream";
/** @internal */
const DocStreamTypeId = exports.DocStreamTypeId = /*#__PURE__*/Symbol.for(DocStreamSymbolKey);
const protoHash = {
  FailedStream: _ => (0, _Function.pipe)(Hash.string("@effect/printer/DocStream/FailedStream"), Hash.combine(Hash.string(DocStreamSymbolKey))),
  EmptyStream: _ => (0, _Function.pipe)(Hash.string("@effect/printer/DocStream/EmptyStream"), Hash.combine(Hash.string(DocStreamSymbolKey))),
  CharStream: self => (0, _Function.pipe)(Hash.hash("@effect/printer/DocStream/CharStream"), Hash.combine(Hash.string(DocStreamSymbolKey)), Hash.combine(Hash.string(self.char)), Hash.combine(Hash.hash(self.stream))),
  TextStream: self => (0, _Function.pipe)(Hash.string("@effect/printer/DocStream/TextStream"), Hash.combine(Hash.string(DocStreamSymbolKey)), Hash.combine(Hash.string(self.text)), Hash.combine(Hash.hash(self.stream))),
  LineStream: self => (0, _Function.pipe)(Hash.string("@effect/printer/DocStream/LineStream"), Hash.combine(Hash.string(DocStreamSymbolKey)), Hash.combine(Hash.hash(self.stream))),
  PushAnnotationStream: self => (0, _Function.pipe)(Hash.string("@effect/printer/DocStream/PopAnnotationStream"), Hash.combine(Hash.string(DocStreamSymbolKey)), Hash.combine(Hash.hash(self.annotation)), Hash.combine(Hash.hash(self.stream))),
  PopAnnotationStream: self => (0, _Function.pipe)(Hash.string("@effect/printer/DocStream/PopAnnotationStream"), Hash.combine(Hash.string(DocStreamSymbolKey)), Hash.combine(Hash.hash(self.stream)))
};
const protoEqual = {
  FailedStream: (self, that) => isDocStream(that) && that._tag === "FailedStream",
  EmptyStream: (self, that) => isDocStream(that) && that._tag === "EmptyStream",
  CharStream: (self, that) => isDocStream(that) && that._tag === "CharStream" && self.char === that.char && Equal.equals(self.stream, that.stream),
  TextStream: (self, that) => isDocStream(that) && that._tag === "TextStream" && self.text === that.text && Equal.equals(self.stream, that.stream),
  LineStream: (self, that) => isDocStream(that) && that._tag === "LineStream" && Equal.equals(self.stream, that.stream),
  PushAnnotationStream: (self, that) => isDocStream(that) && that._tag === "PushAnnotationStream" && Equal.equals(self.annotation, that.annotation) && Equal.equals(self.stream, that.stream),
  PopAnnotationStream: (self, that) => isDocStream(that) && that._tag === "PopAnnotationStream" && Equal.equals(self.stream, that.stream)
};
const proto = {
  [DocStreamTypeId]: {
    _A: _ => _
  },
  [Hash.symbol]() {
    return Hash.cached(this, protoHash[this._tag](this));
  },
  [Equal.symbol](that) {
    return protoEqual[this._tag](this, that);
  }
};
// -----------------------------------------------------------------------------
// Refinements
// -----------------------------------------------------------------------------
/** @internal */
const isDocStream = u => typeof u === "object" && u != null && DocStreamTypeId in u;
/** @internal */
exports.isDocStream = isDocStream;
const isFailedStream = self => self._tag === "FailedStream";
/** @internal */
exports.isFailedStream = isFailedStream;
const isEmptyStream = self => self._tag === "EmptyStream";
/** @internal */
exports.isEmptyStream = isEmptyStream;
const isCharStream = self => self._tag === "CharStream";
/** @internal */
exports.isCharStream = isCharStream;
const isTextStream = self => self._tag === "TextStream";
/** @internal */
exports.isTextStream = isTextStream;
const isLineStream = self => self._tag === "LineStream";
/** @internal */
exports.isLineStream = isLineStream;
const isPushAnnotationStream = self => self._tag === "PushAnnotationStream";
/** @internal */
exports.isPushAnnotationStream = isPushAnnotationStream;
const isPopAnnotationStream = self => self._tag === "PopAnnotationStream";
// -----------------------------------------------------------------------------
// Constructors
// -----------------------------------------------------------------------------
/** @internal */
exports.isPopAnnotationStream = isPopAnnotationStream;
const failed = exports.failed = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "FailedStream";
  return op;
})();
/** @internal */
const empty = exports.empty = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "EmptyStream";
  return op;
})();
/** @internal */
const char = exports.char = /*#__PURE__*/(0, _Function.dual)(2, (self, char) => {
  const op = Object.create(proto);
  op._tag = "CharStream";
  op.char = char;
  op.stream = self;
  return op;
});
/** @internal */
const text = exports.text = /*#__PURE__*/(0, _Function.dual)(2, (self, text) => {
  const op = Object.create(proto);
  op._tag = "TextStream";
  op.text = text;
  op.stream = self;
  return op;
});
/** @internal */
const line = exports.line = /*#__PURE__*/(0, _Function.dual)(2, (self, indentation) => {
  const op = Object.create(proto);
  op._tag = "LineStream";
  op.indentation = indentation;
  op.stream = self;
  return op;
});
/** @internal */
const pushAnnotation = exports.pushAnnotation = /*#__PURE__*/(0, _Function.dual)(2, (self, annotation) => {
  const op = Object.create(proto);
  op._tag = "PushAnnotationStream";
  op.annotation = annotation;
  op.stream = self;
  return op;
});
/** @internal */
const popAnnotation = stream => {
  const op = Object.create(proto);
  op._tag = "PopAnnotationStream";
  op.stream = stream;
  return op;
};
exports.popAnnotation = popAnnotation;
const Remove = "Remove";
const DontRemove = "DontRemove";
/** @internal */
const alterAnnotations = exports.alterAnnotations = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => Effect.runSync(alterAnnotationSafe(self, f, List.nil())));
const alterAnnotationSafe = (self, f, stack) => {
  switch (self._tag) {
    case "CharStream":
      {
        return Effect.map(Effect.suspend(() => alterAnnotationSafe(self.stream, f, stack)), char(self.char));
      }
    case "TextStream":
      {
        return Effect.map(Effect.suspend(() => alterAnnotationSafe(self.stream, f, stack)), text(self.text));
      }
    case "LineStream":
      {
        return Effect.map(Effect.suspend(() => alterAnnotationSafe(self.stream, f, stack)), line(self.indentation));
      }
    case "PushAnnotationStream":
      {
        const altered = f(self.annotation);
        if (Option.isSome(altered)) {
          return Effect.map(Effect.suspend(() => alterAnnotationSafe(self.stream, f, List.prepend(stack, DontRemove))), pushAnnotation(altered.value));
        }
        return Effect.suspend(() => alterAnnotationSafe(self.stream, f, List.prepend(stack, Remove)));
      }
    case "PopAnnotationStream":
      {
        if (List.isNil(stack)) {
          return Effect.dieMessage("BUG: DocStream.alterAnnotations - received empty stack to pop from" + " - please report an issue at https://github.com/Effect-TS/printer/issues");
        }
        if (stack.head === DontRemove) {
          return Effect.map(Effect.suspend(() => alterAnnotationSafe(self.stream, f, stack.tail)), popAnnotation);
        }
        return Effect.suspend(() => alterAnnotationSafe(self.stream, f, stack.tail));
      }
    default:
      {
        return Effect.succeed(self);
      }
  }
};
/** @internal */
const reAnnotate = exports.reAnnotate = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => Effect.runSync(reAnnotateSafe(self, f)));
const reAnnotateSafe = (self, f) => {
  switch (self._tag) {
    case "CharStream":
      {
        return Effect.map(Effect.suspend(() => reAnnotateSafe(self.stream, f)), char(self.char));
      }
    case "TextStream":
      {
        return Effect.map(Effect.suspend(() => reAnnotateSafe(self.stream, f)), text(self.text));
      }
    case "LineStream":
      {
        return Effect.map(Effect.suspend(() => reAnnotateSafe(self.stream, f)), line(self.indentation));
      }
    case "PushAnnotationStream":
      {
        return Effect.map(Effect.suspend(() => reAnnotateSafe(self.stream, f)), pushAnnotation(f(self.annotation)));
      }
    case "PopAnnotationStream":
      {
        return Effect.suspend(() => reAnnotateSafe(self.stream, f));
      }
    default:
      {
        return Effect.succeed(self);
      }
  }
};
/** @internal */
const unAnnotate = self => Effect.runSync(unAnnotateSafe(self));
exports.unAnnotate = unAnnotate;
const unAnnotateSafe = self => {
  switch (self._tag) {
    case "CharStream":
      {
        return Effect.map(Effect.suspend(() => unAnnotateSafe(self.stream)), char(self.char));
      }
    case "TextStream":
      {
        return Effect.map(Effect.suspend(() => unAnnotateSafe(self.stream)), text(self.text));
      }
    case "LineStream":
      {
        return Effect.map(Effect.suspend(() => unAnnotateSafe(self.stream)), line(self.indentation));
      }
    case "PushAnnotationStream":
    case "PopAnnotationStream":
      {
        return Effect.suspend(() => unAnnotateSafe(self.stream));
      }
    default:
      {
        return Effect.succeed(self);
      }
  }
};
// -----------------------------------------------------------------------------
// Folding
// -----------------------------------------------------------------------------
/** @internal */
const foldMap = exports.foldMap = /*#__PURE__*/(0, _Function.dual)(3, (self, M, f) => Effect.runSync(foldMapSafe(self, M, f)));
const foldMapSafe = (self, M, f) => {
  switch (self._tag) {
    case "CharStream":
      {
        return Effect.suspend(() => foldMapSafe(self.stream, M, f));
      }
    case "TextStream":
      {
        return Effect.suspend(() => foldMapSafe(self.stream, M, f));
      }
    case "LineStream":
      {
        return Effect.suspend(() => foldMapSafe(self.stream, M, f));
      }
    case "PushAnnotationStream":
      {
        return Effect.map(Effect.suspend(() => foldMapSafe(self.stream, M, f)), that => M.combine(f(self.annotation), that));
      }
    case "PopAnnotationStream":
      {
        return Effect.suspend(() => foldMapSafe(self.stream, M, f));
      }
    default:
      {
        return Effect.succeed(M.empty);
      }
  }
};
/** @internal */
const match = exports.match = /*#__PURE__*/(0, _Function.dual)(2, (self, patterns) => {
  switch (self._tag) {
    case "FailedStream":
      {
        return patterns.FailedStream();
      }
    case "EmptyStream":
      {
        return patterns.EmptyStream();
      }
    case "CharStream":
      {
        return patterns.CharStream(self.char, self.stream);
      }
    case "TextStream":
      {
        return patterns.TextStream(self.text, self.stream);
      }
    case "LineStream":
      {
        return patterns.LineStream(self.indentation, self.stream);
      }
    case "PushAnnotationStream":
      {
        return patterns.PushAnnotationStream(self.annotation, self.stream);
      }
    case "PopAnnotationStream":
      {
        return patterns.PopAnnotationStream(self.stream);
      }
  }
});
// -----------------------------------------------------------------------------
// Instances
// -----------------------------------------------------------------------------
/** @internal */
const map = exports.map = reAnnotate;
/** @internal */
const imap = exports.imap = /*#__PURE__*/covariant.imap(map);
/** @internal */
const Covariant = exports.Covariant = {
  map,
  imap
};
/** @internal */
const Invariant = exports.Invariant = {
  imap
};
//# sourceMappingURL=docStream.js.map