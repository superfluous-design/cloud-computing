"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.words = exports.width = exports.vsep = exports.vcat = exports.vbar = exports.union = exports.unAnnotate = exports.tupled = exports.textSpaces = exports.text = exports.surround = exports.string = exports.squote = exports.squareBracketed = exports.spaces = exports.space = exports.softLineBreak = exports.softLine = exports.slash = exports.singleQuoted = exports.seps = exports.semi = exports.rparen = exports.reflow = exports.reAnnotate = exports.rbracket = exports.rbrace = exports.rangle = exports.punctuate = exports.parenthesized = exports.pageWidth = exports.nesting = exports.nest = exports.match = exports.map = exports.lparen = exports.list = exports.lineBreak = exports.line = exports.lbracket = exports.lbrace = exports.langle = exports.isWithPageWidth = exports.isUnion = exports.isText = exports.isNesting = exports.isNest = exports.isLine = exports.isFlatAlt = exports.isFail = exports.isEmpty = exports.isDoc = exports.isColumn = exports.isChar = exports.isCat = exports.isAnnotated = exports.indent = exports.imap = exports.hsep = exports.hcat = exports.hardLine = exports.hang = exports.group = exports.getSemigroup = exports.getMonoid = exports.flatten = exports.flatAlt = exports.fillSep = exports.fillCat = exports.fillBreak = exports.fill = exports.fail = exports.equalSign = exports.encloseSep = exports.empty = exports.dquote = exports.doubleQuoted = exports.dot = exports.curlyBraced = exports.concatWith = exports.comma = exports.column = exports.colon = exports.char = exports.changesUponFlattening = exports.cats = exports.catWithSpace = exports.catWithSoftLineBreak = exports.catWithSoftLine = exports.catWithLineBreak = exports.catWithLine = exports.cat = exports.backslash = exports.annotate = exports.angleBracketed = exports.alterAnnotations = exports.align = exports.Invariant = exports.DocTypeId = exports.Covariant = void 0;
var covariant = _interopRequireWildcard(require("@effect/typeclass/Covariant"));
var Arr = _interopRequireWildcard(require("effect/Array"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Equal = _interopRequireWildcard(require("effect/Equal"));
var _Function = require("effect/Function");
var Hash = _interopRequireWildcard(require("effect/Hash"));
var _Pipeable = require("effect/Pipeable");
var InternalFlatten = _interopRequireWildcard(require("./flatten.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
const DocSymbolKey = "@effect/printer/Doc";
/** @internal */
const DocTypeId = exports.DocTypeId = /*#__PURE__*/Symbol.for(DocSymbolKey);
const protoHash = {
  Fail: _ => Hash.combine(Hash.hash(DocSymbolKey))(Hash.hash("@effect/printer/Doc/Fail")),
  Empty: _ => Hash.combine(Hash.hash(DocSymbolKey))(Hash.hash("@effect/printer/Doc/Empty")),
  Char: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.string(self.char)),
  Text: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.string(self.text)),
  Line: _ => Hash.combine(Hash.hash(DocSymbolKey))(Hash.hash("@effect/printer/Doc/Line")),
  FlatAlt: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.combine(Hash.hash(self.left))(Hash.hash(self.right))),
  Cat: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.combine(Hash.hash(self.left))(Hash.hash(self.right))),
  Nest: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.combine(Hash.hash(self.indent))(Hash.hash(self.doc))),
  Union: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.combine(Hash.hash(self.left))(Hash.hash(self.right))),
  Column: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.hash(self.react)),
  WithPageWidth: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.hash(self.react)),
  Nesting: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.hash(self.react)),
  Annotated: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.combine(Hash.hash(self.annotation))(Hash.hash(self.doc)))
};
const protoEqual = {
  Fail: (_, that) => isDoc(that) && that._tag === "Fail",
  Empty: (_, that) => isDoc(that) && that._tag === "Empty",
  Char: (self, that) => isDoc(that) && that._tag === "Char" && self.char === that.char,
  Text: (self, that) => isDoc(that) && that._tag === "Text" && self.text === that.text,
  Line: (_, that) => isDoc(that) && that._tag === "Line",
  FlatAlt: (self, that) => isDoc(that) && that._tag === "FlatAlt" && Equal.equals(that.left)(self.left) && Equal.equals(that.right)(self.right),
  Cat: (self, that) => isDoc(that) && that._tag === "Cat" && Equal.equals(that.left)(self.left) && Equal.equals(that.right)(self.right),
  Nest: (self, that) => isDoc(that) && that._tag === "Nest" && self.indent === that.indent && Equal.equals(that.doc)(self.doc),
  Union: (self, that) => isDoc(that) && that._tag === "Union" && Equal.equals(that.left)(self.left) && Equal.equals(that.right)(self.right),
  Column: (self, that) => isDoc(that) && that._tag === "Column" && Equal.equals(that.react)(self.react),
  WithPageWidth: (self, that) => isDoc(that) && that._tag === "WithPageWidth" && Equal.equals(that.react)(self.react),
  Nesting: (self, that) => isDoc(that) && that._tag === "Nesting" && Equal.equals(that.react)(self.react),
  Annotated: (self, that) => isDoc(that) && that._tag === "Annotated" && Equal.equals(that.annotation)(self.annotation) && Equal.equals(that.doc)(self.doc)
};
const proto = {
  [DocTypeId]: {
    _A: _ => _
  },
  [Hash.symbol]() {
    return Hash.cached(this, protoHash[this._tag](this));
  },
  [Equal.symbol](that) {
    return protoEqual[this._tag](this, that);
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
// -----------------------------------------------------------------------------
// Refinements
// -----------------------------------------------------------------------------
/** @internal */
const isDoc = u => typeof u === "object" && u != null && DocTypeId in u;
/** @internal */
exports.isDoc = isDoc;
const isFail = self => self._tag === "Fail";
/** @internal */
exports.isFail = isFail;
const isEmpty = self => self._tag === "Empty";
/** @internal */
exports.isEmpty = isEmpty;
const isChar = self => self._tag === "Char";
/** @internal */
exports.isChar = isChar;
const isText = self => self._tag === "Text";
/** @internal */
exports.isText = isText;
const isLine = self => self._tag === "Line";
/** @internal */
exports.isLine = isLine;
const isFlatAlt = self => self._tag === "FlatAlt";
/** @internal */
exports.isFlatAlt = isFlatAlt;
const isCat = self => self._tag === "Cat";
/** @internal */
exports.isCat = isCat;
const isNest = self => self._tag === "Nest";
/** @internal */
exports.isNest = isNest;
const isUnion = self => self._tag === "Union";
/** @internal */
exports.isUnion = isUnion;
const isColumn = self => self._tag === "Column";
/** @internal */
exports.isColumn = isColumn;
const isWithPageWidth = self => self._tag === "WithPageWidth";
/** @internal */
exports.isWithPageWidth = isWithPageWidth;
const isNesting = self => self._tag === "Nesting";
/** @internal */
exports.isNesting = isNesting;
const isAnnotated = self => self._tag === "Annotated";
// -----------------------------------------------------------------------------
// Primitives
// -----------------------------------------------------------------------------
/** @internal */
exports.isAnnotated = isAnnotated;
const char = char => {
  const op = Object.create(proto);
  op._tag = "Char";
  op.char = char;
  return op;
};
/** @internal */
exports.char = char;
const text = text => {
  const op = Object.create(proto);
  op._tag = "Text";
  op.text = text;
  return op;
};
/** @internal */
exports.text = text;
const flatAlt = exports.flatAlt = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {
  const op = Object.create(proto);
  op._tag = "FlatAlt";
  op.left = self;
  op.right = that;
  return op;
});
/** @internal */
const union = exports.union = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {
  const op = Object.create(proto);
  op._tag = "Union";
  op.left = self;
  op.right = that;
  return op;
});
/** @internal */
const cat = exports.cat = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {
  const op = Object.create(proto);
  op._tag = "Cat";
  op.left = self;
  op.right = that;
  return op;
});
/** @internal */
const empty = exports.empty = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "Empty";
  return op;
})();
/** @internal */
const fail = exports.fail = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "Fail";
  return op;
})();
/** @internal */
const hardLine = exports.hardLine = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "Line";
  return op;
})();
/** @internal */
const line = exports.line = /*#__PURE__*/flatAlt(hardLine, /*#__PURE__*/char(" "));
/** @internal */
const lineBreak = exports.lineBreak = /*#__PURE__*/flatAlt(hardLine, empty);
/** @internal */
const softLine = exports.softLine = /*#__PURE__*/union(/*#__PURE__*/char(" "), hardLine);
/** @internal */
const softLineBreak = exports.softLineBreak = /*#__PURE__*/union(empty, hardLine);
/** @internal */
const backslash = exports.backslash = /*#__PURE__*/char("\\");
/** @internal */
const colon = exports.colon = /*#__PURE__*/char(":");
/** @internal */
const comma = exports.comma = /*#__PURE__*/char(",");
/** @internal */
const dot = exports.dot = /*#__PURE__*/char(".");
/** @internal */
const dquote = exports.dquote = /*#__PURE__*/char("\"");
/** @internal */
const equalSign = exports.equalSign = /*#__PURE__*/char("=");
/** @internal */
const langle = exports.langle = /*#__PURE__*/char("<");
/** @internal */
const lbrace = exports.lbrace = /*#__PURE__*/char("{");
/** @internal */
const lbracket = exports.lbracket = /*#__PURE__*/char("[");
/** @internal */
const lparen = exports.lparen = /*#__PURE__*/char("(");
/** @internal */
const rangle = exports.rangle = /*#__PURE__*/char(">");
/** @internal */
const rbrace = exports.rbrace = /*#__PURE__*/char("}");
/** @internal */
const rbracket = exports.rbracket = /*#__PURE__*/char("]");
/** @internal */
const rparen = exports.rparen = /*#__PURE__*/char(")");
/** @internal */
const semi = exports.semi = /*#__PURE__*/char(";");
/** @internal */
const slash = exports.slash = /*#__PURE__*/char("/");
/** @internal */
const squote = exports.squote = /*#__PURE__*/char("'");
/** @internal */
const space = exports.space = /*#__PURE__*/char(" ");
/** @internal */
const vbar = exports.vbar = /*#__PURE__*/char("|");
/** @internal */
const cats = docs => group(vcat(docs));
/** @internal */
exports.cats = cats;
const catWithLine = exports.catWithLine = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => cat(self, cat(line, that)));
/** @internal */
const catWithLineBreak = exports.catWithLineBreak = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => cat(self, cat(lineBreak, that)));
/** @internal */
const catWithSoftLine = exports.catWithSoftLine = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => cat(self, cat(softLine, that)));
/** @internal */
const catWithSoftLineBreak = exports.catWithSoftLineBreak = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => cat(self, cat(softLineBreak, that)));
/** @internal */
const catWithSpace = exports.catWithSpace = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => cat(self, cat(space, that)));
/** @internal */
const concatWith = exports.concatWith = /*#__PURE__*/(0, _Function.dual)(2, (docs, f) => Arr.matchRight(Arr.fromIterable(docs), {
  onEmpty: () => empty,
  onNonEmpty: (init, last) => Arr.reduceRight(init, last, (curr, acc) => f(acc, curr))
}));
/** @internal */
const vcat = docs => concatWith(docs, (left, right) => catWithLineBreak(left, right));
/** @internal */
exports.vcat = vcat;
const hcat = docs => concatWith(docs, (left, right) => cat(left, right));
/** @internal */
exports.hcat = hcat;
const fillCat = docs => concatWith(docs, (left, right) => catWithSoftLineBreak(left, right));
// -----------------------------------------------------------------------------
// Separation
// -----------------------------------------------------------------------------
/** @internal */
exports.fillCat = fillCat;
const hsep = docs => concatWith(docs, (left, right) => catWithSpace(left, right));
/** @internal */
exports.hsep = hsep;
const vsep = docs => concatWith(docs, (left, right) => catWithLine(left, right));
/** @internal */
exports.vsep = vsep;
const fillSep = docs => concatWith(docs, (left, right) => catWithSoftLine(left, right));
/** @internal */
exports.fillSep = fillSep;
const seps = docs => group(vsep(docs));
/** @internal */
exports.seps = seps;
const group = self => {
  switch (self._tag) {
    case "FlatAlt":
      {
        const flattened = changesUponFlattening(self.right);
        switch (flattened._tag) {
          case "Flattened":
            {
              return union(flattened.value, self.left);
            }
          case "AlreadyFlat":
            {
              return union(self.right, self.left);
            }
          case "NeverFlat":
            {
              return self.left;
            }
        }
      }
    case "Union":
      {
        return self;
      }
    default:
      {
        const flattened = changesUponFlattening(self);
        return InternalFlatten.isFlattened(flattened) ? union(flattened.value, self) : self;
      }
  }
};
// -----------------------------------------------------------------------------
// Reactive Layouts
// -----------------------------------------------------------------------------
/** @internal */
exports.group = group;
const column = react => {
  const op = Object.create(proto);
  op._tag = "Column";
  op.react = react;
  return op;
};
/** @internal */
exports.column = column;
const nesting = react => {
  const op = Object.create(proto);
  op._tag = "Nesting";
  op.react = react;
  return op;
};
/** @internal */
exports.nesting = nesting;
const width = exports.width = /*#__PURE__*/(0, _Function.dual)(2, (self, react) => column(colStart => cat(self, column(colEnd => react(colEnd - colStart)))));
/** @internal */
const pageWidth = react => {
  const op = Object.create(proto);
  op._tag = "WithPageWidth";
  op.react = react;
  return op;
};
// -----------------------------------------------------------------------------
// Alignment
// -----------------------------------------------------------------------------
/** @internal */
exports.pageWidth = pageWidth;
const nest = exports.nest = /*#__PURE__*/(0, _Function.dual)(2, (self, indent) => indent === 0 ? self : (() => {
  const op = Object.create(proto);
  op._tag = "Nest";
  op.indent = indent;
  op.doc = self;
  return op;
})());
/** @internal */
const align = self => column(position => nesting(level => nest(self, position - level)));
/** @internal */
exports.align = align;
const hang = exports.hang = /*#__PURE__*/(0, _Function.dual)(2, (self, indent) => align(nest(self, indent)));
/** @internal */
const indent = exports.indent = /*#__PURE__*/(0, _Function.dual)(2, (self, indent) => hang(cat(spaces(indent), self), indent));
/** @internal */
const encloseSep = exports.encloseSep = /*#__PURE__*/(0, _Function.dual)(4, (docs, left, right, sep) => {
  const documents = Arr.fromIterable(docs);
  if (Arr.isEmptyReadonlyArray(documents)) {
    return cat(left, right);
  }
  if (documents.length === 1) {
    return cat(left, cat(documents[0], right));
  }
  const xs = (0, _Function.pipe)(Arr.makeBy(documents.length - 1, () => sep), Arr.prepend(left), Arr.zipWith(documents, (left, right) => cat(left, right)));
  return cat(cats(xs), right);
});
/** @internal */
const list = docs => group(encloseSep(docs, flatAlt(text("[ "), lbracket), flatAlt(text(" ]"), rbracket), text(", ")));
/** @internal */
exports.list = list;
const tupled = docs => group(encloseSep(docs, flatAlt(text("( "), lparen), flatAlt(text(" )"), rparen), text(", ")));
// -----------------------------------------------------------------------------
// Filling
// -----------------------------------------------------------------------------
/** @internal */
exports.tupled = tupled;
const fill = exports.fill = /*#__PURE__*/(0, _Function.dual)(2, (self, w) => width(self, i => spaces(w - i)));
/** @internal */
const fillBreak = exports.fillBreak = /*#__PURE__*/(0, _Function.dual)(2, (self, w) => width(self, i => i > w ? nest(lineBreak, w) : spaces(w - i)));
// -----------------------------------------------------------------------------
// Flattening
// -----------------------------------------------------------------------------
/** @internal */
const flatten = self => Effect.runSync(flattenSafe(self));
exports.flatten = flatten;
const flattenSafe = self => Effect.gen(function* () {
  switch (self._tag) {
    case "Fail":
      {
        return self;
      }
    case "Empty":
      {
        return self;
      }
    case "Char":
      {
        return self;
      }
    case "Text":
      {
        return self;
      }
    case "Line":
      {
        return fail;
      }
    case "FlatAlt":
      {
        return yield* flattenSafe(self.right);
      }
    case "Cat":
      {
        const left = yield* flattenSafe(self.left);
        const right = yield* flattenSafe(self.right);
        return cat(left, right);
      }
    case "Nest":
      {
        const doc = yield* flattenSafe(self.doc);
        return nest(doc, self.indent);
      }
    case "Union":
      {
        return yield* flattenSafe(self.left);
      }
    case "Column":
      {
        return column(position => flatten(self.react(position)));
      }
    case "WithPageWidth":
      {
        return pageWidth(pageWidth => flatten(self.react(pageWidth)));
      }
    case "Nesting":
      {
        return nesting(level => flatten(self.react(level)));
      }
    case "Annotated":
      {
        const doc = yield* flattenSafe(self.doc);
        return annotate(doc, self.annotation);
      }
  }
});
/** @internal */
const changesUponFlattening = self => Effect.runSync(changesUponFlatteningSafe(self));
exports.changesUponFlattening = changesUponFlattening;
const changesUponFlatteningSafe = self => Effect.gen(function* () {
  switch (self._tag) {
    case "Fail":
    case "Line":
      {
        return InternalFlatten.neverFlat;
      }
    case "Empty":
    case "Char":
    case "Text":
      {
        return InternalFlatten.alreadyFlat;
      }
    case "FlatAlt":
      {
        const doc = yield* flattenSafe(self.right);
        return InternalFlatten.flattened(doc);
      }
    case "Cat":
      {
        const left = yield* changesUponFlatteningSafe(self.left);
        const right = yield* changesUponFlatteningSafe(self.right);
        if (InternalFlatten.isNeverFlat(left) || InternalFlatten.isNeverFlat(right)) {
          return InternalFlatten.neverFlat;
        }
        if (InternalFlatten.isFlattened(left) && InternalFlatten.isFlattened(right)) {
          return InternalFlatten.flattened(cat(left.value, right.value));
        }
        if (InternalFlatten.isFlattened(left) && InternalFlatten.isAlreadyFlat(right)) {
          return InternalFlatten.flattened(cat(left.value, self.right));
        }
        if (InternalFlatten.isAlreadyFlat(left) && InternalFlatten.isFlattened(right)) {
          return InternalFlatten.flattened(cat(self.left, right.value));
        }
        if (InternalFlatten.isAlreadyFlat(left) && InternalFlatten.isAlreadyFlat(right)) {
          return InternalFlatten.alreadyFlat;
        }
        throw new Error("[BUG]: Doc.changesUponFlattening - unable to flatten a Cat document " + "- please open an issue at https://github.com/IMax153/contentlayer/issues/new");
      }
    case "Nest":
      {
        return yield* (0, _Function.pipe)(changesUponFlatteningSafe(self.doc), Effect.map(InternalFlatten.map(doc => nest(doc, self.indent))));
      }
    case "Union":
      {
        return InternalFlatten.flattened(self.left);
      }
    case "Column":
      {
        const doc = column(position => Effect.runSync(flattenSafe(self.react(position))));
        return InternalFlatten.flattened(doc);
      }
    case "WithPageWidth":
      {
        const doc = pageWidth(pageWidth => Effect.runSync(flattenSafe(self.react(pageWidth))));
        return InternalFlatten.flattened(doc);
      }
    case "Nesting":
      {
        const doc = nesting(level => Effect.runSync(flattenSafe(self.react(level))));
        return InternalFlatten.flattened(doc);
      }
    case "Annotated":
      {
        return yield* (0, _Function.pipe)(changesUponFlatteningSafe(self.doc), Effect.map(InternalFlatten.map(doc => annotate(doc, self.annotation))));
      }
  }
});
// -----------------------------------------------------------------------------
// Annotations
// -----------------------------------------------------------------------------
/** @internal */
const annotate = exports.annotate = /*#__PURE__*/(0, _Function.dual)(2, (self, annotation) => {
  const op = Object.create(proto);
  op._tag = "Annotated";
  op.doc = self;
  op.annotation = annotation;
  return op;
});
/** @internal */
const alterAnnotations = exports.alterAnnotations = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => Effect.runSync(alterAnnotationsSafe(self, f)));
const alterAnnotationsSafe = (self, f) => {
  switch (self._tag) {
    case "Cat":
      {
        return Effect.zipWith(Effect.suspend(() => alterAnnotationsSafe(self.left, f)), alterAnnotationsSafe(self.right, f), (left, right) => cat(left, right));
      }
    case "FlatAlt":
      {
        return Effect.zipWith(Effect.suspend(() => alterAnnotationsSafe(self.left, f)), alterAnnotationsSafe(self.right, f), (left, right) => flatAlt(left, right));
      }
    case "Union":
      {
        return Effect.zipWith(Effect.suspend(() => alterAnnotationsSafe(self.left, f)), alterAnnotationsSafe(self.right, f), (left, right) => union(left, right));
      }
    case "Nest":
      {
        return Effect.map(Effect.suspend(() => alterAnnotationsSafe(self.doc, f)), nest(self.indent));
      }
    case "Column":
      {
        return Effect.succeed(column(position => Effect.runSync(alterAnnotationsSafe(self.react(position), f))));
      }
    case "WithPageWidth":
      {
        return Effect.succeed(pageWidth(pageWidth => Effect.runSync(alterAnnotationsSafe(self.react(pageWidth), f))));
      }
    case "Nesting":
      {
        return Effect.succeed(nesting(level => Effect.runSync(alterAnnotationsSafe(self.react(level), f))));
      }
    case "Annotated":
      {
        return Effect.map(alterAnnotationsSafe(self.doc, f), doc => Arr.reduceRight(Arr.fromIterable(f(self.annotation)), doc, (doc, b) => annotate(doc, b)));
      }
    default:
      {
        return Effect.succeed(self);
      }
  }
};
/** @internal */
const reAnnotate = exports.reAnnotate = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => alterAnnotations(self, a => [f(a)]));
/** @internal */
const unAnnotate = self => alterAnnotations(() => [])(self);
// -----------------------------------------------------------------------------
// Instances
// -----------------------------------------------------------------------------
/** @internal */
exports.unAnnotate = unAnnotate;
const map = exports.map = reAnnotate;
/** @internal */
const imap = exports.imap = /*#__PURE__*/covariant.imap(map);
/** @internal */
const getSemigroup = () => ({
  combine: cat,
  combineMany: (self, others) => cat(self, cats(others))
});
/** @internal */
exports.getSemigroup = getSemigroup;
const getMonoid = () => ({
  empty,
  combine: cat,
  combineMany: (self, others) => cat(self, cats(others)),
  combineAll: cats
});
/** @internal */
exports.getMonoid = getMonoid;
const Covariant = exports.Covariant = {
  map,
  imap
};
/** @internal */
const Invariant = exports.Invariant = {
  imap
};
// -----------------------------------------------------------------------------
// Utilities
// -----------------------------------------------------------------------------
/** @internal */
const string = str => {
  return cats(str.split("\n").map(s => s.length === 0 ? empty : s.length === 1 ? char(s) : text(s)));
};
/** @internal */
exports.string = string;
const surround = exports.surround = /*#__PURE__*/(0, _Function.dual)(3, (self, left, right) => cat(left, cat(self, right)));
/** @internal */
const singleQuoted = self => surround(self, squote, squote);
/** @Internal */
exports.singleQuoted = singleQuoted;
const doubleQuoted = self => surround(self, dquote, dquote);
/** @internal */
exports.doubleQuoted = doubleQuoted;
const parenthesized = self => surround(self, lparen, rparen);
/** @internal */
exports.parenthesized = parenthesized;
const angleBracketed = self => surround(self, langle, rangle);
/** @internal */
exports.angleBracketed = angleBracketed;
const squareBracketed = self => surround(self, lbracket, rbracket);
/** @internal */
exports.squareBracketed = squareBracketed;
const curlyBraced = self => surround(self, lbrace, rbrace);
/** @internal */
exports.curlyBraced = curlyBraced;
const spaces = n => {
  if (n <= 0) {
    return empty;
  }
  if (n === 1) {
    return char(" ");
  }
  return text(textSpaces(n));
};
/** @internal */
exports.spaces = spaces;
const words = (str, splitChar = " ") => str.split(splitChar).map(word => {
  if (word === "") {
    return empty;
  }
  if (word === "\n") {
    return hardLine;
  }
  if (word.length === 1) {
    return char(word);
  }
  return text(word);
});
/** @internal */
exports.words = words;
const reflow = (s, char = " ") => fillSep(words(s, char));
/** @internal */
exports.reflow = reflow;
const punctuate = exports.punctuate = /*#__PURE__*/(0, _Function.dual)(2, (docs, punctuator) => {
  const documents = Arr.fromIterable(docs);
  return Arr.map(documents, (x, i) => documents.length - 1 === i ? x : cat(x, punctuator));
});
/** @internal */
const match = exports.match = /*#__PURE__*/(0, _Function.dual)(2, (self, patterns) => {
  switch (self._tag) {
    case "Fail":
      {
        return patterns.Fail();
      }
    case "Empty":
      {
        return patterns.Empty();
      }
    case "Char":
      {
        return patterns.Char(self.char);
      }
    case "Text":
      {
        return patterns.Text(self.text);
      }
    case "Line":
      {
        return patterns.Line();
      }
    case "FlatAlt":
      {
        return patterns.FlatAlt(self.left, self.right);
      }
    case "Cat":
      {
        return patterns.Cat(self.left, self.right);
      }
    case "Nest":
      {
        return patterns.Nest(self.indent, self.doc);
      }
    case "Union":
      {
        return patterns.Union(self.left, self.right);
      }
    case "Column":
      {
        return patterns.Column(self.react);
      }
    case "WithPageWidth":
      {
        return patterns.WithPageWidth(self.react);
      }
    case "Nesting":
      {
        return patterns.Nesting(self.react);
      }
    case "Annotated":
      {
        return patterns.Annotated(self.annotation, self.doc);
      }
  }
});
/** @internal */
const textSpaces = n => {
  let s = "";
  for (let i = 0; i < n; i++) {
    s = s += " ";
  }
  return s;
};
exports.textSpaces = textSpaces;
//# sourceMappingURL=doc.js.map