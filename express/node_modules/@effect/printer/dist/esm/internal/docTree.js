import * as covariant from "@effect/typeclass/Covariant";
import * as Arr from "effect/Array";
import * as Effect from "effect/Effect";
import * as Equal from "effect/Equal";
import { dual, pipe } from "effect/Function";
import * as Hash from "effect/Hash";
import * as Option from "effect/Option";
import * as doc from "./doc.js";
import * as docTreeToken from "./docTreeToken.js";
// -----------------------------------------------------------------------------
// Models
// -----------------------------------------------------------------------------
const DocTreeSymbolKey = "@effect/printer/DocTree";
/** @internal */
export const DocTreeTypeId = /*#__PURE__*/Symbol.for(DocTreeSymbolKey);
const protoHash = {
  EmptyTree: _ => pipe(Hash.string("@effect/printer/DocTree/EmptyTree"), Hash.combine(Hash.string(DocTreeSymbolKey))),
  CharTree: self => pipe(Hash.string("@effect/printer/DocTree/CharTree"), Hash.combine(Hash.string(DocTreeSymbolKey)), Hash.combine(Hash.string(self.char))),
  TextTree: self => pipe(Hash.string("@effect/printer/DocTree/TextTree"), Hash.combine(Hash.string(DocTreeSymbolKey)), Hash.combine(Hash.string(self.text))),
  LineTree: self => pipe(Hash.string("@effect/printer/DocTree/LineTree"), Hash.combine(Hash.string(DocTreeSymbolKey)), Hash.combine(Hash.number(self.indentation))),
  AnnotationTree: self => pipe(Hash.string("@effect/printer/DocTree/AnnotationTree"), Hash.combine(Hash.string(DocTreeSymbolKey)), Hash.combine(Hash.hash(self.annotation)), Hash.combine(Hash.hash(self.tree))),
  ConcatTree: self => pipe(Hash.string("@effect/printer/DocTree/ConcatTree"), Hash.combine(Hash.string(DocTreeSymbolKey)), Hash.combine(Hash.hash(self.trees)))
};
const protoEqual = {
  EmptyTree: (_, that) => isDocTree(that) && that._tag === "EmptyTree",
  CharTree: (self, that) => isDocTree(that) && that._tag === "CharTree" && self.char === that.char,
  TextTree: (self, that) => isDocTree(that) && that._tag === "TextTree" && self.text === that.text,
  LineTree: (self, that) => isDocTree(that) && that._tag === "LineTree" && self.indentation === that.indentation,
  AnnotationTree: (self, that) => isDocTree(that) && that._tag === "AnnotationTree" && Equal.equals(self.annotation, that.annotation) && Equal.equals(self.tree, that.tree),
  ConcatTree: (self, that) => isDocTree(that) && that._tag === "ConcatTree" && Equal.equals(self.trees, that.trees)
};
const proto = {
  [DocTreeTypeId]: {
    _A: _ => _
  },
  [Hash.symbol]() {
    return Hash.cached(this, protoHash[this._tag](this));
  },
  [Equal.symbol](that) {
    return protoEqual[this._tag](this, that);
  }
};
// -----------------------------------------------------------------------------
// Refinements
// -----------------------------------------------------------------------------
/** @internal */
export const isDocTree = u => typeof u === "object" && u != null && DocTreeTypeId in u;
/** @internal */
export const isEmptyTree = self => self._tag === "EmptyTree";
/** @internal */
export const isCharTree = self => self._tag === "CharTree";
/** @internal */
export const isTextTree = self => self._tag === "TextTree";
/** @internal */
export const isLineTree = self => self._tag === "LineTree";
/** @internal */
export const isAnnotationTree = self => self._tag === "AnnotationTree";
/** @internal */
export const isConcatTree = self => self._tag === "ConcatTree";
// -----------------------------------------------------------------------------
// Constructors
// -----------------------------------------------------------------------------
/** @internal */
export const empty = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "EmptyTree";
  return op;
})();
/** @internal */
export const char = char => {
  const op = Object.create(proto);
  op._tag = "CharTree";
  op.char = char;
  return op;
};
/** @internal */
export const text = text => {
  const op = Object.create(proto);
  op._tag = "TextTree";
  op.text = text;
  return op;
};
/** @internal */
export const line = indentation => {
  const op = Object.create(proto);
  op._tag = "LineTree";
  op.indentation = indentation;
  return op;
};
/** @internal */
export const annotation = /*#__PURE__*/dual(2, (self, annotation) => {
  const op = Object.create(proto);
  op._tag = "AnnotationTree";
  op.annotation = annotation;
  op.tree = self;
  return op;
});
/** @internal */
export const concat = trees => {
  const op = Object.create(proto);
  op._tag = "ConcatTree";
  op.trees = trees;
  return op;
};
// -----------------------------------------------------------------------------
// Annotations
// -----------------------------------------------------------------------------
/** @internal */
export const alterAnnotations = /*#__PURE__*/dual(2, (self, f) => Effect.runSync(alterAnnotationsSafe(self, f)));
const alterAnnotationsSafe = (self, f) => {
  switch (self._tag) {
    case "EmptyTree":
      {
        return Effect.succeed(empty);
      }
    case "CharTree":
      {
        return Effect.succeed(char(self.char));
      }
    case "TextTree":
      {
        return Effect.succeed(text(self.text));
      }
    case "LineTree":
      {
        return Effect.succeed(line(self.indentation));
      }
    case "AnnotationTree":
      {
        return Arr.reduce(Arr.fromIterable(f(self.annotation)), Effect.suspend(() => alterAnnotationsSafe(self.tree, f)), (acc, b) => Effect.map(acc, annotation(b)));
      }
    case "ConcatTree":
      {
        return pipe(Effect.forEach(self.trees, tree => alterAnnotationsSafe(tree, f)), Effect.map(concat));
      }
  }
};
/** @internal */
export const reAnnotate = /*#__PURE__*/dual(2, (self, f) => alterAnnotations(self, a => [f(a)]));
/** @internal */
export const unAnnotate = self => alterAnnotations(self, () => []);
// -----------------------------------------------------------------------------
// Folding
// -----------------------------------------------------------------------------
/** @internal */
export const foldMap = /*#__PURE__*/dual(3, (self, M, f) => Effect.runSync(foldMapSafe(self, M, f)));
const foldMapSafe = (self, M, f) => {
  switch (self._tag) {
    case "EmptyTree":
    case "CharTree":
    case "TextTree":
    case "LineTree":
      {
        return Effect.succeed(M.empty);
      }
    case "AnnotationTree":
      {
        return Effect.map(Effect.suspend(() => foldMapSafe(self.tree, M, f)), that => M.combine(f(self.annotation), that));
      }
    case "ConcatTree":
      {
        if (Arr.isEmptyReadonlyArray(self.trees)) {
          return Effect.succeed(M.empty);
        }
        return Effect.map(Effect.forEach(self.trees, tree => foldMapSafe(tree, M, f)), trees => {
          const head = trees[0];
          const tail = trees.slice(1);
          return Arr.reduce(tail, head, M.combine);
        });
      }
  }
};
// -----------------------------------------------------------------------------
// Rendering
// -----------------------------------------------------------------------------
/** @internal */
export const renderSimplyDecorated = /*#__PURE__*/dual(4, (self, M, renderText, renderAnnotation) => Effect.runSync(renderSimplyDecoratedSafe(self, M, renderText, renderAnnotation)));
const renderSimplyDecoratedSafe = (self, M, renderText, renderAnnotation) => {
  switch (self._tag) {
    case "EmptyTree":
      {
        return Effect.succeed(M.empty);
      }
    case "CharTree":
      {
        return Effect.succeed(renderText(self.char));
      }
    case "TextTree":
      {
        return Effect.succeed(renderText(self.text));
      }
    case "LineTree":
      {
        return Effect.succeed(M.combine(renderText("\n"), renderText(doc.textSpaces(self.indentation))));
      }
    case "AnnotationTree":
      {
        return Effect.map(Effect.suspend(() => renderSimplyDecoratedSafe(self.tree, M, renderText, renderAnnotation)), out => renderAnnotation(self.annotation, out));
      }
    case "ConcatTree":
      {
        if (Arr.isEmptyReadonlyArray(self.trees)) {
          return Effect.succeed(M.empty);
        }
        const head = self.trees[0];
        const tail = self.trees.slice(1);
        return Arr.reduce(tail, Effect.suspend(() => renderSimplyDecoratedSafe(head, M, renderText, renderAnnotation)), (acc, tree) => Effect.zipWith(acc, Effect.suspend(() => renderSimplyDecoratedSafe(tree, M, renderText, renderAnnotation)), M.combine));
      }
  }
};
// -----------------------------------------------------------------------------
// Conversions
// -----------------------------------------------------------------------------
/** @internal */
export const treeForm = stream => {
  const result = parser()(stream);
  switch (result._tag) {
    case "None":
      {
        throw new Error("BUG: DocTree.treeForm - failed to convert DocStream to DocTree" + " - please report an issue at https://github.com/Effect-TS/printer/issues");
      }
    case "Some":
      {
        const [docTree, remaining] = result.value;
        if (remaining._tag !== "EmptyStream") {
          throw new Error("BUG: DocTree.treeForm - DocStream not fully consumed during DocTree parsing" + " - please report an issue at https://github.com/Effect-TS/printer/issues");
        }
        return docTree;
      }
  }
};
const parserSucceed = value => stream => Option.some([value, stream]);
const parserMap = (self, f) => stream => Option.map(self(stream), ([a, s]) => [f(a), s]);
const parserFlatMap = (self, f) => stream => Option.flatMap(self(stream), ([a, s1]) => f(a)(s1));
function many(parser) {
  return stream => pipe(parser(stream), Option.map(([head, next]) => {
    const output = [head];
    let input = next;
    let result = parser(next);
    while (result._tag === "Some") {
      const [value, nextInput] = result.value;
      output.push(value);
      input = nextInput;
      result = parser(nextInput);
    }
    return [output, input];
  }));
}
const nextToken = () => {
  return stream => {
    switch (stream._tag) {
      case "FailedStream":
        {
          throw new Error("BUG: DocTree.treeForm - found failed doc stream while parsing" + " - please report an issue at https://github.com/Effect-TS/printer/issues");
        }
      case "EmptyStream":
        {
          return Option.none();
        }
      case "CharStream":
        {
          return Option.some([docTreeToken.char(stream.char), stream.stream]);
        }
      case "TextStream":
        {
          return Option.some([docTreeToken.text(stream.text), stream.stream]);
        }
      case "LineStream":
        {
          return Option.some([docTreeToken.line(stream.indentation), stream.stream]);
        }
      case "PushAnnotationStream":
        {
          return Option.some([docTreeToken.pushAnnotation(stream.annotation), stream.stream]);
        }
      case "PopAnnotationStream":
        {
          return Option.some([docTreeToken.popAnnotation, stream.stream]);
        }
    }
  };
};
const mergeTrees = trees => {
  if (trees.length === 0) {
    return empty;
  }
  const head = trees[0];
  const tail = trees.slice(1);
  return tail.length === 0 ? head : concat(trees);
};
const tree = parser => {
  return parserFlatMap(nextToken(), token => {
    switch (token._tag) {
      case "EmptyToken":
        {
          return parserSucceed(empty);
        }
      case "CharToken":
        {
          return parserSucceed(char(token.char));
        }
      case "TextToken":
        {
          return parserSucceed(text(token.text));
        }
      case "LineToken":
        {
          return parserSucceed(line(token.indentation));
        }
      case "PushAnnotationToken":
        {
          return parserFlatMap(parser(), annotatedContents =>
          // Make sure to handle the subsequent pop annotation token
          parserMap(nextToken(), () => annotation(annotatedContents, token.annotation)));
        }
      case "PopAnnotationToken":
        {
          return () => Option.none();
        }
    }
  });
};
/** @internal */
export const parser = () => parserMap(many(tree(() => parser())), mergeTrees);
// -----------------------------------------------------------------------------
// Instances
// -----------------------------------------------------------------------------
export const map = reAnnotate;
const imap = /*#__PURE__*/covariant.imap(map);
/** @internal */
export const getSemigroup = _ => {
  return {
    combine: (self, that) => concat(Arr.make(self, that)),
    combineMany: (self, trees) => concat(Arr.fromIterable([self, ...trees]))
  };
};
/** @internal */
export const getMonoid = _ => {
  return {
    empty,
    combine: (self, that) => concat(Arr.make(self, that)),
    combineMany: (self, trees) => concat(Arr.fromIterable([self, ...trees])),
    combineAll: trees => concat(Arr.fromIterable(trees))
  };
};
/** @internal */
export const Covariant = {
  map,
  imap
};
export const Invariant = {
  imap
};
//# sourceMappingURL=docTree.js.map