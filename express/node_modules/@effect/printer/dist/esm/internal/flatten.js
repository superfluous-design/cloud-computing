import * as Equal from "effect/Equal";
import { dual } from "effect/Function";
import * as Hash from "effect/Hash";
// -----------------------------------------------------------------------------
// Models
// -----------------------------------------------------------------------------
const FlattenSymbolKey = "@effect/printer/Flatten";
/** @internal */
export const FlattenTypeId = /*#__PURE__*/Symbol.for(FlattenSymbolKey);
const protoHash = {
  Flattened: self => Hash.combine(Hash.hash(self.value))(Hash.string(FlattenSymbolKey)),
  AlreadyFlat: _ => Hash.combine(Hash.string("@effect/printer/Flattened/AlreadyFlat"))(Hash.string(FlattenSymbolKey)),
  NeverFlat: _ => Hash.combine(Hash.string("@effect/printer/Flattened/NeverFlat"))(Hash.string(FlattenSymbolKey))
};
const protoEqual = {
  Flattened: (self, that) => isFlatten(that) && that._tag === "Flattened" && Equal.equals(self.value, that.value),
  AlreadyFlat: (_, that) => isFlatten(that) && that._tag === "AlreadyFlat",
  NeverFlat: (_, that) => isFlatten(that) && that._tag === "NeverFlat"
};
const proto = {
  [FlattenTypeId]: {
    _A: _ => _
  },
  [Hash.symbol]() {
    return Hash.cached(this, protoHash[this._tag](this));
  },
  [Equal.symbol](that) {
    return protoEqual[this._tag](this, that);
  }
};
// -----------------------------------------------------------------------------
// Refinements
// -----------------------------------------------------------------------------
/** @internal */
export const isFlatten = u => typeof u === "object" && u != null && FlattenTypeId in u;
/** @internal */
export const isFlattened = self => self._tag === "Flattened";
/** @internal */
export const isAlreadyFlat = self => self._tag === "AlreadyFlat";
/** @internal */
export const isNeverFlat = self => self._tag === "NeverFlat";
// -----------------------------------------------------------------------------
// Constructors
// -----------------------------------------------------------------------------
/** @internal */
export const flattened = value => (() => {
  const op = Object.create(proto);
  op._tag = "Flattened";
  op.value = value;
  return op;
})();
/** @internal */
export const alreadyFlat = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "AlreadyFlat";
  return op;
})();
/** @internal */
export const neverFlat = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "NeverFlat";
  return op;
})();
// -----------------------------------------------------------------------------
// Combinators
// -----------------------------------------------------------------------------
/** @internal */
export const map = /*#__PURE__*/dual(2, (self, f) => {
  switch (self._tag) {
    case "Flattened":
      {
        return flattened(f(self.value));
      }
    case "AlreadyFlat":
      {
        return alreadyFlat;
      }
    case "NeverFlat":
      {
        return neverFlat;
      }
  }
});
//# sourceMappingURL=flatten.js.map