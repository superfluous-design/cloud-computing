import * as covariant from "@effect/typeclass/Covariant";
import * as Effect from "effect/Effect";
import * as Equal from "effect/Equal";
import { dual, pipe } from "effect/Function";
import * as Hash from "effect/Hash";
import * as List from "effect/List";
import * as Option from "effect/Option";
// -----------------------------------------------------------------------------
// Models
// -----------------------------------------------------------------------------
const DocStreamSymbolKey = "@effect/printer/DocStream";
/** @internal */
export const DocStreamTypeId = /*#__PURE__*/Symbol.for(DocStreamSymbolKey);
const protoHash = {
  FailedStream: _ => pipe(Hash.string("@effect/printer/DocStream/FailedStream"), Hash.combine(Hash.string(DocStreamSymbolKey))),
  EmptyStream: _ => pipe(Hash.string("@effect/printer/DocStream/EmptyStream"), Hash.combine(Hash.string(DocStreamSymbolKey))),
  CharStream: self => pipe(Hash.hash("@effect/printer/DocStream/CharStream"), Hash.combine(Hash.string(DocStreamSymbolKey)), Hash.combine(Hash.string(self.char)), Hash.combine(Hash.hash(self.stream))),
  TextStream: self => pipe(Hash.string("@effect/printer/DocStream/TextStream"), Hash.combine(Hash.string(DocStreamSymbolKey)), Hash.combine(Hash.string(self.text)), Hash.combine(Hash.hash(self.stream))),
  LineStream: self => pipe(Hash.string("@effect/printer/DocStream/LineStream"), Hash.combine(Hash.string(DocStreamSymbolKey)), Hash.combine(Hash.hash(self.stream))),
  PushAnnotationStream: self => pipe(Hash.string("@effect/printer/DocStream/PopAnnotationStream"), Hash.combine(Hash.string(DocStreamSymbolKey)), Hash.combine(Hash.hash(self.annotation)), Hash.combine(Hash.hash(self.stream))),
  PopAnnotationStream: self => pipe(Hash.string("@effect/printer/DocStream/PopAnnotationStream"), Hash.combine(Hash.string(DocStreamSymbolKey)), Hash.combine(Hash.hash(self.stream)))
};
const protoEqual = {
  FailedStream: (self, that) => isDocStream(that) && that._tag === "FailedStream",
  EmptyStream: (self, that) => isDocStream(that) && that._tag === "EmptyStream",
  CharStream: (self, that) => isDocStream(that) && that._tag === "CharStream" && self.char === that.char && Equal.equals(self.stream, that.stream),
  TextStream: (self, that) => isDocStream(that) && that._tag === "TextStream" && self.text === that.text && Equal.equals(self.stream, that.stream),
  LineStream: (self, that) => isDocStream(that) && that._tag === "LineStream" && Equal.equals(self.stream, that.stream),
  PushAnnotationStream: (self, that) => isDocStream(that) && that._tag === "PushAnnotationStream" && Equal.equals(self.annotation, that.annotation) && Equal.equals(self.stream, that.stream),
  PopAnnotationStream: (self, that) => isDocStream(that) && that._tag === "PopAnnotationStream" && Equal.equals(self.stream, that.stream)
};
const proto = {
  [DocStreamTypeId]: {
    _A: _ => _
  },
  [Hash.symbol]() {
    return Hash.cached(this, protoHash[this._tag](this));
  },
  [Equal.symbol](that) {
    return protoEqual[this._tag](this, that);
  }
};
// -----------------------------------------------------------------------------
// Refinements
// -----------------------------------------------------------------------------
/** @internal */
export const isDocStream = u => typeof u === "object" && u != null && DocStreamTypeId in u;
/** @internal */
export const isFailedStream = self => self._tag === "FailedStream";
/** @internal */
export const isEmptyStream = self => self._tag === "EmptyStream";
/** @internal */
export const isCharStream = self => self._tag === "CharStream";
/** @internal */
export const isTextStream = self => self._tag === "TextStream";
/** @internal */
export const isLineStream = self => self._tag === "LineStream";
/** @internal */
export const isPushAnnotationStream = self => self._tag === "PushAnnotationStream";
/** @internal */
export const isPopAnnotationStream = self => self._tag === "PopAnnotationStream";
// -----------------------------------------------------------------------------
// Constructors
// -----------------------------------------------------------------------------
/** @internal */
export const failed = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "FailedStream";
  return op;
})();
/** @internal */
export const empty = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "EmptyStream";
  return op;
})();
/** @internal */
export const char = /*#__PURE__*/dual(2, (self, char) => {
  const op = Object.create(proto);
  op._tag = "CharStream";
  op.char = char;
  op.stream = self;
  return op;
});
/** @internal */
export const text = /*#__PURE__*/dual(2, (self, text) => {
  const op = Object.create(proto);
  op._tag = "TextStream";
  op.text = text;
  op.stream = self;
  return op;
});
/** @internal */
export const line = /*#__PURE__*/dual(2, (self, indentation) => {
  const op = Object.create(proto);
  op._tag = "LineStream";
  op.indentation = indentation;
  op.stream = self;
  return op;
});
/** @internal */
export const pushAnnotation = /*#__PURE__*/dual(2, (self, annotation) => {
  const op = Object.create(proto);
  op._tag = "PushAnnotationStream";
  op.annotation = annotation;
  op.stream = self;
  return op;
});
/** @internal */
export const popAnnotation = stream => {
  const op = Object.create(proto);
  op._tag = "PopAnnotationStream";
  op.stream = stream;
  return op;
};
const Remove = "Remove";
const DontRemove = "DontRemove";
/** @internal */
export const alterAnnotations = /*#__PURE__*/dual(2, (self, f) => Effect.runSync(alterAnnotationSafe(self, f, List.nil())));
const alterAnnotationSafe = (self, f, stack) => {
  switch (self._tag) {
    case "CharStream":
      {
        return Effect.map(Effect.suspend(() => alterAnnotationSafe(self.stream, f, stack)), char(self.char));
      }
    case "TextStream":
      {
        return Effect.map(Effect.suspend(() => alterAnnotationSafe(self.stream, f, stack)), text(self.text));
      }
    case "LineStream":
      {
        return Effect.map(Effect.suspend(() => alterAnnotationSafe(self.stream, f, stack)), line(self.indentation));
      }
    case "PushAnnotationStream":
      {
        const altered = f(self.annotation);
        if (Option.isSome(altered)) {
          return Effect.map(Effect.suspend(() => alterAnnotationSafe(self.stream, f, List.prepend(stack, DontRemove))), pushAnnotation(altered.value));
        }
        return Effect.suspend(() => alterAnnotationSafe(self.stream, f, List.prepend(stack, Remove)));
      }
    case "PopAnnotationStream":
      {
        if (List.isNil(stack)) {
          return Effect.dieMessage("BUG: DocStream.alterAnnotations - received empty stack to pop from" + " - please report an issue at https://github.com/Effect-TS/printer/issues");
        }
        if (stack.head === DontRemove) {
          return Effect.map(Effect.suspend(() => alterAnnotationSafe(self.stream, f, stack.tail)), popAnnotation);
        }
        return Effect.suspend(() => alterAnnotationSafe(self.stream, f, stack.tail));
      }
    default:
      {
        return Effect.succeed(self);
      }
  }
};
/** @internal */
export const reAnnotate = /*#__PURE__*/dual(2, (self, f) => Effect.runSync(reAnnotateSafe(self, f)));
const reAnnotateSafe = (self, f) => {
  switch (self._tag) {
    case "CharStream":
      {
        return Effect.map(Effect.suspend(() => reAnnotateSafe(self.stream, f)), char(self.char));
      }
    case "TextStream":
      {
        return Effect.map(Effect.suspend(() => reAnnotateSafe(self.stream, f)), text(self.text));
      }
    case "LineStream":
      {
        return Effect.map(Effect.suspend(() => reAnnotateSafe(self.stream, f)), line(self.indentation));
      }
    case "PushAnnotationStream":
      {
        return Effect.map(Effect.suspend(() => reAnnotateSafe(self.stream, f)), pushAnnotation(f(self.annotation)));
      }
    case "PopAnnotationStream":
      {
        return Effect.suspend(() => reAnnotateSafe(self.stream, f));
      }
    default:
      {
        return Effect.succeed(self);
      }
  }
};
/** @internal */
export const unAnnotate = self => Effect.runSync(unAnnotateSafe(self));
const unAnnotateSafe = self => {
  switch (self._tag) {
    case "CharStream":
      {
        return Effect.map(Effect.suspend(() => unAnnotateSafe(self.stream)), char(self.char));
      }
    case "TextStream":
      {
        return Effect.map(Effect.suspend(() => unAnnotateSafe(self.stream)), text(self.text));
      }
    case "LineStream":
      {
        return Effect.map(Effect.suspend(() => unAnnotateSafe(self.stream)), line(self.indentation));
      }
    case "PushAnnotationStream":
    case "PopAnnotationStream":
      {
        return Effect.suspend(() => unAnnotateSafe(self.stream));
      }
    default:
      {
        return Effect.succeed(self);
      }
  }
};
// -----------------------------------------------------------------------------
// Folding
// -----------------------------------------------------------------------------
/** @internal */
export const foldMap = /*#__PURE__*/dual(3, (self, M, f) => Effect.runSync(foldMapSafe(self, M, f)));
const foldMapSafe = (self, M, f) => {
  switch (self._tag) {
    case "CharStream":
      {
        return Effect.suspend(() => foldMapSafe(self.stream, M, f));
      }
    case "TextStream":
      {
        return Effect.suspend(() => foldMapSafe(self.stream, M, f));
      }
    case "LineStream":
      {
        return Effect.suspend(() => foldMapSafe(self.stream, M, f));
      }
    case "PushAnnotationStream":
      {
        return Effect.map(Effect.suspend(() => foldMapSafe(self.stream, M, f)), that => M.combine(f(self.annotation), that));
      }
    case "PopAnnotationStream":
      {
        return Effect.suspend(() => foldMapSafe(self.stream, M, f));
      }
    default:
      {
        return Effect.succeed(M.empty);
      }
  }
};
/** @internal */
export const match = /*#__PURE__*/dual(2, (self, patterns) => {
  switch (self._tag) {
    case "FailedStream":
      {
        return patterns.FailedStream();
      }
    case "EmptyStream":
      {
        return patterns.EmptyStream();
      }
    case "CharStream":
      {
        return patterns.CharStream(self.char, self.stream);
      }
    case "TextStream":
      {
        return patterns.TextStream(self.text, self.stream);
      }
    case "LineStream":
      {
        return patterns.LineStream(self.indentation, self.stream);
      }
    case "PushAnnotationStream":
      {
        return patterns.PushAnnotationStream(self.annotation, self.stream);
      }
    case "PopAnnotationStream":
      {
        return patterns.PopAnnotationStream(self.stream);
      }
  }
});
// -----------------------------------------------------------------------------
// Instances
// -----------------------------------------------------------------------------
/** @internal */
export const map = reAnnotate;
/** @internal */
export const imap = /*#__PURE__*/covariant.imap(map);
/** @internal */
export const Covariant = {
  map,
  imap
};
/** @internal */
export const Invariant = {
  imap
};
//# sourceMappingURL=docStream.js.map