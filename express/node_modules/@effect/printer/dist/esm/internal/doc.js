import * as covariant from "@effect/typeclass/Covariant";
import * as Arr from "effect/Array";
import * as Effect from "effect/Effect";
import * as Equal from "effect/Equal";
import { dual, pipe } from "effect/Function";
import * as Hash from "effect/Hash";
import { pipeArguments } from "effect/Pipeable";
import * as InternalFlatten from "./flatten.js";
const DocSymbolKey = "@effect/printer/Doc";
/** @internal */
export const DocTypeId = /*#__PURE__*/Symbol.for(DocSymbolKey);
const protoHash = {
  Fail: _ => Hash.combine(Hash.hash(DocSymbolKey))(Hash.hash("@effect/printer/Doc/Fail")),
  Empty: _ => Hash.combine(Hash.hash(DocSymbolKey))(Hash.hash("@effect/printer/Doc/Empty")),
  Char: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.string(self.char)),
  Text: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.string(self.text)),
  Line: _ => Hash.combine(Hash.hash(DocSymbolKey))(Hash.hash("@effect/printer/Doc/Line")),
  FlatAlt: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.combine(Hash.hash(self.left))(Hash.hash(self.right))),
  Cat: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.combine(Hash.hash(self.left))(Hash.hash(self.right))),
  Nest: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.combine(Hash.hash(self.indent))(Hash.hash(self.doc))),
  Union: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.combine(Hash.hash(self.left))(Hash.hash(self.right))),
  Column: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.hash(self.react)),
  WithPageWidth: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.hash(self.react)),
  Nesting: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.hash(self.react)),
  Annotated: self => Hash.combine(Hash.hash(DocSymbolKey))(Hash.combine(Hash.hash(self.annotation))(Hash.hash(self.doc)))
};
const protoEqual = {
  Fail: (_, that) => isDoc(that) && that._tag === "Fail",
  Empty: (_, that) => isDoc(that) && that._tag === "Empty",
  Char: (self, that) => isDoc(that) && that._tag === "Char" && self.char === that.char,
  Text: (self, that) => isDoc(that) && that._tag === "Text" && self.text === that.text,
  Line: (_, that) => isDoc(that) && that._tag === "Line",
  FlatAlt: (self, that) => isDoc(that) && that._tag === "FlatAlt" && Equal.equals(that.left)(self.left) && Equal.equals(that.right)(self.right),
  Cat: (self, that) => isDoc(that) && that._tag === "Cat" && Equal.equals(that.left)(self.left) && Equal.equals(that.right)(self.right),
  Nest: (self, that) => isDoc(that) && that._tag === "Nest" && self.indent === that.indent && Equal.equals(that.doc)(self.doc),
  Union: (self, that) => isDoc(that) && that._tag === "Union" && Equal.equals(that.left)(self.left) && Equal.equals(that.right)(self.right),
  Column: (self, that) => isDoc(that) && that._tag === "Column" && Equal.equals(that.react)(self.react),
  WithPageWidth: (self, that) => isDoc(that) && that._tag === "WithPageWidth" && Equal.equals(that.react)(self.react),
  Nesting: (self, that) => isDoc(that) && that._tag === "Nesting" && Equal.equals(that.react)(self.react),
  Annotated: (self, that) => isDoc(that) && that._tag === "Annotated" && Equal.equals(that.annotation)(self.annotation) && Equal.equals(that.doc)(self.doc)
};
const proto = {
  [DocTypeId]: {
    _A: _ => _
  },
  [Hash.symbol]() {
    return Hash.cached(this, protoHash[this._tag](this));
  },
  [Equal.symbol](that) {
    return protoEqual[this._tag](this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// -----------------------------------------------------------------------------
// Refinements
// -----------------------------------------------------------------------------
/** @internal */
export const isDoc = u => typeof u === "object" && u != null && DocTypeId in u;
/** @internal */
export const isFail = self => self._tag === "Fail";
/** @internal */
export const isEmpty = self => self._tag === "Empty";
/** @internal */
export const isChar = self => self._tag === "Char";
/** @internal */
export const isText = self => self._tag === "Text";
/** @internal */
export const isLine = self => self._tag === "Line";
/** @internal */
export const isFlatAlt = self => self._tag === "FlatAlt";
/** @internal */
export const isCat = self => self._tag === "Cat";
/** @internal */
export const isNest = self => self._tag === "Nest";
/** @internal */
export const isUnion = self => self._tag === "Union";
/** @internal */
export const isColumn = self => self._tag === "Column";
/** @internal */
export const isWithPageWidth = self => self._tag === "WithPageWidth";
/** @internal */
export const isNesting = self => self._tag === "Nesting";
/** @internal */
export const isAnnotated = self => self._tag === "Annotated";
// -----------------------------------------------------------------------------
// Primitives
// -----------------------------------------------------------------------------
/** @internal */
export const char = char => {
  const op = Object.create(proto);
  op._tag = "Char";
  op.char = char;
  return op;
};
/** @internal */
export const text = text => {
  const op = Object.create(proto);
  op._tag = "Text";
  op.text = text;
  return op;
};
/** @internal */
export const flatAlt = /*#__PURE__*/dual(2, (self, that) => {
  const op = Object.create(proto);
  op._tag = "FlatAlt";
  op.left = self;
  op.right = that;
  return op;
});
/** @internal */
export const union = /*#__PURE__*/dual(2, (self, that) => {
  const op = Object.create(proto);
  op._tag = "Union";
  op.left = self;
  op.right = that;
  return op;
});
/** @internal */
export const cat = /*#__PURE__*/dual(2, (self, that) => {
  const op = Object.create(proto);
  op._tag = "Cat";
  op.left = self;
  op.right = that;
  return op;
});
/** @internal */
export const empty = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "Empty";
  return op;
})();
/** @internal */
export const fail = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "Fail";
  return op;
})();
/** @internal */
export const hardLine = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "Line";
  return op;
})();
/** @internal */
export const line = /*#__PURE__*/flatAlt(hardLine, /*#__PURE__*/char(" "));
/** @internal */
export const lineBreak = /*#__PURE__*/flatAlt(hardLine, empty);
/** @internal */
export const softLine = /*#__PURE__*/union(/*#__PURE__*/char(" "), hardLine);
/** @internal */
export const softLineBreak = /*#__PURE__*/union(empty, hardLine);
/** @internal */
export const backslash = /*#__PURE__*/char("\\");
/** @internal */
export const colon = /*#__PURE__*/char(":");
/** @internal */
export const comma = /*#__PURE__*/char(",");
/** @internal */
export const dot = /*#__PURE__*/char(".");
/** @internal */
export const dquote = /*#__PURE__*/char("\"");
/** @internal */
export const equalSign = /*#__PURE__*/char("=");
/** @internal */
export const langle = /*#__PURE__*/char("<");
/** @internal */
export const lbrace = /*#__PURE__*/char("{");
/** @internal */
export const lbracket = /*#__PURE__*/char("[");
/** @internal */
export const lparen = /*#__PURE__*/char("(");
/** @internal */
export const rangle = /*#__PURE__*/char(">");
/** @internal */
export const rbrace = /*#__PURE__*/char("}");
/** @internal */
export const rbracket = /*#__PURE__*/char("]");
/** @internal */
export const rparen = /*#__PURE__*/char(")");
/** @internal */
export const semi = /*#__PURE__*/char(";");
/** @internal */
export const slash = /*#__PURE__*/char("/");
/** @internal */
export const squote = /*#__PURE__*/char("'");
/** @internal */
export const space = /*#__PURE__*/char(" ");
/** @internal */
export const vbar = /*#__PURE__*/char("|");
/** @internal */
export const cats = docs => group(vcat(docs));
/** @internal */
export const catWithLine = /*#__PURE__*/dual(2, (self, that) => cat(self, cat(line, that)));
/** @internal */
export const catWithLineBreak = /*#__PURE__*/dual(2, (self, that) => cat(self, cat(lineBreak, that)));
/** @internal */
export const catWithSoftLine = /*#__PURE__*/dual(2, (self, that) => cat(self, cat(softLine, that)));
/** @internal */
export const catWithSoftLineBreak = /*#__PURE__*/dual(2, (self, that) => cat(self, cat(softLineBreak, that)));
/** @internal */
export const catWithSpace = /*#__PURE__*/dual(2, (self, that) => cat(self, cat(space, that)));
/** @internal */
export const concatWith = /*#__PURE__*/dual(2, (docs, f) => Arr.matchRight(Arr.fromIterable(docs), {
  onEmpty: () => empty,
  onNonEmpty: (init, last) => Arr.reduceRight(init, last, (curr, acc) => f(acc, curr))
}));
/** @internal */
export const vcat = docs => concatWith(docs, (left, right) => catWithLineBreak(left, right));
/** @internal */
export const hcat = docs => concatWith(docs, (left, right) => cat(left, right));
/** @internal */
export const fillCat = docs => concatWith(docs, (left, right) => catWithSoftLineBreak(left, right));
// -----------------------------------------------------------------------------
// Separation
// -----------------------------------------------------------------------------
/** @internal */
export const hsep = docs => concatWith(docs, (left, right) => catWithSpace(left, right));
/** @internal */
export const vsep = docs => concatWith(docs, (left, right) => catWithLine(left, right));
/** @internal */
export const fillSep = docs => concatWith(docs, (left, right) => catWithSoftLine(left, right));
/** @internal */
export const seps = docs => group(vsep(docs));
/** @internal */
export const group = self => {
  switch (self._tag) {
    case "FlatAlt":
      {
        const flattened = changesUponFlattening(self.right);
        switch (flattened._tag) {
          case "Flattened":
            {
              return union(flattened.value, self.left);
            }
          case "AlreadyFlat":
            {
              return union(self.right, self.left);
            }
          case "NeverFlat":
            {
              return self.left;
            }
        }
      }
    case "Union":
      {
        return self;
      }
    default:
      {
        const flattened = changesUponFlattening(self);
        return InternalFlatten.isFlattened(flattened) ? union(flattened.value, self) : self;
      }
  }
};
// -----------------------------------------------------------------------------
// Reactive Layouts
// -----------------------------------------------------------------------------
/** @internal */
export const column = react => {
  const op = Object.create(proto);
  op._tag = "Column";
  op.react = react;
  return op;
};
/** @internal */
export const nesting = react => {
  const op = Object.create(proto);
  op._tag = "Nesting";
  op.react = react;
  return op;
};
/** @internal */
export const width = /*#__PURE__*/dual(2, (self, react) => column(colStart => cat(self, column(colEnd => react(colEnd - colStart)))));
/** @internal */
export const pageWidth = react => {
  const op = Object.create(proto);
  op._tag = "WithPageWidth";
  op.react = react;
  return op;
};
// -----------------------------------------------------------------------------
// Alignment
// -----------------------------------------------------------------------------
/** @internal */
export const nest = /*#__PURE__*/dual(2, (self, indent) => indent === 0 ? self : (() => {
  const op = Object.create(proto);
  op._tag = "Nest";
  op.indent = indent;
  op.doc = self;
  return op;
})());
/** @internal */
export const align = self => column(position => nesting(level => nest(self, position - level)));
/** @internal */
export const hang = /*#__PURE__*/dual(2, (self, indent) => align(nest(self, indent)));
/** @internal */
export const indent = /*#__PURE__*/dual(2, (self, indent) => hang(cat(spaces(indent), self), indent));
/** @internal */
export const encloseSep = /*#__PURE__*/dual(4, (docs, left, right, sep) => {
  const documents = Arr.fromIterable(docs);
  if (Arr.isEmptyReadonlyArray(documents)) {
    return cat(left, right);
  }
  if (documents.length === 1) {
    return cat(left, cat(documents[0], right));
  }
  const xs = pipe(Arr.makeBy(documents.length - 1, () => sep), Arr.prepend(left), Arr.zipWith(documents, (left, right) => cat(left, right)));
  return cat(cats(xs), right);
});
/** @internal */
export const list = docs => group(encloseSep(docs, flatAlt(text("[ "), lbracket), flatAlt(text(" ]"), rbracket), text(", ")));
/** @internal */
export const tupled = docs => group(encloseSep(docs, flatAlt(text("( "), lparen), flatAlt(text(" )"), rparen), text(", ")));
// -----------------------------------------------------------------------------
// Filling
// -----------------------------------------------------------------------------
/** @internal */
export const fill = /*#__PURE__*/dual(2, (self, w) => width(self, i => spaces(w - i)));
/** @internal */
export const fillBreak = /*#__PURE__*/dual(2, (self, w) => width(self, i => i > w ? nest(lineBreak, w) : spaces(w - i)));
// -----------------------------------------------------------------------------
// Flattening
// -----------------------------------------------------------------------------
/** @internal */
export const flatten = self => Effect.runSync(flattenSafe(self));
const flattenSafe = self => Effect.gen(function* () {
  switch (self._tag) {
    case "Fail":
      {
        return self;
      }
    case "Empty":
      {
        return self;
      }
    case "Char":
      {
        return self;
      }
    case "Text":
      {
        return self;
      }
    case "Line":
      {
        return fail;
      }
    case "FlatAlt":
      {
        return yield* flattenSafe(self.right);
      }
    case "Cat":
      {
        const left = yield* flattenSafe(self.left);
        const right = yield* flattenSafe(self.right);
        return cat(left, right);
      }
    case "Nest":
      {
        const doc = yield* flattenSafe(self.doc);
        return nest(doc, self.indent);
      }
    case "Union":
      {
        return yield* flattenSafe(self.left);
      }
    case "Column":
      {
        return column(position => flatten(self.react(position)));
      }
    case "WithPageWidth":
      {
        return pageWidth(pageWidth => flatten(self.react(pageWidth)));
      }
    case "Nesting":
      {
        return nesting(level => flatten(self.react(level)));
      }
    case "Annotated":
      {
        const doc = yield* flattenSafe(self.doc);
        return annotate(doc, self.annotation);
      }
  }
});
/** @internal */
export const changesUponFlattening = self => Effect.runSync(changesUponFlatteningSafe(self));
const changesUponFlatteningSafe = self => Effect.gen(function* () {
  switch (self._tag) {
    case "Fail":
    case "Line":
      {
        return InternalFlatten.neverFlat;
      }
    case "Empty":
    case "Char":
    case "Text":
      {
        return InternalFlatten.alreadyFlat;
      }
    case "FlatAlt":
      {
        const doc = yield* flattenSafe(self.right);
        return InternalFlatten.flattened(doc);
      }
    case "Cat":
      {
        const left = yield* changesUponFlatteningSafe(self.left);
        const right = yield* changesUponFlatteningSafe(self.right);
        if (InternalFlatten.isNeverFlat(left) || InternalFlatten.isNeverFlat(right)) {
          return InternalFlatten.neverFlat;
        }
        if (InternalFlatten.isFlattened(left) && InternalFlatten.isFlattened(right)) {
          return InternalFlatten.flattened(cat(left.value, right.value));
        }
        if (InternalFlatten.isFlattened(left) && InternalFlatten.isAlreadyFlat(right)) {
          return InternalFlatten.flattened(cat(left.value, self.right));
        }
        if (InternalFlatten.isAlreadyFlat(left) && InternalFlatten.isFlattened(right)) {
          return InternalFlatten.flattened(cat(self.left, right.value));
        }
        if (InternalFlatten.isAlreadyFlat(left) && InternalFlatten.isAlreadyFlat(right)) {
          return InternalFlatten.alreadyFlat;
        }
        throw new Error("[BUG]: Doc.changesUponFlattening - unable to flatten a Cat document " + "- please open an issue at https://github.com/IMax153/contentlayer/issues/new");
      }
    case "Nest":
      {
        return yield* pipe(changesUponFlatteningSafe(self.doc), Effect.map(InternalFlatten.map(doc => nest(doc, self.indent))));
      }
    case "Union":
      {
        return InternalFlatten.flattened(self.left);
      }
    case "Column":
      {
        const doc = column(position => Effect.runSync(flattenSafe(self.react(position))));
        return InternalFlatten.flattened(doc);
      }
    case "WithPageWidth":
      {
        const doc = pageWidth(pageWidth => Effect.runSync(flattenSafe(self.react(pageWidth))));
        return InternalFlatten.flattened(doc);
      }
    case "Nesting":
      {
        const doc = nesting(level => Effect.runSync(flattenSafe(self.react(level))));
        return InternalFlatten.flattened(doc);
      }
    case "Annotated":
      {
        return yield* pipe(changesUponFlatteningSafe(self.doc), Effect.map(InternalFlatten.map(doc => annotate(doc, self.annotation))));
      }
  }
});
// -----------------------------------------------------------------------------
// Annotations
// -----------------------------------------------------------------------------
/** @internal */
export const annotate = /*#__PURE__*/dual(2, (self, annotation) => {
  const op = Object.create(proto);
  op._tag = "Annotated";
  op.doc = self;
  op.annotation = annotation;
  return op;
});
/** @internal */
export const alterAnnotations = /*#__PURE__*/dual(2, (self, f) => Effect.runSync(alterAnnotationsSafe(self, f)));
const alterAnnotationsSafe = (self, f) => {
  switch (self._tag) {
    case "Cat":
      {
        return Effect.zipWith(Effect.suspend(() => alterAnnotationsSafe(self.left, f)), alterAnnotationsSafe(self.right, f), (left, right) => cat(left, right));
      }
    case "FlatAlt":
      {
        return Effect.zipWith(Effect.suspend(() => alterAnnotationsSafe(self.left, f)), alterAnnotationsSafe(self.right, f), (left, right) => flatAlt(left, right));
      }
    case "Union":
      {
        return Effect.zipWith(Effect.suspend(() => alterAnnotationsSafe(self.left, f)), alterAnnotationsSafe(self.right, f), (left, right) => union(left, right));
      }
    case "Nest":
      {
        return Effect.map(Effect.suspend(() => alterAnnotationsSafe(self.doc, f)), nest(self.indent));
      }
    case "Column":
      {
        return Effect.succeed(column(position => Effect.runSync(alterAnnotationsSafe(self.react(position), f))));
      }
    case "WithPageWidth":
      {
        return Effect.succeed(pageWidth(pageWidth => Effect.runSync(alterAnnotationsSafe(self.react(pageWidth), f))));
      }
    case "Nesting":
      {
        return Effect.succeed(nesting(level => Effect.runSync(alterAnnotationsSafe(self.react(level), f))));
      }
    case "Annotated":
      {
        return Effect.map(alterAnnotationsSafe(self.doc, f), doc => Arr.reduceRight(Arr.fromIterable(f(self.annotation)), doc, (doc, b) => annotate(doc, b)));
      }
    default:
      {
        return Effect.succeed(self);
      }
  }
};
/** @internal */
export const reAnnotate = /*#__PURE__*/dual(2, (self, f) => alterAnnotations(self, a => [f(a)]));
/** @internal */
export const unAnnotate = self => alterAnnotations(() => [])(self);
// -----------------------------------------------------------------------------
// Instances
// -----------------------------------------------------------------------------
/** @internal */
export const map = reAnnotate;
/** @internal */
export const imap = /*#__PURE__*/covariant.imap(map);
/** @internal */
export const getSemigroup = () => ({
  combine: cat,
  combineMany: (self, others) => cat(self, cats(others))
});
/** @internal */
export const getMonoid = () => ({
  empty,
  combine: cat,
  combineMany: (self, others) => cat(self, cats(others)),
  combineAll: cats
});
/** @internal */
export const Covariant = {
  map,
  imap
};
/** @internal */
export const Invariant = {
  imap
};
// -----------------------------------------------------------------------------
// Utilities
// -----------------------------------------------------------------------------
/** @internal */
export const string = str => {
  return cats(str.split("\n").map(s => s.length === 0 ? empty : s.length === 1 ? char(s) : text(s)));
};
/** @internal */
export const surround = /*#__PURE__*/dual(3, (self, left, right) => cat(left, cat(self, right)));
/** @internal */
export const singleQuoted = self => surround(self, squote, squote);
/** @Internal */
export const doubleQuoted = self => surround(self, dquote, dquote);
/** @internal */
export const parenthesized = self => surround(self, lparen, rparen);
/** @internal */
export const angleBracketed = self => surround(self, langle, rangle);
/** @internal */
export const squareBracketed = self => surround(self, lbracket, rbracket);
/** @internal */
export const curlyBraced = self => surround(self, lbrace, rbrace);
/** @internal */
export const spaces = n => {
  if (n <= 0) {
    return empty;
  }
  if (n === 1) {
    return char(" ");
  }
  return text(textSpaces(n));
};
/** @internal */
export const words = (str, splitChar = " ") => str.split(splitChar).map(word => {
  if (word === "") {
    return empty;
  }
  if (word === "\n") {
    return hardLine;
  }
  if (word.length === 1) {
    return char(word);
  }
  return text(word);
});
/** @internal */
export const reflow = (s, char = " ") => fillSep(words(s, char));
/** @internal */
export const punctuate = /*#__PURE__*/dual(2, (docs, punctuator) => {
  const documents = Arr.fromIterable(docs);
  return Arr.map(documents, (x, i) => documents.length - 1 === i ? x : cat(x, punctuator));
});
/** @internal */
export const match = /*#__PURE__*/dual(2, (self, patterns) => {
  switch (self._tag) {
    case "Fail":
      {
        return patterns.Fail();
      }
    case "Empty":
      {
        return patterns.Empty();
      }
    case "Char":
      {
        return patterns.Char(self.char);
      }
    case "Text":
      {
        return patterns.Text(self.text);
      }
    case "Line":
      {
        return patterns.Line();
      }
    case "FlatAlt":
      {
        return patterns.FlatAlt(self.left, self.right);
      }
    case "Cat":
      {
        return patterns.Cat(self.left, self.right);
      }
    case "Nest":
      {
        return patterns.Nest(self.indent, self.doc);
      }
    case "Union":
      {
        return patterns.Union(self.left, self.right);
      }
    case "Column":
      {
        return patterns.Column(self.react);
      }
    case "WithPageWidth":
      {
        return patterns.WithPageWidth(self.react);
      }
    case "Nesting":
      {
        return patterns.Nesting(self.react);
      }
    case "Annotated":
      {
        return patterns.Annotated(self.annotation, self.doc);
      }
  }
});
/** @internal */
export const textSpaces = n => {
  let s = "";
  for (let i = 0; i < n; i++) {
    s = s += " ";
  }
  return s;
};
//# sourceMappingURL=doc.js.map