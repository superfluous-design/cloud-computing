/**
 * @since 1.0.0
 */
import type { Equal } from "effect/Equal";
import type { TypeLambda } from "effect/HKT";
/**
 * @since 1.0.0
 * @category symbol
 */
export declare const FlattenTypeId: unique symbol;
/**
 * @since 1.0.0
 * @category symbol
 */
export type FlattenTypeId = typeof FlattenTypeId;
/**
 * Because certain documents do not change after removal of newlines, etc, there
 * is no point in creating a `Union` of the flattened and unflattened versions.
 * All this leads to is the introduction of two possible branches for a layout
 * algorithm to take, resulting in potentially exponential behavior on deeply
 * nested examples.
 *
 * @since 1.0.0
 * @category model
 */
export type Flatten<A> = Flattened<A> | AlreadyFlat<A> | NeverFlat<A>;
/**
 * @since 1.0.0
 */
export declare namespace Flatten {
    /**
     * @since 1.0.0
     * @category model
     */
    interface Variance<A> extends Equal {
        readonly [FlattenTypeId]: {
            readonly _A: (_: never) => A;
        };
    }
    /**
     * @since 1.0.0
     */
    type TypeLambda = FlattenTypeLambda;
}
/**
 * @since 1.0.0
 * @category model
 */
export interface FlattenTypeLambda extends TypeLambda {
    readonly type: Flatten<this["Target"]>;
}
/**
 * Represents a `FlattenResult` where `A` is likely flatter than the input.
 *
 * @since 1.0.0
 * @category model
 */
export interface Flattened<A> extends Flatten.Variance<A> {
    readonly _tag: "Flattened";
    readonly value: A;
}
/**
 * Represents a `FlattenResult` where the input was already flat.
 *
 * @since 1.0.0
 * @category model
 */
export interface AlreadyFlat<A> extends Flatten.Variance<A> {
    readonly _tag: "AlreadyFlat";
}
/**
 * Represents a `FlattenResult` where the input cannot be flattened.
 *
 * @since 1.0.0
 * @category model
 */
export interface NeverFlat<A> extends Flatten.Variance<A> {
    readonly _tag: "NeverFlat";
}
/**
 * Returns `true` if the specified value is a `Flatten`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
export declare const isFlatten: (u: unknown) => u is Flatten<unknown>;
/**
 * Returns `true` if the specified `Flatten` is a `Flattened`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
export declare const isFlattened: <A>(a: Flatten<A>) => a is Flattened<A>;
/**
 * Returns `true` if the specified `Flatten` is an `AlreadyFlat`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
export declare const isAlreadyFlat: <A>(a: Flatten<A>) => a is AlreadyFlat<A>;
/**
 * Returns `true` if the specified `Flatten` is a `NeverFlat`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
export declare const isNeverFlat: <A>(a: Flatten<A>) => a is NeverFlat<A>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const flattened: <A>(value: A) => Flatten<A>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const alreadyFlat: Flatten<never>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const neverFlat: Flatten<never>;
/**
 * @since 1.0.0
 * @category mapping
 */
export declare const map: {
    /**
     * @since 1.0.0
     * @category mapping
     */
    <A, B>(f: (a: A) => B): (self: Flatten<A>) => Flatten<B>;
    /**
     * @since 1.0.0
     * @category mapping
     */
    <A, B>(self: Flatten<A>, f: (a: A) => B): Flatten<B>;
};
//# sourceMappingURL=Flatten.d.ts.map