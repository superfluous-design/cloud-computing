import * as Otel from "@opentelemetry/semantic-conventions";
import * as Effect from "effect/Effect";
import * as Effectable from "effect/Effectable";
import * as FiberRef from "effect/FiberRef";
import { dual, identity } from "effect/Function";
import { globalValue } from "effect/GlobalValue";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import * as Predicate from "effect/Predicate";
import * as Stream from "effect/Stream";
/** @internal */
export const FragmentId = /*#__PURE__*/Symbol.for("@effect/sql/Fragment");
/** @internal */
export const isFragment = u => typeof u === "object" && u !== null && FragmentId in u;
/** @internal */
export const isParameter = u => Predicate.isTagged(u, "Parameter");
/** @internal */
export const isCustom = kind => u => u instanceof CustomImpl && u.kind === kind;
/** @internal */
export const currentTransformer = /*#__PURE__*/globalValue("@effect/sql/Statement/currentTransformer", () => FiberRef.unsafeMake(Option.none()));
/** @internal */
export const withTransformer = /*#__PURE__*/dual(2, (effect, f) => Effect.locally(effect, currentTransformer, Option.some(f)));
/** @internal */
export const withTransformerDisabled = effect => Effect.locally(effect, currentTransformer, Option.none());
/** @internal */
export const setTransformer = f => Layer.locallyScoped(currentTransformer, Option.some(f));
const withStatement = (self, span, f) => Effect.withFiberRuntime(fiber => {
  const transform = fiber.getFiberRef(currentTransformer);
  if (transform._tag === "None") {
    return f(self);
  }
  return Effect.flatMap(transform.value(self, make(self.acquirer, self.compiler, self.spanAttributes, self.transformRows), fiber.getFiberRefs(), span), f);
});
/** @internal */
export class StatementPrimitive extends Effectable.Class {
  segments;
  acquirer;
  compiler;
  spanAttributes;
  transformRows;
  get [FragmentId]() {
    return identity;
  }
  constructor(segments, acquirer, compiler, spanAttributes, transformRows) {
    super();
    this.segments = segments;
    this.acquirer = acquirer;
    this.compiler = compiler;
    this.spanAttributes = spanAttributes;
    this.transformRows = transformRows;
  }
  withConnection(operation, f, withoutTransform = false) {
    return Effect.useSpan("sql.execute", {
      kind: "client",
      captureStackTrace: false
    }, span => withStatement(this, span, statement => {
      const [sql, params] = statement.compile(withoutTransform);
      for (const [key, value] of this.spanAttributes) {
        span.attribute(key, value);
      }
      span.attribute(Otel.SEMATTRS_DB_OPERATION, operation);
      span.attribute(Otel.SEMATTRS_DB_STATEMENT, sql);
      return Effect.scoped(Effect.flatMap(this.acquirer, _ => f(_, sql, params)));
    }));
  }
  get withoutTransform() {
    return this.withConnection("executeWithoutTransform", (connection, sql, params) => connection.execute(sql, params, undefined), true);
  }
  get raw() {
    return this.withConnection("executeRaw", (connection, sql, params) => connection.executeRaw(sql, params), true);
  }
  get stream() {
    return Stream.unwrapScoped(Effect.flatMap(Effect.makeSpanScoped("sql.execute", {
      kind: "client",
      captureStackTrace: false
    }), span => withStatement(this, span, statement => {
      const [sql, params] = statement.compile();
      for (const [key, value] of this.spanAttributes) {
        span.attribute(key, value);
      }
      span.attribute(Otel.SEMATTRS_DB_OPERATION, "executeStream");
      span.attribute(Otel.SEMATTRS_DB_STATEMENT, sql);
      return Effect.map(this.acquirer, _ => _.executeStream(sql, params, this.transformRows));
    })));
  }
  get values() {
    return this.withConnection("executeValues", (connection, sql, params) => connection.executeValues(sql, params));
  }
  get unprepared() {
    return this.withConnection("executeUnprepared", (connection, sql, params) => connection.executeUnprepared(sql, params, this.transformRows));
  }
  compile(withoutTransform) {
    return this.compiler.compile(this, withoutTransform ?? false);
  }
  commit() {
    return this.withConnection("execute", (connection, sql, params) => connection.execute(sql, params, this.transformRows));
  }
  toJSON() {
    const [sql, params] = this.compile();
    return {
      _id: "@effect/sql/Statement",
      segments: this.segments,
      sql,
      params
    };
  }
}
class FragmentImpl {
  segments;
  get [FragmentId]() {
    return identity;
  }
  constructor(segments) {
    this.segments = segments;
  }
}
class LiteralImpl {
  value;
  params;
  _tag = "Literal";
  constructor(value, params) {
    this.value = value;
    this.params = params;
  }
}
class IdentifierImpl {
  value;
  _tag = "Identifier";
  constructor(value) {
    this.value = value;
  }
}
class ParameterImpl {
  value;
  _tag = "Parameter";
  constructor(value) {
    this.value = value;
  }
}
class ArrayHelperImpl {
  value;
  _tag = "ArrayHelper";
  constructor(value) {
    this.value = value;
  }
}
function identifierWrap(sql) {
  return typeof sql === "string" ? sql : FragmentId in sql ? sql : new FragmentImpl([sql]);
}
class RecordInsertHelperImpl {
  value;
  returningIdentifier;
  _tag = "RecordInsertHelper";
  constructor(value, returningIdentifier) {
    this.value = value;
    this.returningIdentifier = returningIdentifier;
  }
  returning(sql) {
    return new RecordInsertHelperImpl(this.value, identifierWrap(sql));
  }
}
class RecordUpdateHelperImpl {
  value;
  alias;
  returningIdentifier;
  _tag = "RecordUpdateHelper";
  constructor(value, alias, returningIdentifier) {
    this.value = value;
    this.alias = alias;
    this.returningIdentifier = returningIdentifier;
  }
  returning(sql) {
    return new RecordUpdateHelperImpl(this.value, this.alias, identifierWrap(sql));
  }
}
class RecordUpdateHelperSingleImpl {
  value;
  omit;
  returningIdentifier;
  _tag = "RecordUpdateHelperSingle";
  constructor(value, omit, returningIdentifier) {
    this.value = value;
    this.omit = omit;
    this.returningIdentifier = returningIdentifier;
  }
  returning(sql) {
    return new RecordUpdateHelperSingleImpl(this.value, this.omit, identifierWrap(sql));
  }
}
class CustomImpl {
  kind;
  i0;
  i1;
  i2;
  _tag = "Custom";
  constructor(kind, i0, i1, i2) {
    this.kind = kind;
    this.i0 = i0;
    this.i1 = i1;
    this.i2 = i2;
  }
}
/** @internal */
export const custom = kind => (i0, i1, i2) => new FragmentImpl([new CustomImpl(kind, i0, i1, i2)]);
const isHelper = u => u instanceof ArrayHelperImpl || u instanceof RecordInsertHelperImpl || u instanceof RecordUpdateHelperImpl || u instanceof RecordUpdateHelperSingleImpl || u instanceof IdentifierImpl;
const constructorCache = /*#__PURE__*/globalValue("@effect/sql/Statement/constructorCache", () => ({
  transforms: new WeakMap(),
  noTransforms: new WeakMap()
}));
/** @internal */
export const make = (acquirer, compiler, spanAttributes, transformRows) => {
  const cache = transformRows === undefined ? constructorCache.noTransforms : constructorCache.transforms;
  if (cache.has(acquirer)) {
    return cache.get(acquirer);
  }
  const self = Object.assign(function sql(strings, ...args) {
    if (Array.isArray(strings) && "raw" in strings) {
      return statement(acquirer, compiler, strings, args, spanAttributes, transformRows);
    } else if (typeof strings === "string") {
      return new IdentifierImpl(strings);
    }
    throw "absurd";
  }, {
    unsafe(sql, params) {
      return new StatementPrimitive([new LiteralImpl(sql, params)], acquirer, compiler, spanAttributes, transformRows);
    },
    literal(sql) {
      return new FragmentImpl([new LiteralImpl(sql)]);
    },
    in: in_,
    insert(value) {
      return new RecordInsertHelperImpl(Array.isArray(value) ? value : [value], undefined);
    },
    update(value, omit) {
      return new RecordUpdateHelperSingleImpl(value, omit ?? [], undefined);
    },
    updateValues(value, alias) {
      return new RecordUpdateHelperImpl(value, alias, undefined);
    },
    and,
    or,
    csv,
    join,
    onDialect(options) {
      return options[compiler.dialect]();
    },
    onDialectOrElse(options) {
      return options[compiler.dialect] !== undefined ? options[compiler.dialect]() : options.orElse();
    }
  });
  cache.set(acquirer, self);
  return self;
};
/** @internal */
export const statement = (acquirer, compiler, strings, args, spanAttributes, transformRows) => {
  const segments = strings[0].length > 0 ? [new LiteralImpl(strings[0])] : [];
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (isFragment(arg)) {
      for (const segment of arg.segments) {
        segments.push(segment);
      }
    } else if (isHelper(arg)) {
      segments.push(arg);
    } else {
      segments.push(new ParameterImpl(arg));
    }
    if (strings[i + 1].length > 0) {
      segments.push(new LiteralImpl(strings[i + 1]));
    }
  }
  return new StatementPrimitive(segments, acquirer, compiler, spanAttributes, transformRows);
};
/** @internal */
export const unsafeFragment = (sql, params) => new FragmentImpl([new LiteralImpl(sql, params)]);
function convertLiteralOrFragment(clause) {
  if (typeof clause === "string") {
    return [new LiteralImpl(clause)];
  }
  return clause.segments;
}
function in_() {
  if (arguments.length === 1) {
    return new ArrayHelperImpl(arguments[0]);
  }
  const column = arguments[0];
  const values = arguments[1];
  return values.length === 0 ? unsafeFragment("1=0") : new FragmentImpl([new IdentifierImpl(column), new LiteralImpl(" IN "), new ArrayHelperImpl(values)]);
}
/** @internal */
export function join(literal, addParens = true, fallback = "") {
  const literalStatement = new LiteralImpl(literal);
  return clauses => {
    if (clauses.length === 0) {
      return unsafeFragment(fallback);
    } else if (clauses.length === 1) {
      return new FragmentImpl(convertLiteralOrFragment(clauses[0]));
    }
    const segments = [];
    if (addParens) {
      segments.push(new LiteralImpl("("));
    }
    segments.push.apply(segments, convertLiteralOrFragment(clauses[0]));
    for (let i = 1; i < clauses.length; i++) {
      segments.push(literalStatement);
      segments.push.apply(segments, convertLiteralOrFragment(clauses[i]));
    }
    if (addParens) {
      segments.push(new LiteralImpl(")"));
    }
    return new FragmentImpl(segments);
  };
}
/** @internal */
export const and = /*#__PURE__*/join(" AND ", true, "1=1");
/** @internal */
export const or = /*#__PURE__*/join(" OR ", true, "1=1");
const csvRaw = /*#__PURE__*/join(", ", false);
/** @internal */
export const csv = (...args) => {
  if (args[args.length - 1].length === 0) {
    return unsafeFragment("");
  }
  if (args.length === 1) {
    return csvRaw(args[0]);
  }
  return new FragmentImpl([new LiteralImpl(`${args[0]} `), ...csvRaw(args[1]).segments]);
};
const statementCacheSymbol = /*#__PURE__*/Symbol.for("@effect/sql/Statement/statementCache");
const statementCacheNoTransformSymbol = /*#__PURE__*/Symbol.for("@effect/sql/Statement/statementCacheNoTransform");
/** @internal */
class CompilerImpl {
  dialect;
  parameterPlaceholder;
  onIdentifier;
  onRecordUpdate;
  onCustom;
  onInsert;
  onRecordUpdateSingle;
  disableTransforms;
  constructor(dialect, parameterPlaceholder, onIdentifier, onRecordUpdate, onCustom, onInsert, onRecordUpdateSingle, disableTransforms = false) {
    this.dialect = dialect;
    this.parameterPlaceholder = parameterPlaceholder;
    this.onIdentifier = onIdentifier;
    this.onRecordUpdate = onRecordUpdate;
    this.onCustom = onCustom;
    this.onInsert = onInsert;
    this.onRecordUpdateSingle = onRecordUpdateSingle;
    this.disableTransforms = disableTransforms;
  }
  compile(statement, withoutTransform = false, placeholderOverride) {
    withoutTransform = withoutTransform || this.disableTransforms;
    const cacheSymbol = withoutTransform ? statementCacheNoTransformSymbol : statementCacheSymbol;
    if (cacheSymbol in statement) {
      return statement[cacheSymbol];
    }
    const segments = statement.segments;
    const len = segments.length;
    let sql = "";
    const binds = [];
    let placeholderCount = 0;
    const placeholder = placeholderOverride ?? (u => this.parameterPlaceholder(++placeholderCount, u));
    const placeholderNoIncrement = u => this.parameterPlaceholder(placeholderCount, u);
    const placeholders = makePlaceholdersArray(placeholder);
    for (let i = 0; i < len; i++) {
      const segment = segments[i];
      switch (segment._tag) {
        case "Literal":
          {
            sql += segment.value;
            if (segment.params) {
              binds.push.apply(binds, segment.params);
            }
            break;
          }
        case "Identifier":
          {
            sql += this.onIdentifier(segment.value, withoutTransform);
            break;
          }
        case "Parameter":
          {
            sql += placeholder(segment.value);
            binds.push(segment.value);
            break;
          }
        case "ArrayHelper":
          {
            sql += `(${placeholders(segment.value)})`;
            binds.push.apply(binds, segment.value);
            break;
          }
        case "RecordInsertHelper":
          {
            const keys = Object.keys(segment.value[0]);
            if (this.onInsert) {
              const values = new Array(segment.value.length);
              let placeholders = "";
              for (let i = 0; i < segment.value.length; i++) {
                const row = new Array(keys.length);
                values[i] = row;
                placeholders += i === 0 ? "(" : ",(";
                for (let j = 0; j < keys.length; j++) {
                  const key = keys[j];
                  const value = segment.value[i][key];
                  const primitive = extractPrimitive(value, this.onCustom, placeholderNoIncrement, withoutTransform);
                  row[j] = primitive;
                  placeholders += j === 0 ? placeholder(value) : `,${placeholder(value)}`;
                }
                placeholders += ")";
              }
              const [s, b] = this.onInsert(keys.map(_ => this.onIdentifier(_, withoutTransform)), placeholders, values, typeof segment.returningIdentifier === "string" ? [segment.returningIdentifier, []] : segment.returningIdentifier ? this.compile(segment.returningIdentifier, withoutTransform, placeholder) : undefined);
              sql += s;
              binds.push.apply(binds, b);
            } else {
              let placeholders = "";
              for (let i = 0; i < segment.value.length; i++) {
                placeholders += i === 0 ? "(" : ",(";
                for (let j = 0; j < keys.length; j++) {
                  const value = segment.value[i][keys[j]];
                  const primitive = extractPrimitive(value, this.onCustom, placeholderNoIncrement, withoutTransform);
                  binds.push(primitive);
                  placeholders += j === 0 ? placeholder(value) : `,${placeholder(value)}`;
                }
                placeholders += ")";
              }
              sql += `${generateColumns(keys, this.onIdentifier, withoutTransform)} VALUES ${placeholders}`;
              if (typeof segment.returningIdentifier === "string") {
                sql += ` RETURNING ${segment.returningIdentifier}`;
              } else if (segment.returningIdentifier) {
                sql += " RETURNING ";
                const [s, b] = this.compile(segment.returningIdentifier, withoutTransform, placeholder);
                sql += s;
                binds.push.apply(binds, b);
              }
            }
            break;
          }
        case "RecordUpdateHelperSingle":
          {
            let keys = Object.keys(segment.value);
            if (segment.omit.length > 0) {
              keys = keys.filter(key => !segment.omit.includes(key));
            }
            if (this.onRecordUpdateSingle) {
              const [s, b] = this.onRecordUpdateSingle(keys.map(_ => this.onIdentifier(_, withoutTransform)), keys.map(key => extractPrimitive(segment.value[key], this.onCustom, placeholderNoIncrement, withoutTransform)), typeof segment.returningIdentifier === "string" ? [segment.returningIdentifier, []] : segment.returningIdentifier ? this.compile(segment.returningIdentifier, withoutTransform, placeholder) : undefined);
              sql += s;
              binds.push.apply(binds, b);
            } else {
              for (let i = 0, len = keys.length; i < len; i++) {
                const column = this.onIdentifier(keys[i], withoutTransform);
                if (i === 0) {
                  sql += `${column} = ${placeholder(segment.value[keys[i]])}`;
                } else {
                  sql += `, ${column} = ${placeholder(segment.value[keys[i]])}`;
                }
                binds.push(extractPrimitive(segment.value[keys[i]], this.onCustom, placeholderNoIncrement, withoutTransform));
              }
              if (typeof segment.returningIdentifier === "string") {
                if (this.dialect === "mssql") {
                  sql += ` OUTPUT ${segment.returningIdentifier === "*" ? "INSERTED.*" : segment.returningIdentifier}`;
                } else {
                  sql += ` RETURNING ${segment.returningIdentifier}`;
                }
              } else if (segment.returningIdentifier) {
                sql += this.dialect === "mssql" ? " OUTPUT " : " RETURNING ";
                const [s, b] = this.compile(segment.returningIdentifier, withoutTransform, placeholder);
                sql += s;
                binds.push.apply(binds, b);
              }
            }
            break;
          }
        case "RecordUpdateHelper":
          {
            const keys = Object.keys(segment.value[0]);
            const values = new Array(segment.value.length);
            let placeholders = "";
            for (let i = 0; i < segment.value.length; i++) {
              const row = new Array(keys.length);
              values[i] = row;
              placeholders += i === 0 ? "(" : ",(";
              for (let j = 0; j < keys.length; j++) {
                const key = keys[j];
                const value = segment.value[i][key];
                row[j] = extractPrimitive(value, this.onCustom, placeholderNoIncrement, withoutTransform);
                placeholders += j === 0 ? placeholder(value) : `,${placeholder(value)}`;
              }
              placeholders += ")";
            }
            const [s, b] = this.onRecordUpdate(placeholders, segment.alias, generateColumns(keys, this.onIdentifier, withoutTransform), values, typeof segment.returningIdentifier === "string" ? [segment.returningIdentifier, []] : segment.returningIdentifier ? this.compile(segment.returningIdentifier, withoutTransform, placeholder) : undefined);
            sql += s;
            binds.push.apply(binds, b);
            break;
          }
        case "Custom":
          {
            const [s, b] = this.onCustom(segment, placeholder, withoutTransform);
            sql += s;
            binds.push.apply(binds, b);
            break;
          }
      }
    }
    const result = [sql, binds];
    if (placeholderOverride !== undefined) {
      return result;
    }
    return statement[cacheSymbol] = result;
  }
  get withoutTransform() {
    return new CompilerImpl(this.dialect, this.parameterPlaceholder, this.onIdentifier, this.onRecordUpdate, this.onCustom, this.onInsert, this.onRecordUpdateSingle, true);
  }
}
/** @internal */
export const makeCompiler = options => new CompilerImpl(options.dialect, options.placeholder, options.onIdentifier, options.onRecordUpdate, options.onCustom, options.onInsert, options.onRecordUpdateSingle);
const makePlaceholdersArray = evaluate => values => {
  if (values.length === 0) {
    return "";
  }
  let result = evaluate(values[0]);
  for (let i = 1; i < values.length; i++) {
    result += `,${evaluate(values[i])}`;
  }
  return result;
};
const generateColumns = (keys, escape, withoutTransform) => {
  if (keys.length === 0) {
    return "()";
  }
  let str = `(${escape(keys[0], withoutTransform)}`;
  for (let i = 1; i < keys.length; i++) {
    str += `,${escape(keys[i], withoutTransform)}`;
  }
  return str + ")";
};
/** @internal */
export function defaultEscape(c) {
  const re = new RegExp(c, "g");
  const double = c + c;
  const dot = c + "." + c;
  return function (str) {
    return c + str.replace(re, double).replace(/\./g, dot) + c;
  };
}
/** @internal */
export const primitiveKind = value => {
  switch (typeof value) {
    case "string":
      return "string";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "bigint":
      return "bigint";
    case "undefined":
      return "null";
  }
  if (value === null) {
    return "null";
  } else if (value instanceof Date) {
    return "Date";
  } else if (value instanceof Uint8Array) {
    return "Uint8Array";
  } else if (value instanceof Int8Array) {
    return "Int8Array";
  }
  return "string";
};
const extractPrimitive = (value, onCustom, placeholder, withoutTransform) => {
  if (value === undefined) {
    return null;
  } else if (isFragment(value)) {
    const head = value.segments[0];
    if (head._tag === "Custom") {
      const compiled = onCustom(head, placeholder, withoutTransform);
      return compiled[1][0] ?? null;
    } else if (head._tag === "Parameter") {
      return head.value;
    }
    return null;
  }
  return value;
};
const escapeSqlite = /*#__PURE__*/defaultEscape("\"");
/** @internal */
export const makeCompilerSqlite = transform => makeCompiler({
  dialect: "sqlite",
  placeholder(_) {
    return "?";
  },
  onIdentifier: transform ? function (value, withoutTransform) {
    return withoutTransform ? escapeSqlite(value) : escapeSqlite(transform(value));
  } : escapeSqlite,
  onRecordUpdate() {
    return ["", []];
  },
  onCustom() {
    return ["", []];
  }
});
/** @internal */
export const defaultTransforms = (transformer, nested = true) => {
  const transformValue = value => {
    if (Array.isArray(value)) {
      if (value.length === 0 || value[0].constructor !== Object) {
        return value;
      }
      return array(value);
    } else if (value?.constructor === Object) {
      return transformObject(value);
    }
    return value;
  };
  const transformObject = obj => {
    const newObj = {};
    for (const key in obj) {
      newObj[transformer(key)] = transformValue(obj[key]);
    }
    return newObj;
  };
  const transformArrayNested = rows => {
    const newRows = new Array(rows.length);
    for (let i = 0, len = rows.length; i < len; i++) {
      const row = rows[i];
      if (Array.isArray(row)) {
        newRows[i] = transformArrayNested(row);
      } else {
        const obj = {};
        for (const key in row) {
          obj[transformer(key)] = transformValue(row[key]);
        }
        newRows[i] = obj;
      }
    }
    return newRows;
  };
  const transformArray = rows => {
    const newRows = new Array(rows.length);
    for (let i = 0, len = rows.length; i < len; i++) {
      const row = rows[i];
      if (Array.isArray(row)) {
        newRows[i] = transformArray(row);
      } else {
        const obj = {};
        for (const key in row) {
          obj[transformer(key)] = row[key];
        }
        newRows[i] = obj;
      }
    }
    return newRows;
  };
  const array = nested ? transformArrayNested : transformArray;
  return {
    value: transformValue,
    object: transformObject,
    array
  };
};
//# sourceMappingURL=statement.js.map