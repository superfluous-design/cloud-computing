"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeRepository = exports.makeDataLoaders = exports.fields = exports.fieldFromKey = exports.fieldEvolve = exports.extract = exports.UuidV4WithGenerate = exports.UuidV4Insert = exports.Union = exports.Struct = exports.Sensitive = exports.Override = exports.JsonFromString = exports.GeneratedByApp = exports.Generated = exports.FieldOption = exports.FieldOnly = exports.FieldExcept = exports.Field = exports.DateWithNow = exports.DateTimeWithNow = exports.DateTimeUpdateFromNumber = exports.DateTimeUpdateFromDate = exports.DateTimeUpdate = exports.DateTimeInsertFromNumber = exports.DateTimeInsertFromDate = exports.DateTimeInsert = exports.DateTimeFromNumberWithNow = exports.DateTimeFromDateWithNow = exports.DateTimeFromDate = exports.Date = exports.Class = exports.BooleanFromNumber = void 0;
var RRX = _interopRequireWildcard(require("@effect/experimental/RequestResolver"));
var VariantSchema = _interopRequireWildcard(require("@effect/experimental/VariantSchema"));
var DateTime = _interopRequireWildcard(require("effect/DateTime"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Option = _interopRequireWildcard(require("effect/Option"));
var ParseResult = _interopRequireWildcard(require("effect/ParseResult"));
var Schema = _interopRequireWildcard(require("effect/Schema"));
var Uuid = _interopRequireWildcard(require("uuid"));
var _SqlClient = require("./SqlClient.js");
var SqlResolver = _interopRequireWildcard(require("./SqlResolver.js"));
var SqlSchema = _interopRequireWildcard(require("./SqlSchema.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

const {
  Class,
  Field,
  FieldExcept,
  FieldOnly,
  Struct,
  Union,
  extract,
  fieldEvolve,
  fieldFromKey
} = /*#__PURE__*/VariantSchema.make({
  variants: ["select", "insert", "update", "json", "jsonCreate", "jsonUpdate"],
  defaultVariant: "select"
});
exports.fieldFromKey = fieldFromKey;
exports.fieldEvolve = fieldEvolve;
exports.extract = extract;
exports.Union = Union;
exports.Struct = Struct;
exports.FieldOnly = FieldOnly;
exports.FieldExcept = FieldExcept;
exports.Field = Field;
exports.Class = Class;
/**
 * @since 1.0.0
 * @category fields
 */
const fields = exports.fields = VariantSchema.fields;
/**
 * @since 1.0.0
 * @category overrideable
 */
const Override = exports.Override = VariantSchema.Override;
/**
 * A field that represents a column that is generated by the database.
 *
 * It is available for selection and update, but not for insertion.
 *
 * @since 1.0.0
 * @category generated
 */
const Generated = schema => Field({
  select: schema,
  update: schema,
  json: schema
});
/**
 * A field that represents a column that is generated by the application.
 *
 * It is required by the database, but not by the JSON variants.
 *
 * @since 1.0.0
 * @category generated
 */
exports.Generated = Generated;
const GeneratedByApp = schema => Field({
  select: schema,
  insert: schema,
  update: schema,
  json: schema
});
/**
 * A field that represents a sensitive value that should not be exposed in the
 * JSON variants.
 *
 * @since 1.0.0
 * @category sensitive
 */
exports.GeneratedByApp = GeneratedByApp;
const Sensitive = schema => Field({
  select: schema,
  insert: schema,
  update: schema
});
/**
 * Convert a field to one that is optional for all variants.
 *
 * For the database variants, it will accept `null`able values.
 * For the JSON variants, it will also accept missing keys.
 *
 * @since 1.0.0
 * @category optional
 */
exports.Sensitive = Sensitive;
const FieldOption = exports.FieldOption = /*#__PURE__*/fieldEvolve({
  select: Schema.OptionFromNullOr,
  insert: Schema.OptionFromNullOr,
  update: Schema.OptionFromNullOr,
  json: /*#__PURE__*/Schema.optionalWith({
    as: "Option"
  }),
  jsonCreate: /*#__PURE__*/Schema.optionalWith({
    as: "Option",
    nullable: true
  }),
  jsonUpdate: /*#__PURE__*/Schema.optionalWith({
    as: "Option",
    nullable: true
  })
});
/**
 * @since 1.0.0
 * @category date & time
 */
const DateTimeFromDate = exports.DateTimeFromDate = /*#__PURE__*/Schema.transform(Schema.ValidDateFromSelf, Schema.DateTimeUtcFromSelf, {
  decode: DateTime.unsafeFromDate,
  encode: DateTime.toDateUtc
});
/**
 * A schema for a `DateTime.Utc` that is serialized as a date string in the
 * format `YYYY-MM-DD`.
 *
 * @since 1.0.0
 * @category date & time
 */
const Date = exports.Date = /*#__PURE__*/Schema.transformOrFail(Schema.String, Schema.DateTimeUtcFromSelf, {
  decode: (s, _, ast) => DateTime.make(s).pipe(Option.map(DateTime.removeTime), Option.match({
    onNone: () => ParseResult.fail(new ParseResult.Type(ast, s)),
    onSome: dt => ParseResult.succeed(dt)
  })),
  encode: dt => ParseResult.succeed(DateTime.formatIsoDate(dt))
});
/**
 * @since 1.0.0
 * @category date & time
 */
const DateWithNow = exports.DateWithNow = /*#__PURE__*/VariantSchema.Overrideable(Date, Schema.DateTimeUtcFromSelf, {
  generate: /*#__PURE__*/Option.match({
    onNone: () => Effect.map(DateTime.now, DateTime.removeTime),
    onSome: dt => Effect.succeed(DateTime.removeTime(dt))
  })
});
/**
 * @since 1.0.0
 * @category date & time
 */
const DateTimeWithNow = exports.DateTimeWithNow = /*#__PURE__*/VariantSchema.Overrideable(Schema.String, Schema.DateTimeUtcFromSelf, {
  generate: /*#__PURE__*/Option.match({
    onNone: () => Effect.map(DateTime.now, DateTime.formatIso),
    onSome: dt => Effect.succeed(DateTime.formatIso(dt))
  }),
  decode: Schema.DateTimeUtc
});
/**
 * @since 1.0.0
 * @category date & time
 */
const DateTimeFromDateWithNow = exports.DateTimeFromDateWithNow = /*#__PURE__*/VariantSchema.Overrideable(Schema.DateFromSelf, Schema.DateTimeUtcFromSelf, {
  generate: /*#__PURE__*/Option.match({
    onNone: () => Effect.map(DateTime.now, DateTime.toDateUtc),
    onSome: dt => Effect.succeed(DateTime.toDateUtc(dt))
  }),
  decode: DateTimeFromDate
});
/**
 * @since 1.0.0
 * @category date & time
 */
const DateTimeFromNumberWithNow = exports.DateTimeFromNumberWithNow = /*#__PURE__*/VariantSchema.Overrideable(Schema.Number, Schema.DateTimeUtcFromSelf, {
  generate: /*#__PURE__*/Option.match({
    onNone: () => Effect.map(DateTime.now, DateTime.toEpochMillis),
    onSome: dt => Effect.succeed(DateTime.toEpochMillis(dt))
  }),
  decode: Schema.DateTimeUtcFromNumber
});
/**
 * A field that represents a date-time value that is inserted as the current
 * `DateTime.Utc`. It is serialized as a string for the database.
 *
 * It is omitted from updates and is available for selection.
 *
 * @since 1.0.0
 * @category date & time
 */
const DateTimeInsert = exports.DateTimeInsert = /*#__PURE__*/Field({
  select: Schema.DateTimeUtc,
  insert: DateTimeWithNow,
  json: Schema.DateTimeUtc
});
/**
 * A field that represents a date-time value that is inserted as the current
 * `DateTime.Utc`. It is serialized as a `Date` for the database.
 *
 * It is omitted from updates and is available for selection.
 *
 * @since 1.0.0
 * @category date & time
 */
const DateTimeInsertFromDate = exports.DateTimeInsertFromDate = /*#__PURE__*/Field({
  select: DateTimeFromDate,
  insert: DateTimeFromDateWithNow,
  json: Schema.DateTimeUtc
});
/**
 * A field that represents a date-time value that is inserted as the current
 * `DateTime.Utc`. It is serialized as a `number`.
 *
 * It is omitted from updates and is available for selection.
 *
 * @since 1.0.0
 * @category date & time
 */
const DateTimeInsertFromNumber = exports.DateTimeInsertFromNumber = /*#__PURE__*/Field({
  select: Schema.DateTimeUtcFromNumber,
  insert: DateTimeFromNumberWithNow,
  json: Schema.DateTimeUtcFromNumber
});
/**
 * A field that represents a date-time value that is updated as the current
 * `DateTime.Utc`. It is serialized as a string for the database.
 *
 * It is set to the current `DateTime.Utc` on updates and inserts and is
 * available for selection.
 *
 * @since 1.0.0
 * @category date & time
 */
const DateTimeUpdate = exports.DateTimeUpdate = /*#__PURE__*/Field({
  select: Schema.DateTimeUtc,
  insert: DateTimeWithNow,
  update: DateTimeWithNow,
  json: Schema.DateTimeUtc
});
/**
 * A field that represents a date-time value that is updated as the current
 * `DateTime.Utc`. It is serialized as a `Date` for the database.
 *
 * It is set to the current `DateTime.Utc` on updates and inserts and is
 * available for selection.
 *
 * @since 1.0.0
 * @category date & time
 */
const DateTimeUpdateFromDate = exports.DateTimeUpdateFromDate = /*#__PURE__*/Field({
  select: DateTimeFromDate,
  insert: DateTimeFromDateWithNow,
  update: DateTimeFromDateWithNow,
  json: Schema.DateTimeUtc
});
/**
 * A field that represents a date-time value that is updated as the current
 * `DateTime.Utc`. It is serialized as a `number`.
 *
 * It is set to the current `DateTime.Utc` on updates and inserts and is
 * available for selection.
 *
 * @since 1.0.0
 * @category date & time
 */
const DateTimeUpdateFromNumber = exports.DateTimeUpdateFromNumber = /*#__PURE__*/Field({
  select: Schema.DateTimeUtcFromNumber,
  insert: DateTimeFromNumberWithNow,
  update: DateTimeFromNumberWithNow,
  json: Schema.DateTimeUtcFromNumber
});
/**
 * A field that represents a JSON value stored as text in the database.
 *
 * The "json" variants will use the object schema directly.
 *
 * @since 1.0.0
 * @category json
 */
const JsonFromString = schema => {
  const parsed = Schema.parseJson(schema);
  return Field({
    select: parsed,
    insert: parsed,
    update: parsed,
    json: schema,
    jsonCreate: schema,
    jsonUpdate: schema
  });
};
/**
 * @since 1.0.0
 * @category uuid
 */
exports.JsonFromString = JsonFromString;
const UuidV4WithGenerate = schema => VariantSchema.Overrideable(Schema.Uint8ArrayFromSelf, schema, {
  generate: Option.match({
    onNone: () => Effect.sync(() => Uuid.v4({}, new Uint8Array(16))),
    onSome: id => Effect.succeed(id)
  }),
  decode: Schema.Uint8ArrayFromSelf,
  constructorDefault: () => Uuid.v4({}, new Uint8Array(16))
});
/**
 * A field that represents a binary UUID v4 that is generated on inserts.
 *
 * @since 1.0.0
 * @category uuid
 */
exports.UuidV4WithGenerate = UuidV4WithGenerate;
const UuidV4Insert = schema => Field({
  select: schema,
  insert: UuidV4WithGenerate(schema),
  update: schema,
  json: schema
});
/**
 * A boolean parsed from 0 or 1
 *
 * @since 1.0.0
 * @category uuid
 */
exports.UuidV4Insert = UuidV4Insert;
class BooleanFromNumber extends /*#__PURE__*/Schema.transform(/*#__PURE__*/Schema.Literal(0, 1), Schema.Boolean, {
  decode: n => n === 1,
  encode: b => b ? 1 : 0
}) {}
/**
 * Create a simple CRUD repository from a model.
 *
 * @since 1.0.0
 * @category repository
 */
exports.BooleanFromNumber = BooleanFromNumber;
const makeRepository = (Model, options) => Effect.gen(function* () {
  const sql = yield* _SqlClient.SqlClient;
  const idSchema = Model.fields[options.idColumn];
  const idColumn = options.idColumn;
  const insertSchema = SqlSchema.single({
    Request: Model.insert,
    Result: Model,
    execute: request => sql.onDialectOrElse({
      mysql: () => sql`insert into ${sql(options.tableName)} ${sql.insert(request)};
select * from ${sql(options.tableName)} where ${sql(idColumn)} = LAST_INSERT_ID();`.unprepared.pipe(Effect.map(([, results]) => results)),
      orElse: () => sql`insert into ${sql(options.tableName)} ${sql.insert(request).returning("*")}`
    })
  });
  const insert = insert => insertSchema(insert).pipe(Effect.orDie, Effect.withSpan(`${options.spanPrefix}.insert`, {
    captureStackTrace: false,
    attributes: {
      insert
    }
  }));
  const insertVoidSchema = SqlSchema.void({
    Request: Model.insert,
    execute: request => sql`insert into ${sql(options.tableName)} ${sql.insert(request)}`
  });
  const insertVoid = insert => insertVoidSchema(insert).pipe(Effect.orDie, Effect.withSpan(`${options.spanPrefix}.insertVoid`, {
    captureStackTrace: false,
    attributes: {
      insert
    }
  }));
  const updateSchema = SqlSchema.single({
    Request: Model.update,
    Result: Model,
    execute: request => sql.onDialectOrElse({
      mysql: () => sql`update ${sql(options.tableName)} set ${sql.update(request, [idColumn])} where ${sql(idColumn)} = ${request[idColumn]};
select * from ${sql(options.tableName)} where ${sql(idColumn)} = ${request[idColumn]};`.unprepared.pipe(Effect.map(([, results]) => results)),
      orElse: () => sql`update ${sql(options.tableName)} set ${sql.update(request, [idColumn])} where ${sql(idColumn)} = ${request[idColumn]} returning *`
    })
  });
  const update = update => updateSchema(update).pipe(Effect.orDie, Effect.withSpan(`${options.spanPrefix}.update`, {
    captureStackTrace: false,
    attributes: {
      update
    }
  }));
  const updateVoidSchema = SqlSchema.void({
    Request: Model.update,
    execute: request => sql`update ${sql(options.tableName)} set ${sql.update(request, [idColumn])} where ${sql(idColumn)} = ${request[idColumn]}`
  });
  const updateVoid = update => updateVoidSchema(update).pipe(Effect.orDie, Effect.withSpan(`${options.spanPrefix}.updateVoid`, {
    captureStackTrace: false,
    attributes: {
      update
    }
  }));
  const findByIdSchema = SqlSchema.findOne({
    Request: idSchema,
    Result: Model,
    execute: id => sql`select * from ${sql(options.tableName)} where ${sql(idColumn)} = ${id}`
  });
  const findById = id => findByIdSchema(id).pipe(Effect.orDie, Effect.withSpan(`${options.spanPrefix}.findById`, {
    captureStackTrace: false,
    attributes: {
      id
    }
  }));
  const deleteSchema = SqlSchema.void({
    Request: idSchema,
    execute: id => sql`delete from ${sql(options.tableName)} where ${sql(idColumn)} = ${id}`
  });
  const delete_ = id => deleteSchema(id).pipe(Effect.orDie, Effect.withSpan(`${options.spanPrefix}.delete`, {
    captureStackTrace: false,
    attributes: {
      id
    }
  }));
  return {
    insert,
    insertVoid,
    update,
    updateVoid,
    findById,
    delete: delete_
  };
});
/**
 * Create some simple data loaders from a model.
 *
 * @since 1.0.0
 * @category repository
 */
exports.makeRepository = makeRepository;
const makeDataLoaders = (Model, options) => Effect.gen(function* () {
  const sql = yield* _SqlClient.SqlClient;
  const idSchema = Model.fields[options.idColumn];
  const idColumn = options.idColumn;
  const insertResolver = yield* SqlResolver.ordered(`${options.spanPrefix}/insert`, {
    Request: Model.insert,
    Result: Model,
    execute: request => sql.onDialectOrElse({
      mysql: () => Effect.forEach(request, request => sql`insert into ${sql(options.tableName)} ${sql.insert(request)};
select * from ${sql(options.tableName)} where ${sql(idColumn)} = LAST_INSERT_ID();`.unprepared.pipe(Effect.map(([, results]) => results[0])), {
        concurrency: 10
      }),
      orElse: () => sql`insert into ${sql(options.tableName)} ${sql.insert(request).returning("*")}`
    })
  });
  const insertLoader = yield* RRX.dataLoader(insertResolver, {
    window: options.window,
    maxBatchSize: options.maxBatchSize
  });
  const insertExecute = insertResolver.makeExecute(insertLoader);
  const insert = insert => insertExecute(insert).pipe(Effect.orDie, Effect.withSpan(`${options.spanPrefix}.insert`, {
    captureStackTrace: false,
    attributes: {
      insert
    }
  }));
  const insertVoidResolver = yield* SqlResolver.void(`${options.spanPrefix}/insertVoid`, {
    Request: Model.insert,
    execute: request => sql`insert into ${sql(options.tableName)} ${sql.insert(request)}`
  });
  const insertVoidLoader = yield* RRX.dataLoader(insertVoidResolver, {
    window: options.window,
    maxBatchSize: options.maxBatchSize
  });
  const insertVoidExecute = insertVoidResolver.makeExecute(insertVoidLoader);
  const insertVoid = insert => insertVoidExecute(insert).pipe(Effect.orDie, Effect.withSpan(`${options.spanPrefix}.insertVoid`, {
    captureStackTrace: false,
    attributes: {
      insert
    }
  }));
  const findByIdResolver = yield* SqlResolver.findById(`${options.spanPrefix}/findById`, {
    Id: idSchema,
    Result: Model,
    ResultId(request) {
      return request[idColumn];
    },
    execute: ids => sql`select * from ${sql(options.tableName)} where ${sql.in(idColumn, ids)}`
  });
  const findByIdLoader = yield* RRX.dataLoader(findByIdResolver, {
    window: options.window,
    maxBatchSize: options.maxBatchSize
  });
  const findByIdExecute = findByIdResolver.makeExecute(findByIdLoader);
  const findById = id => findByIdExecute(id).pipe(Effect.orDie, Effect.withSpan(`${options.spanPrefix}.findById`, {
    captureStackTrace: false,
    attributes: {
      id
    }
  }));
  const deleteResolver = yield* SqlResolver.void(`${options.spanPrefix}/delete`, {
    Request: idSchema,
    execute: ids => sql`delete from ${sql(options.tableName)} where ${sql.in(idColumn, ids)}`
  });
  const deleteLoader = yield* RRX.dataLoader(deleteResolver, {
    window: options.window,
    maxBatchSize: options.maxBatchSize
  });
  const deleteExecute = deleteResolver.makeExecute(deleteLoader);
  const delete_ = id => deleteExecute(id).pipe(Effect.orDie, Effect.withSpan(`${options.spanPrefix}.delete`, {
    captureStackTrace: false,
    attributes: {
      id
    }
  }));
  return {
    insert,
    insertVoid,
    findById,
    delete: delete_
  };
});
exports.makeDataLoaders = makeDataLoaders;
//# sourceMappingURL=Model.js.map