"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerProducer = exports.makeProducer = exports.layer = exports.MetricProducerImpl = void 0;
var _api = require("@opentelemetry/api");
var _sdkMetrics = require("@opentelemetry/sdk-metrics");
var Arr = _interopRequireWildcard(require("effect/Array"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Metric = _interopRequireWildcard(require("effect/Metric"));
var MetricKeyType = _interopRequireWildcard(require("effect/MetricKeyType"));
var MetricState = _interopRequireWildcard(require("effect/MetricState"));
var Option = _interopRequireWildcard(require("effect/Option"));
var Resource = _interopRequireWildcard(require("../Resource.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
const sdkName = "@effect/opentelemetry/Metrics";
/** @internal */
class MetricProducerImpl {
  resource;
  constructor(resource) {
    this.resource = resource;
  }
  startTimes = /*#__PURE__*/new Map();
  startTimeFor(name, hrTime) {
    if (this.startTimes.has(name)) {
      return this.startTimes.get(name);
    }
    this.startTimes.set(name, hrTime);
    return hrTime;
  }
  collect(_options) {
    const snapshot = Metric.unsafeSnapshot();
    const hrTimeNow = currentHrTime();
    const metricData = [];
    const metricDataByName = new Map();
    const addMetricData = data => {
      metricData.push(data);
      metricDataByName.set(data.descriptor.name, data);
    };
    for (let i = 0, len = snapshot.length; i < len; i++) {
      const {
        metricKey,
        metricState
      } = snapshot[i];
      const attributes = Arr.reduce(metricKey.tags, {}, (acc, label) => {
        acc[label.key] = label.value;
        return acc;
      });
      const descriptor = descriptorFromKey(metricKey, attributes);
      const startTime = this.startTimeFor(descriptor.name, hrTimeNow);
      if (MetricState.isCounterState(metricState)) {
        const dataPoint = {
          startTime,
          endTime: hrTimeNow,
          attributes,
          value: Number(metricState.count)
        };
        if (metricDataByName.has(descriptor.name)) {
          metricDataByName.get(descriptor.name).dataPoints.push(dataPoint);
        } else {
          addMetricData({
            dataPointType: _sdkMetrics.DataPointType.SUM,
            descriptor,
            isMonotonic: descriptor.type === _sdkMetrics.InstrumentType.COUNTER,
            aggregationTemporality: _sdkMetrics.AggregationTemporality.CUMULATIVE,
            dataPoints: [dataPoint]
          });
        }
      } else if (MetricState.isGaugeState(metricState)) {
        const dataPoint = {
          startTime,
          endTime: hrTimeNow,
          attributes,
          value: Number(metricState.value)
        };
        if (metricDataByName.has(descriptor.name)) {
          metricDataByName.get(descriptor.name).dataPoints.push(dataPoint);
        } else {
          addMetricData({
            dataPointType: _sdkMetrics.DataPointType.GAUGE,
            descriptor,
            aggregationTemporality: _sdkMetrics.AggregationTemporality.CUMULATIVE,
            dataPoints: [dataPoint]
          });
        }
      } else if (MetricState.isHistogramState(metricState)) {
        const size = metricState.buckets.length;
        const buckets = {
          boundaries: Arr.allocate(size - 1),
          counts: Arr.allocate(size)
        };
        let i = 0;
        let prev = 0;
        for (const [boundary, value] of metricState.buckets) {
          if (i < size - 1) {
            buckets.boundaries[i] = boundary;
          }
          buckets.counts[i] = value - prev;
          prev = value;
          i++;
        }
        const dataPoint = {
          startTime,
          endTime: hrTimeNow,
          attributes,
          value: {
            buckets,
            count: metricState.count,
            min: metricState.min,
            max: metricState.max,
            sum: metricState.sum
          }
        };
        if (metricDataByName.has(descriptor.name)) {
          metricDataByName.get(descriptor.name).dataPoints.push(dataPoint);
        } else {
          addMetricData({
            dataPointType: _sdkMetrics.DataPointType.HISTOGRAM,
            descriptor,
            aggregationTemporality: _sdkMetrics.AggregationTemporality.CUMULATIVE,
            dataPoints: [dataPoint]
          });
        }
      } else if (MetricState.isFrequencyState(metricState)) {
        const dataPoints = [];
        for (const [freqKey, value] of metricState.occurrences) {
          dataPoints.push({
            startTime,
            endTime: hrTimeNow,
            attributes: {
              ...attributes,
              key: freqKey
            },
            value
          });
        }
        if (metricDataByName.has(descriptor.name)) {
          // eslint-disable-next-line no-restricted-syntax
          metricDataByName.get(descriptor.name).dataPoints.push(...dataPoints);
        } else {
          addMetricData({
            dataPointType: _sdkMetrics.DataPointType.SUM,
            descriptor: descriptorFromKey(metricKey, attributes),
            aggregationTemporality: _sdkMetrics.AggregationTemporality.CUMULATIVE,
            isMonotonic: true,
            dataPoints
          });
        }
      } else if (MetricState.isSummaryState(metricState)) {
        const dataPoints = [{
          startTime,
          endTime: hrTimeNow,
          attributes: {
            ...attributes,
            quantile: "min"
          },
          value: metricState.min
        }];
        for (const [quantile, value] of metricState.quantiles) {
          dataPoints.push({
            startTime,
            endTime: hrTimeNow,
            attributes: {
              ...attributes,
              quantile: quantile.toString()
            },
            value: value._tag === "Some" ? value.value : 0
          });
        }
        dataPoints.push({
          startTime,
          endTime: hrTimeNow,
          attributes: {
            ...attributes,
            quantile: "max"
          },
          value: metricState.max
        });
        const countDataPoint = {
          startTime,
          endTime: hrTimeNow,
          attributes,
          value: metricState.count
        };
        const sumDataPoint = {
          startTime,
          endTime: hrTimeNow,
          attributes,
          value: metricState.sum
        };
        if (metricDataByName.has(`${descriptor.name}_quantiles`)) {
          // eslint-disable-next-line no-restricted-syntax
          metricDataByName.get(`${descriptor.name}_quantiles`).dataPoints.push(...dataPoints);
          metricDataByName.get(`${descriptor.name}_count`).dataPoints.push(countDataPoint);
          metricDataByName.get(`${descriptor.name}_sum`).dataPoints.push(sumDataPoint);
        } else {
          addMetricData({
            dataPointType: _sdkMetrics.DataPointType.SUM,
            descriptor: descriptorFromKey(metricKey, attributes, "quantiles"),
            aggregationTemporality: _sdkMetrics.AggregationTemporality.CUMULATIVE,
            isMonotonic: false,
            dataPoints
          });
          addMetricData({
            dataPointType: _sdkMetrics.DataPointType.SUM,
            descriptor: {
              ...descriptorMeta(metricKey, "count"),
              unit: "1",
              type: _sdkMetrics.InstrumentType.COUNTER,
              valueType: _api.ValueType.INT
            },
            aggregationTemporality: _sdkMetrics.AggregationTemporality.CUMULATIVE,
            isMonotonic: true,
            dataPoints: [countDataPoint]
          });
          addMetricData({
            dataPointType: _sdkMetrics.DataPointType.SUM,
            descriptor: {
              ...descriptorMeta(metricKey, "sum"),
              unit: "1",
              type: _sdkMetrics.InstrumentType.COUNTER,
              valueType: _api.ValueType.DOUBLE
            },
            aggregationTemporality: _sdkMetrics.AggregationTemporality.CUMULATIVE,
            isMonotonic: true,
            dataPoints: [sumDataPoint]
          });
        }
      }
    }
    return Promise.resolve({
      resourceMetrics: {
        resource: this.resource,
        scopeMetrics: [{
          scope: {
            name: sdkName
          },
          metrics: metricData
        }]
      },
      errors: []
    });
  }
}
exports.MetricProducerImpl = MetricProducerImpl;
const descriptorMeta = (metricKey, suffix) => ({
  name: suffix ? `${metricKey.name}_${suffix}` : metricKey.name,
  description: Option.getOrElse(metricKey.description, () => ""),
  advice: {}
});
const descriptorFromKey = (metricKey, tags, suffix) => ({
  ...descriptorMeta(metricKey, suffix),
  unit: tags.unit ?? tags.time_unit ?? "1",
  type: instrumentTypeFromKey(metricKey),
  valueType: "bigint" in metricKey.keyType && metricKey.keyType.bigint === true ? _api.ValueType.INT : _api.ValueType.DOUBLE
});
const instrumentTypeFromKey = key => {
  if (MetricKeyType.isHistogramKey(key.keyType)) {
    return _sdkMetrics.InstrumentType.HISTOGRAM;
  } else if (MetricKeyType.isGaugeKey(key.keyType)) {
    return _sdkMetrics.InstrumentType.OBSERVABLE_GAUGE;
  } else if (MetricKeyType.isFrequencyKey(key.keyType)) {
    return _sdkMetrics.InstrumentType.COUNTER;
  } else if (MetricKeyType.isCounterKey(key.keyType) && key.keyType.incremental) {
    return _sdkMetrics.InstrumentType.COUNTER;
  }
  return _sdkMetrics.InstrumentType.UP_DOWN_COUNTER;
};
const currentHrTime = () => {
  const now = Date.now();
  return [Math.floor(now / 1000), now % 1000 * 1000000];
};
/** @internal */
const makeProducer = exports.makeProducer = /*#__PURE__*/Effect.map(Resource.Resource, resource => new MetricProducerImpl(resource));
/** @internal */
const registerProducer = (self, metricReader, options) => Effect.acquireRelease(Effect.sync(() => {
  const reader = metricReader();
  const readers = Array.isArray(reader) ? reader : [reader];
  readers.forEach(reader => reader.setMetricProducer(self));
  return readers;
}), readers => Effect.promise(() => Promise.all(readers.map(reader => reader.shutdown()))).pipe(Effect.ignoreLogged, Effect.interruptible, Effect.timeoutOption(options?.shutdownTimeout ?? 3000)));
/** @internal */
exports.registerProducer = registerProducer;
const layer = (evaluate, options) => Layer.scopedDiscard(Effect.flatMap(makeProducer, producer => registerProducer(producer, evaluate, options)));
exports.layer = layer;
//# sourceMappingURL=metrics.js.map