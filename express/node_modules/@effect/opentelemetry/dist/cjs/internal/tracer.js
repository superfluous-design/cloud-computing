"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withSpanContext = exports.traceStateTag = exports.traceFlagsTag = exports.makeExternalSpan = exports.make = exports.layerWithoutOtelTracer = exports.layerTracer = exports.layerGlobalTracer = exports.layerGlobalProvider = exports.layerGlobal = exports.layer = exports.currentOtelSpan = exports.TracerProvider = exports.Tracer = exports.OtelSpan = void 0;
var OtelApi = _interopRequireWildcard(require("@opentelemetry/api"));
var Cause = _interopRequireWildcard(require("effect/Cause"));
var Context = _interopRequireWildcard(require("effect/Context"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var _Function = require("effect/Function");
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Option = _interopRequireWildcard(require("effect/Option"));
var EffectTracer = _interopRequireWildcard(require("effect/Tracer"));
var _Resource = require("../Resource.js");
var _utils = require("./utils.js");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
const OtelSpanTypeId = /*#__PURE__*/Symbol.for("@effect/opentelemetry/Tracer/OtelSpan");
const kindMap = {
  "internal": OtelApi.SpanKind.INTERNAL,
  "client": OtelApi.SpanKind.CLIENT,
  "server": OtelApi.SpanKind.SERVER,
  "producer": OtelApi.SpanKind.PRODUCER,
  "consumer": OtelApi.SpanKind.CONSUMER
};
/** @internal */
class OtelSpan {
  name;
  parent;
  context;
  links;
  kind;
  [OtelSpanTypeId];
  _tag = "Span";
  span;
  spanId;
  traceId;
  attributes = /*#__PURE__*/new Map();
  sampled;
  status;
  constructor(contextApi, tracer, name, parent, context, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context;
    this.links = links;
    this.kind = kind;
    this[OtelSpanTypeId] = OtelSpanTypeId;
    const active = contextApi.active();
    this.span = tracer.startSpan(name, {
      startTime: (0, _utils.nanosToHrTime)(startTime),
      links: links.length > 0 ? links.map(link => ({
        context: makeSpanContext(link.span),
        attributes: (0, _utils.recordToAttributes)(link.attributes)
      })) : undefined,
      kind: kindMap[this.kind]
    }, parent._tag === "Some" ? populateContext(active, parent.value, context) : OtelApi.trace.deleteSpan(active));
    const spanContext = this.span.spanContext();
    this.spanId = spanContext.spanId;
    this.traceId = spanContext.traceId;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.sampled = (spanContext.traceFlags & OtelApi.TraceFlags.SAMPLED) === OtelApi.TraceFlags.SAMPLED;
  }
  attribute(key, value) {
    this.span.setAttribute(key, (0, _utils.unknownToAttributeValue)(value));
    this.attributes.set(key, value);
  }
  addLinks(links) {
    // eslint-disable-next-line no-restricted-syntax
    this.links.push(...links);
    this.span.addLinks(links.map(link => ({
      context: makeSpanContext(link.span),
      attributes: (0, _utils.recordToAttributes)(link.attributes)
    })));
  }
  end(endTime, exit) {
    const hrTime = (0, _utils.nanosToHrTime)(endTime);
    this.status = {
      _tag: "Ended",
      endTime,
      exit,
      startTime: this.status.startTime
    };
    if (exit._tag === "Success") {
      this.span.setStatus({
        code: OtelApi.SpanStatusCode.OK
      });
    } else {
      if (Cause.isInterruptedOnly(exit.cause)) {
        this.span.setStatus({
          code: OtelApi.SpanStatusCode.OK,
          message: Cause.pretty(exit.cause)
        });
        this.span.setAttribute("span.label", "⚠︎ Interrupted");
        this.span.setAttribute("status.interrupted", true);
      } else {
        const firstError = Cause.prettyErrors(exit.cause)[0];
        if (firstError) {
          firstError.stack = Cause.pretty(exit.cause, {
            renderErrorCause: true
          });
          this.span.recordException(firstError, hrTime);
          this.span.setStatus({
            code: OtelApi.SpanStatusCode.ERROR,
            message: firstError.message
          });
        } else {
          // empty cause means no error
          this.span.setStatus({
            code: OtelApi.SpanStatusCode.OK
          });
        }
      }
    }
    this.span.end(hrTime);
  }
  event(name, startTime, attributes) {
    this.span.addEvent(name, attributes ? (0, _utils.recordToAttributes)(attributes) : undefined, (0, _utils.nanosToHrTime)(startTime));
  }
}
/** @internal */
exports.OtelSpan = OtelSpan;
const TracerProvider = exports.TracerProvider = /*#__PURE__*/Context.GenericTag("@effect/opentelemetry/Tracer/OtelTracerProvider");
/** @internal */
const Tracer = exports.Tracer = /*#__PURE__*/Context.GenericTag("@effect/opentelemetry/Tracer/OtelTracer");
/** @internal */
const make = exports.make = /*#__PURE__*/Effect.map(Tracer, tracer => EffectTracer.make({
  span(name, parent, context, links, startTime, kind) {
    return new OtelSpan(OtelApi.context, tracer, name, parent, context, links.slice(), startTime, kind);
  },
  context(execution, fiber) {
    const currentSpan = fiber.currentSpan;
    if (currentSpan === undefined) {
      return execution();
    }
    return OtelApi.context.with(populateContext(OtelApi.context.active(), currentSpan), execution);
  }
}));
/** @internal */
const traceFlagsTag = exports.traceFlagsTag = /*#__PURE__*/Context.GenericTag("@effect/opentelemetry/Tracer/OtelTraceFlags");
/** @internal */
const traceStateTag = exports.traceStateTag = /*#__PURE__*/Context.GenericTag("@effect/opentelemetry/Tracer/OtelTraceState");
/** @internal */
const makeExternalSpan = options => {
  let context = Context.empty();
  if (options.traceFlags) {
    context = Context.add(context, traceFlagsTag, options.traceFlags);
  }
  if (typeof options.traceState === "string") {
    context = Option.match(createTraceState(options.traceState), {
      onNone: () => context,
      onSome: traceState => Context.add(context, traceStateTag, traceState)
    });
  } else if (options.traceState) {
    context = Context.add(context, traceStateTag, options.traceState);
  }
  return {
    _tag: "ExternalSpan",
    traceId: options.traceId,
    spanId: options.spanId,
    sampled: options.traceFlags ? (options.traceFlags & OtelApi.TraceFlags.SAMPLED) === OtelApi.TraceFlags.SAMPLED : true,
    context
  };
};
/** @internal */
exports.makeExternalSpan = makeExternalSpan;
const currentOtelSpan = exports.currentOtelSpan = /*#__PURE__*/Effect.flatMap(Effect.currentSpan, span => {
  if (OtelSpanTypeId in span) {
    return Effect.succeed(span.span);
  }
  return Effect.fail(new Cause.NoSuchElementException());
});
/** @internal */
const layerGlobalProvider = exports.layerGlobalProvider = /*#__PURE__*/Layer.sync(TracerProvider, () => OtelApi.trace.getTracerProvider());
/** @internal */
const layerTracer = exports.layerTracer = /*#__PURE__*/Layer.effect(Tracer, /*#__PURE__*/Effect.flatMap(/*#__PURE__*/Effect.zip(_Resource.Resource, TracerProvider), ([resource, provider]) => Effect.sync(() => provider.getTracer(resource.attributes["service.name"], resource.attributes["service.version"]))));
/** @internal */
const layerGlobalTracer = exports.layerGlobalTracer = /*#__PURE__*/layerTracer.pipe(/*#__PURE__*/Layer.provide(layerGlobalProvider));
/** @internal */
const layerGlobal = exports.layerGlobal = /*#__PURE__*/Layer.unwrapEffect(Effect.map(make, Layer.setTracer)).pipe(/*#__PURE__*/Layer.provideMerge(layerGlobalTracer));
/** @internal */
const layerWithoutOtelTracer = exports.layerWithoutOtelTracer = /*#__PURE__*/Layer.unwrapEffect(/*#__PURE__*/Effect.map(make, Layer.setTracer));
/** @internal */
const layer = exports.layer = /*#__PURE__*/layerWithoutOtelTracer.pipe(/*#__PURE__*/Layer.provideMerge(layerTracer));
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
const createTraceState = /*#__PURE__*/Option.liftThrowable(OtelApi.createTraceState);
const populateContext = (otelContext, span, context) => span instanceof OtelSpan ? OtelApi.trace.setSpan(otelContext, span.span) : OtelApi.trace.setSpanContext(otelContext, makeSpanContext(span, context));
const makeSpanContext = (span, context) => ({
  spanId: span.spanId,
  traceId: span.traceId,
  isRemote: span._tag === "ExternalSpan",
  traceFlags: Option.getOrElse(context ? extractTraceTag(span, context, traceFlagsTag) : Context.getOption(span.context, traceFlagsTag), () => OtelApi.TraceFlags.SAMPLED),
  traceState: Option.getOrUndefined(context ? extractTraceTag(span, context, traceStateTag) : Context.getOption(span.context, traceStateTag))
});
const extractTraceTag = (parent, context, tag) => Option.orElse(Context.getOption(context, tag), () => Context.getOption(parent.context, tag));
/** @internal */
const withSpanContext = exports.withSpanContext = /*#__PURE__*/(0, _Function.dual)(2, (effect, spanContext) => Effect.withParentSpan(effect, makeExternalSpan(spanContext)));
//# sourceMappingURL=tracer.js.map