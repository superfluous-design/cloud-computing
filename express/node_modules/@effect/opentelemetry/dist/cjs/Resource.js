"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.layerFromEnv = exports.layerEmpty = exports.layer = exports.configToAttributes = exports.Resource = void 0;
var Resources = _interopRequireWildcard(require("@opentelemetry/resources"));
var _semanticConventions = require("@opentelemetry/semantic-conventions");
var Arr = _interopRequireWildcard(require("effect/Array"));
var Config = _interopRequireWildcard(require("effect/Config"));
var _Context = require("effect/Context");
var Effect = _interopRequireWildcard(require("effect/Effect"));
var _Function = require("effect/Function");
var Layer = _interopRequireWildcard(require("effect/Layer"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 * @category tag
 */
const Resource = exports.Resource = /*#__PURE__*/(0, _Context.GenericTag)("@effect/opentelemetry/Resource");
/**
 * @since 1.0.0
 * @category layer
 */
const layer = config => Layer.succeed(Resource, Resources.resourceFromAttributes(configToAttributes(config)));
/**
 * @since 1.0.0
 * @category config
 */
exports.layer = layer;
const configToAttributes = options => {
  const attributes = {
    ...(options.attributes ?? undefined),
    [_semanticConventions.SEMRESATTRS_SERVICE_NAME]: options.serviceName,
    [_semanticConventions.SEMRESATTRS_TELEMETRY_SDK_NAME]: "@effect/opentelemetry",
    [_semanticConventions.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE]: typeof globalThis.document === "undefined" ? _semanticConventions.TELEMETRYSDKLANGUAGEVALUES_NODEJS : _semanticConventions.TELEMETRYSDKLANGUAGEVALUES_WEBJS
  };
  if (options.serviceVersion) {
    attributes[_semanticConventions.SEMRESATTRS_SERVICE_VERSION] = options.serviceVersion;
  }
  return attributes;
};
/**
 * @since 1.0.0
 * @category layer
 */
exports.configToAttributes = configToAttributes;
const layerFromEnv = additionalAttributes => Layer.effect(Resource, Effect.gen(function* () {
  const serviceName = yield* (0, _Function.pipe)(Config.string("OTEL_SERVICE_NAME"), Config.option, Effect.orDie);
  const attributes = yield* (0, _Function.pipe)(Config.string("OTEL_RESOURCE_ATTRIBUTES"), Config.withDefault(""), Config.map(s => {
    const attrs = s.split(",");
    return Arr.reduce(attrs, {}, (acc, attr) => {
      const parts = attr.split("=");
      if (parts.length !== 2) {
        return acc;
      }
      acc[parts[0].trim()] = parts[1].trim();
      return acc;
    });
  }), Effect.orDie);
  if (serviceName._tag === "Some") {
    attributes[_semanticConventions.SEMRESATTRS_SERVICE_NAME] = serviceName.value;
  }
  if (additionalAttributes) {
    Object.assign(attributes, additionalAttributes);
  }
  return Resources.resourceFromAttributes(attributes);
}));
/**
 * @since 2.0.0
 * @category layer
 */
exports.layerFromEnv = layerFromEnv;
const layerEmpty = exports.layerEmpty = /*#__PURE__*/Layer.succeed(Resource, /*#__PURE__*/Resources.emptyResource());
//# sourceMappingURL=Resource.js.map