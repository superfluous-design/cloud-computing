"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.make = exports.layerLoggerReplace = exports.layerLoggerProvider = exports.layerLoggerAdd = exports.OtelLoggerProvider = void 0;
var Otel = _interopRequireWildcard(require("@opentelemetry/sdk-logs"));
var Arr = _interopRequireWildcard(require("effect/Array"));
var Context = _interopRequireWildcard(require("effect/Context"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var FiberId = _interopRequireWildcard(require("effect/FiberId"));
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Logger = _interopRequireWildcard(require("effect/Logger"));
var _utils = require("./internal/utils.js");
var _Resource = require("./Resource.js");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category tags
 */
class OtelLoggerProvider extends /*#__PURE__*/Context.Tag("@effect/opentelemetry/Logger/OtelLoggerProvider")() {}
/**
 * @since 1.0.0
 * @category constructors
 */
exports.OtelLoggerProvider = OtelLoggerProvider;
const make = exports.make = /*#__PURE__*/Effect.gen(function* () {
  const loggerProvider = yield* OtelLoggerProvider;
  const clock = yield* Effect.clock;
  const otelLogger = loggerProvider.getLogger("@effect/opentelemetry");
  return Logger.make(options => {
    const now = options.date.getTime();
    const attributes = {
      fiberId: FiberId.threadName(options.fiberId)
    };
    for (const [key, value] of options.annotations) {
      attributes[key] = (0, _utils.unknownToAttributeValue)(value);
    }
    for (const span of options.spans) {
      attributes[`logSpan.${span.label}`] = `${now - span.startTime}ms`;
    }
    const message = Arr.ensure(options.message).map(_utils.unknownToAttributeValue);
    otelLogger.emit({
      body: message.length === 1 ? message[0] : message,
      severityText: options.logLevel.label,
      severityNumber: options.logLevel.ordinal,
      timestamp: options.date,
      observedTimestamp: clock.unsafeCurrentTimeMillis(),
      attributes
    });
  });
});
/**
 * @since 1.0.0
 * @category layers
 */
const layerLoggerAdd = exports.layerLoggerAdd = /*#__PURE__*/Logger.addEffect(make);
/**
 * @since 1.0.0
 * @category layers
 */
const layerLoggerReplace = exports.layerLoggerReplace = /*#__PURE__*/Logger.replaceEffect(Logger.defaultLogger, make);
/**
 * @since 1.0.0
 * @category layers
 */
const layerLoggerProvider = (processor, config) => Layer.scoped(OtelLoggerProvider, Effect.flatMap(_Resource.Resource, resource => Effect.acquireRelease(Effect.sync(() => {
  const provider = new Otel.LoggerProvider({
    ...(config ?? undefined),
    resource
  });
  if (Array.isArray(processor)) {
    processor.forEach(p => provider.addLogRecordProcessor(p));
  } else {
    provider.addLogRecordProcessor(processor);
  }
  return provider;
}), provider => Effect.promise(() => provider.forceFlush().then(() => provider.shutdown())).pipe(Effect.ignoreLogged, Effect.interruptible, Effect.timeoutOption(config?.shutdownTimeout ?? 3000)))));
exports.layerLoggerProvider = layerLoggerProvider;
//# sourceMappingURL=Logger.js.map