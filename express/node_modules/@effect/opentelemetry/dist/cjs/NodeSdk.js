"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.layerTracerProvider = exports.layerEmpty = exports.layer = void 0;
var _sdkTraceNode = require("@opentelemetry/sdk-trace-node");
var Effect = _interopRequireWildcard(require("effect/Effect"));
var _Function = require("effect/Function");
var Layer = _interopRequireWildcard(require("effect/Layer"));
var _utils = require("./internal/utils.js");
var Logger = _interopRequireWildcard(require("./Logger.js"));
var Metrics = _interopRequireWildcard(require("./Metrics.js"));
var Resource = _interopRequireWildcard(require("./Resource.js"));
var Tracer = _interopRequireWildcard(require("./Tracer.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 * @category layers
 */
const layerTracerProvider = (processor, config) => Layer.scoped(Tracer.OtelTracerProvider, Effect.flatMap(Resource.Resource, resource => Effect.acquireRelease(Effect.sync(() => {
  const provider = new _sdkTraceNode.NodeTracerProvider({
    ...(config ?? undefined),
    resource,
    spanProcessors: Array.isArray(processor) ? processor : [processor]
  });
  return provider;
}), provider => Effect.promise(() => provider.forceFlush().then(() => provider.shutdown())).pipe(Effect.ignoreLogged, Effect.interruptible, Effect.timeoutOption(config?.shutdownTimeout ?? 3000)))));
/**
 * @since 1.0.0
 * @category layer
 */
exports.layerTracerProvider = layerTracerProvider;
const layer = evaluate => Layer.unwrapEffect(Effect.map(Effect.isEffect(evaluate) ? evaluate : Effect.sync(evaluate), config => {
  const ResourceLive = Resource.layerFromEnv(config.resource && Resource.configToAttributes(config.resource));
  const TracerLive = (0, _utils.isNonEmpty)(config.spanProcessor) ? Layer.provide(Tracer.layer, layerTracerProvider(config.spanProcessor, {
    ...config.tracerConfig,
    shutdownTimeout: config.shutdownTimeout
  })) : Layer.empty;
  const MetricsLive = (0, _utils.isNonEmpty)(config.metricReader) ? Metrics.layer((0, _Function.constant)(config.metricReader), config) : Layer.empty;
  const LoggerLive = (0, _utils.isNonEmpty)(config.logRecordProcessor) ? Layer.provide(Logger.layerLoggerAdd, Logger.layerLoggerProvider(config.logRecordProcessor, {
    ...config.loggerProviderConfig,
    shutdownTimeout: config.shutdownTimeout
  })) : Layer.empty;
  return Layer.mergeAll(TracerLive, MetricsLive, LoggerLive).pipe(Layer.provideMerge(ResourceLive));
}));
/**
 * @since 2.0.0
 * @category layer
 */
exports.layer = layer;
const layerEmpty = exports.layerEmpty = Resource.layerEmpty;
//# sourceMappingURL=NodeSdk.js.map