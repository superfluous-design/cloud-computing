import * as OtelApi from "@opentelemetry/api";
import * as Cause from "effect/Cause";
import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import { dual } from "effect/Function";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import * as EffectTracer from "effect/Tracer";
import { Resource } from "../Resource.js";
import { nanosToHrTime, recordToAttributes, unknownToAttributeValue } from "./utils.js";
const OtelSpanTypeId = /*#__PURE__*/Symbol.for("@effect/opentelemetry/Tracer/OtelSpan");
const kindMap = {
  "internal": OtelApi.SpanKind.INTERNAL,
  "client": OtelApi.SpanKind.CLIENT,
  "server": OtelApi.SpanKind.SERVER,
  "producer": OtelApi.SpanKind.PRODUCER,
  "consumer": OtelApi.SpanKind.CONSUMER
};
/** @internal */
export class OtelSpan {
  name;
  parent;
  context;
  links;
  kind;
  [OtelSpanTypeId];
  _tag = "Span";
  span;
  spanId;
  traceId;
  attributes = /*#__PURE__*/new Map();
  sampled;
  status;
  constructor(contextApi, tracer, name, parent, context, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context;
    this.links = links;
    this.kind = kind;
    this[OtelSpanTypeId] = OtelSpanTypeId;
    const active = contextApi.active();
    this.span = tracer.startSpan(name, {
      startTime: nanosToHrTime(startTime),
      links: links.length > 0 ? links.map(link => ({
        context: makeSpanContext(link.span),
        attributes: recordToAttributes(link.attributes)
      })) : undefined,
      kind: kindMap[this.kind]
    }, parent._tag === "Some" ? populateContext(active, parent.value, context) : OtelApi.trace.deleteSpan(active));
    const spanContext = this.span.spanContext();
    this.spanId = spanContext.spanId;
    this.traceId = spanContext.traceId;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.sampled = (spanContext.traceFlags & OtelApi.TraceFlags.SAMPLED) === OtelApi.TraceFlags.SAMPLED;
  }
  attribute(key, value) {
    this.span.setAttribute(key, unknownToAttributeValue(value));
    this.attributes.set(key, value);
  }
  addLinks(links) {
    // eslint-disable-next-line no-restricted-syntax
    this.links.push(...links);
    this.span.addLinks(links.map(link => ({
      context: makeSpanContext(link.span),
      attributes: recordToAttributes(link.attributes)
    })));
  }
  end(endTime, exit) {
    const hrTime = nanosToHrTime(endTime);
    this.status = {
      _tag: "Ended",
      endTime,
      exit,
      startTime: this.status.startTime
    };
    if (exit._tag === "Success") {
      this.span.setStatus({
        code: OtelApi.SpanStatusCode.OK
      });
    } else {
      if (Cause.isInterruptedOnly(exit.cause)) {
        this.span.setStatus({
          code: OtelApi.SpanStatusCode.OK,
          message: Cause.pretty(exit.cause)
        });
        this.span.setAttribute("span.label", "⚠︎ Interrupted");
        this.span.setAttribute("status.interrupted", true);
      } else {
        const firstError = Cause.prettyErrors(exit.cause)[0];
        if (firstError) {
          firstError.stack = Cause.pretty(exit.cause, {
            renderErrorCause: true
          });
          this.span.recordException(firstError, hrTime);
          this.span.setStatus({
            code: OtelApi.SpanStatusCode.ERROR,
            message: firstError.message
          });
        } else {
          // empty cause means no error
          this.span.setStatus({
            code: OtelApi.SpanStatusCode.OK
          });
        }
      }
    }
    this.span.end(hrTime);
  }
  event(name, startTime, attributes) {
    this.span.addEvent(name, attributes ? recordToAttributes(attributes) : undefined, nanosToHrTime(startTime));
  }
}
/** @internal */
export const TracerProvider = /*#__PURE__*/Context.GenericTag("@effect/opentelemetry/Tracer/OtelTracerProvider");
/** @internal */
export const Tracer = /*#__PURE__*/Context.GenericTag("@effect/opentelemetry/Tracer/OtelTracer");
/** @internal */
export const make = /*#__PURE__*/Effect.map(Tracer, tracer => EffectTracer.make({
  span(name, parent, context, links, startTime, kind) {
    return new OtelSpan(OtelApi.context, tracer, name, parent, context, links.slice(), startTime, kind);
  },
  context(execution, fiber) {
    const currentSpan = fiber.currentSpan;
    if (currentSpan === undefined) {
      return execution();
    }
    return OtelApi.context.with(populateContext(OtelApi.context.active(), currentSpan), execution);
  }
}));
/** @internal */
export const traceFlagsTag = /*#__PURE__*/Context.GenericTag("@effect/opentelemetry/Tracer/OtelTraceFlags");
/** @internal */
export const traceStateTag = /*#__PURE__*/Context.GenericTag("@effect/opentelemetry/Tracer/OtelTraceState");
/** @internal */
export const makeExternalSpan = options => {
  let context = Context.empty();
  if (options.traceFlags) {
    context = Context.add(context, traceFlagsTag, options.traceFlags);
  }
  if (typeof options.traceState === "string") {
    context = Option.match(createTraceState(options.traceState), {
      onNone: () => context,
      onSome: traceState => Context.add(context, traceStateTag, traceState)
    });
  } else if (options.traceState) {
    context = Context.add(context, traceStateTag, options.traceState);
  }
  return {
    _tag: "ExternalSpan",
    traceId: options.traceId,
    spanId: options.spanId,
    sampled: options.traceFlags ? (options.traceFlags & OtelApi.TraceFlags.SAMPLED) === OtelApi.TraceFlags.SAMPLED : true,
    context
  };
};
/** @internal */
export const currentOtelSpan = /*#__PURE__*/Effect.flatMap(Effect.currentSpan, span => {
  if (OtelSpanTypeId in span) {
    return Effect.succeed(span.span);
  }
  return Effect.fail(new Cause.NoSuchElementException());
});
/** @internal */
export const layerGlobalProvider = /*#__PURE__*/Layer.sync(TracerProvider, () => OtelApi.trace.getTracerProvider());
/** @internal */
export const layerTracer = /*#__PURE__*/Layer.effect(Tracer, /*#__PURE__*/Effect.flatMap(/*#__PURE__*/Effect.zip(Resource, TracerProvider), ([resource, provider]) => Effect.sync(() => provider.getTracer(resource.attributes["service.name"], resource.attributes["service.version"]))));
/** @internal */
export const layerGlobalTracer = /*#__PURE__*/layerTracer.pipe(/*#__PURE__*/Layer.provide(layerGlobalProvider));
/** @internal */
export const layerGlobal = /*#__PURE__*/Layer.unwrapEffect(Effect.map(make, Layer.setTracer)).pipe(/*#__PURE__*/Layer.provideMerge(layerGlobalTracer));
/** @internal */
export const layerWithoutOtelTracer = /*#__PURE__*/Layer.unwrapEffect(/*#__PURE__*/Effect.map(make, Layer.setTracer));
/** @internal */
export const layer = /*#__PURE__*/layerWithoutOtelTracer.pipe(/*#__PURE__*/Layer.provideMerge(layerTracer));
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
const createTraceState = /*#__PURE__*/Option.liftThrowable(OtelApi.createTraceState);
const populateContext = (otelContext, span, context) => span instanceof OtelSpan ? OtelApi.trace.setSpan(otelContext, span.span) : OtelApi.trace.setSpanContext(otelContext, makeSpanContext(span, context));
const makeSpanContext = (span, context) => ({
  spanId: span.spanId,
  traceId: span.traceId,
  isRemote: span._tag === "ExternalSpan",
  traceFlags: Option.getOrElse(context ? extractTraceTag(span, context, traceFlagsTag) : Context.getOption(span.context, traceFlagsTag), () => OtelApi.TraceFlags.SAMPLED),
  traceState: Option.getOrUndefined(context ? extractTraceTag(span, context, traceStateTag) : Context.getOption(span.context, traceStateTag))
});
const extractTraceTag = (parent, context, tag) => Option.orElse(Context.getOption(context, tag), () => Context.getOption(parent.context, tag));
/** @internal */
export const withSpanContext = /*#__PURE__*/dual(2, (effect, spanContext) => Effect.withParentSpan(effect, makeExternalSpan(spanContext)));
//# sourceMappingURL=tracer.js.map