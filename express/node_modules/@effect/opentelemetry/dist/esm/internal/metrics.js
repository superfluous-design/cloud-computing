import { ValueType } from "@opentelemetry/api";
import { AggregationTemporality, DataPointType, InstrumentType } from "@opentelemetry/sdk-metrics";
import * as Arr from "effect/Array";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Metric from "effect/Metric";
import * as MetricKeyType from "effect/MetricKeyType";
import * as MetricState from "effect/MetricState";
import * as Option from "effect/Option";
import * as Resource from "../Resource.js";
const sdkName = "@effect/opentelemetry/Metrics";
/** @internal */
export class MetricProducerImpl {
  resource;
  constructor(resource) {
    this.resource = resource;
  }
  startTimes = /*#__PURE__*/new Map();
  startTimeFor(name, hrTime) {
    if (this.startTimes.has(name)) {
      return this.startTimes.get(name);
    }
    this.startTimes.set(name, hrTime);
    return hrTime;
  }
  collect(_options) {
    const snapshot = Metric.unsafeSnapshot();
    const hrTimeNow = currentHrTime();
    const metricData = [];
    const metricDataByName = new Map();
    const addMetricData = data => {
      metricData.push(data);
      metricDataByName.set(data.descriptor.name, data);
    };
    for (let i = 0, len = snapshot.length; i < len; i++) {
      const {
        metricKey,
        metricState
      } = snapshot[i];
      const attributes = Arr.reduce(metricKey.tags, {}, (acc, label) => {
        acc[label.key] = label.value;
        return acc;
      });
      const descriptor = descriptorFromKey(metricKey, attributes);
      const startTime = this.startTimeFor(descriptor.name, hrTimeNow);
      if (MetricState.isCounterState(metricState)) {
        const dataPoint = {
          startTime,
          endTime: hrTimeNow,
          attributes,
          value: Number(metricState.count)
        };
        if (metricDataByName.has(descriptor.name)) {
          metricDataByName.get(descriptor.name).dataPoints.push(dataPoint);
        } else {
          addMetricData({
            dataPointType: DataPointType.SUM,
            descriptor,
            isMonotonic: descriptor.type === InstrumentType.COUNTER,
            aggregationTemporality: AggregationTemporality.CUMULATIVE,
            dataPoints: [dataPoint]
          });
        }
      } else if (MetricState.isGaugeState(metricState)) {
        const dataPoint = {
          startTime,
          endTime: hrTimeNow,
          attributes,
          value: Number(metricState.value)
        };
        if (metricDataByName.has(descriptor.name)) {
          metricDataByName.get(descriptor.name).dataPoints.push(dataPoint);
        } else {
          addMetricData({
            dataPointType: DataPointType.GAUGE,
            descriptor,
            aggregationTemporality: AggregationTemporality.CUMULATIVE,
            dataPoints: [dataPoint]
          });
        }
      } else if (MetricState.isHistogramState(metricState)) {
        const size = metricState.buckets.length;
        const buckets = {
          boundaries: Arr.allocate(size - 1),
          counts: Arr.allocate(size)
        };
        let i = 0;
        let prev = 0;
        for (const [boundary, value] of metricState.buckets) {
          if (i < size - 1) {
            buckets.boundaries[i] = boundary;
          }
          buckets.counts[i] = value - prev;
          prev = value;
          i++;
        }
        const dataPoint = {
          startTime,
          endTime: hrTimeNow,
          attributes,
          value: {
            buckets,
            count: metricState.count,
            min: metricState.min,
            max: metricState.max,
            sum: metricState.sum
          }
        };
        if (metricDataByName.has(descriptor.name)) {
          metricDataByName.get(descriptor.name).dataPoints.push(dataPoint);
        } else {
          addMetricData({
            dataPointType: DataPointType.HISTOGRAM,
            descriptor,
            aggregationTemporality: AggregationTemporality.CUMULATIVE,
            dataPoints: [dataPoint]
          });
        }
      } else if (MetricState.isFrequencyState(metricState)) {
        const dataPoints = [];
        for (const [freqKey, value] of metricState.occurrences) {
          dataPoints.push({
            startTime,
            endTime: hrTimeNow,
            attributes: {
              ...attributes,
              key: freqKey
            },
            value
          });
        }
        if (metricDataByName.has(descriptor.name)) {
          // eslint-disable-next-line no-restricted-syntax
          metricDataByName.get(descriptor.name).dataPoints.push(...dataPoints);
        } else {
          addMetricData({
            dataPointType: DataPointType.SUM,
            descriptor: descriptorFromKey(metricKey, attributes),
            aggregationTemporality: AggregationTemporality.CUMULATIVE,
            isMonotonic: true,
            dataPoints
          });
        }
      } else if (MetricState.isSummaryState(metricState)) {
        const dataPoints = [{
          startTime,
          endTime: hrTimeNow,
          attributes: {
            ...attributes,
            quantile: "min"
          },
          value: metricState.min
        }];
        for (const [quantile, value] of metricState.quantiles) {
          dataPoints.push({
            startTime,
            endTime: hrTimeNow,
            attributes: {
              ...attributes,
              quantile: quantile.toString()
            },
            value: value._tag === "Some" ? value.value : 0
          });
        }
        dataPoints.push({
          startTime,
          endTime: hrTimeNow,
          attributes: {
            ...attributes,
            quantile: "max"
          },
          value: metricState.max
        });
        const countDataPoint = {
          startTime,
          endTime: hrTimeNow,
          attributes,
          value: metricState.count
        };
        const sumDataPoint = {
          startTime,
          endTime: hrTimeNow,
          attributes,
          value: metricState.sum
        };
        if (metricDataByName.has(`${descriptor.name}_quantiles`)) {
          // eslint-disable-next-line no-restricted-syntax
          metricDataByName.get(`${descriptor.name}_quantiles`).dataPoints.push(...dataPoints);
          metricDataByName.get(`${descriptor.name}_count`).dataPoints.push(countDataPoint);
          metricDataByName.get(`${descriptor.name}_sum`).dataPoints.push(sumDataPoint);
        } else {
          addMetricData({
            dataPointType: DataPointType.SUM,
            descriptor: descriptorFromKey(metricKey, attributes, "quantiles"),
            aggregationTemporality: AggregationTemporality.CUMULATIVE,
            isMonotonic: false,
            dataPoints
          });
          addMetricData({
            dataPointType: DataPointType.SUM,
            descriptor: {
              ...descriptorMeta(metricKey, "count"),
              unit: "1",
              type: InstrumentType.COUNTER,
              valueType: ValueType.INT
            },
            aggregationTemporality: AggregationTemporality.CUMULATIVE,
            isMonotonic: true,
            dataPoints: [countDataPoint]
          });
          addMetricData({
            dataPointType: DataPointType.SUM,
            descriptor: {
              ...descriptorMeta(metricKey, "sum"),
              unit: "1",
              type: InstrumentType.COUNTER,
              valueType: ValueType.DOUBLE
            },
            aggregationTemporality: AggregationTemporality.CUMULATIVE,
            isMonotonic: true,
            dataPoints: [sumDataPoint]
          });
        }
      }
    }
    return Promise.resolve({
      resourceMetrics: {
        resource: this.resource,
        scopeMetrics: [{
          scope: {
            name: sdkName
          },
          metrics: metricData
        }]
      },
      errors: []
    });
  }
}
const descriptorMeta = (metricKey, suffix) => ({
  name: suffix ? `${metricKey.name}_${suffix}` : metricKey.name,
  description: Option.getOrElse(metricKey.description, () => ""),
  advice: {}
});
const descriptorFromKey = (metricKey, tags, suffix) => ({
  ...descriptorMeta(metricKey, suffix),
  unit: tags.unit ?? tags.time_unit ?? "1",
  type: instrumentTypeFromKey(metricKey),
  valueType: "bigint" in metricKey.keyType && metricKey.keyType.bigint === true ? ValueType.INT : ValueType.DOUBLE
});
const instrumentTypeFromKey = key => {
  if (MetricKeyType.isHistogramKey(key.keyType)) {
    return InstrumentType.HISTOGRAM;
  } else if (MetricKeyType.isGaugeKey(key.keyType)) {
    return InstrumentType.OBSERVABLE_GAUGE;
  } else if (MetricKeyType.isFrequencyKey(key.keyType)) {
    return InstrumentType.COUNTER;
  } else if (MetricKeyType.isCounterKey(key.keyType) && key.keyType.incremental) {
    return InstrumentType.COUNTER;
  }
  return InstrumentType.UP_DOWN_COUNTER;
};
const currentHrTime = () => {
  const now = Date.now();
  return [Math.floor(now / 1000), now % 1000 * 1000000];
};
/** @internal */
export const makeProducer = /*#__PURE__*/Effect.map(Resource.Resource, resource => new MetricProducerImpl(resource));
/** @internal */
export const registerProducer = (self, metricReader, options) => Effect.acquireRelease(Effect.sync(() => {
  const reader = metricReader();
  const readers = Array.isArray(reader) ? reader : [reader];
  readers.forEach(reader => reader.setMetricProducer(self));
  return readers;
}), readers => Effect.promise(() => Promise.all(readers.map(reader => reader.shutdown()))).pipe(Effect.ignoreLogged, Effect.interruptible, Effect.timeoutOption(options?.shutdownTimeout ?? 3000)));
/** @internal */
export const layer = (evaluate, options) => Layer.scopedDiscard(Effect.flatMap(makeProducer, producer => registerProducer(producer, evaluate, options)));
//# sourceMappingURL=metrics.js.map