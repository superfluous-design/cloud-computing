import * as Cause from "effect/Cause";
import * as Duration from "effect/Duration";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import * as Tracer from "effect/Tracer";
import * as Exporter from "./internal/otlpExporter.js";
import { entriesToAttributes } from "./OtlpResource.js";
import * as OtlpResource from "./OtlpResource.js";
/**
 * @since 1.0.0
 * @category Constructors
 */
export const make = /*#__PURE__*/Effect.fnUntraced(function* (options) {
  const otelResource = OtlpResource.make(options.resource);
  const scope = {
    name: options.resource.serviceName
  };
  const exporter = yield* Exporter.make({
    label: "OtlpTracer",
    url: options.url,
    headers: options.headers,
    exportInterval: options.exportInterval ?? Duration.seconds(5),
    maxBatchSize: options.maxBatchSize ?? 1000,
    body(spans) {
      const data = {
        resourceSpans: [{
          resource: otelResource,
          scopeSpans: [{
            scope,
            spans
          }]
        }]
      };
      return data;
    },
    shutdownTimeout: options.shutdownTimeout ?? Duration.seconds(3)
  });
  return Tracer.make({
    span(name, parent, context, links, startTime, kind) {
      return makeSpan({
        name,
        parent,
        context,
        status: {
          _tag: "Started",
          startTime
        },
        attributes: new Map(),
        links,
        sampled: true,
        kind,
        export(span) {
          exporter.push(makeOtlpSpan(span));
        }
      });
    },
    context: options.context ? function (f, fiber) {
      if (fiber.currentSpan === undefined) {
        return f();
      }
      return options.context(f, fiber.currentSpan);
    } : defaultContext
  });
});
/**
 * @since 1.0.0
 * @category Layers
 */
export const layer = options => Layer.unwrapScoped(Effect.map(make(options), Layer.setTracer));
// internal
function defaultContext(f, _) {
  return f();
}
const SpanProto = {
  _tag: "Span",
  end(endTime, exit) {
    this.status = {
      _tag: "Ended",
      startTime: this.status.startTime,
      endTime,
      exit
    };
    this.export(this);
  },
  attribute(key, value) {
    this.attributes.set(key, value);
  },
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes]);
  },
  addLinks(links) {
    // eslint-disable-next-line no-restricted-syntax
    this.links.push(...links);
  }
};
const makeSpan = options => {
  const self = Object.assign(Object.create(SpanProto), options);
  if (Option.isSome(self.parent)) {
    self.traceId = self.parent.value.traceId;
  } else {
    self.traceId = generateId(32);
  }
  self.spanId = generateId(16);
  self.events = [];
  return self;
};
const generateId = len => {
  const chars = "0123456789abcdef";
  let result = "";
  for (let i = 0; i < len; i++) {
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
};
const makeOtlpSpan = self => {
  const status = self.status;
  const attributes = entriesToAttributes(self.attributes.entries());
  const events = self.events.map(([name, startTime, attributes]) => ({
    name,
    timeUnixNano: String(startTime),
    attributes: attributes ? entriesToAttributes(Object.entries(attributes)) : [],
    droppedAttributesCount: 0
  }));
  let otelStatus;
  if (status.exit._tag === "Success") {
    otelStatus = constOtelStatusSuccess;
  } else if (Cause.isInterruptedOnly(status.exit.cause)) {
    otelStatus = {
      code: StatusCode.Ok,
      message: Cause.pretty(status.exit.cause)
    };
  } else {
    const errors = Cause.prettyErrors(status.exit.cause);
    const firstError = errors[0];
    otelStatus = {
      code: StatusCode.Error
    };
    attributes.push({
      key: "span.label",
      value: {
        stringValue: "⚠︎ Interrupted"
      }
    }, {
      key: "status.interrupted",
      value: {
        boolValue: true
      }
    });
    if (firstError) {
      otelStatus.message = firstError.message;
      events.push({
        name: "exception",
        timeUnixNano: String(status.endTime),
        droppedAttributesCount: 0,
        attributes: [{
          "key": "exception.type",
          "value": {
            "stringValue": firstError.name
          }
        }, {
          "key": "exception.message",
          "value": {
            "stringValue": firstError.message
          }
        }, {
          "key": "exception.stacktrace",
          "value": {
            "stringValue": Cause.pretty(status.exit.cause, {
              renderErrorCause: true
            })
          }
        }]
      });
    }
  }
  return {
    traceId: self.traceId,
    spanId: self.spanId,
    parentSpanId: Option.isSome(self.parent) ? self.parent.value.spanId : undefined,
    name: self.name,
    kind: SpanKind[self.kind],
    startTimeUnixNano: String(status.startTime),
    endTimeUnixNano: String(status.endTime),
    attributes,
    droppedAttributesCount: 0,
    events,
    droppedEventsCount: 0,
    status: otelStatus,
    links: self.links.map(link => ({
      traceId: link.span.traceId,
      spanId: link.span.spanId,
      attributes: entriesToAttributes(Object.entries(link.attributes)),
      droppedAttributesCount: 0
    })),
    droppedLinksCount: 0
  };
};
var StatusCode;
(function (StatusCode) {
  StatusCode[StatusCode["Unset"] = 0] = "Unset";
  StatusCode[StatusCode["Ok"] = 1] = "Ok";
  StatusCode[StatusCode["Error"] = 2] = "Error";
})(StatusCode || (StatusCode = {}));
var SpanKind;
(function (SpanKind) {
  SpanKind[SpanKind["unspecified"] = 0] = "unspecified";
  SpanKind[SpanKind["internal"] = 1] = "internal";
  SpanKind[SpanKind["server"] = 2] = "server";
  SpanKind[SpanKind["client"] = 3] = "client";
  SpanKind[SpanKind["producer"] = 4] = "producer";
  SpanKind[SpanKind["consumer"] = 5] = "consumer";
})(SpanKind || (SpanKind = {}));
const constOtelStatusSuccess = {
  code: StatusCode.Ok
};
//# sourceMappingURL=OtlpTracer.js.map