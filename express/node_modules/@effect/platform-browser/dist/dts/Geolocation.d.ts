import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Stream from "effect/Stream";
/**
 * @since 1.0.0
 * @category type ids
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category type ids
 */
export type TypeId = typeof TypeId;
/**
 * @since 1.0.0
 * @category models
 */
export interface Geolocation {
    readonly [TypeId]: TypeId;
    readonly getCurrentPosition: (options?: PositionOptions | undefined) => Effect.Effect<GeolocationPosition, GeolocationError>;
    readonly watchPosition: (options?: PositionOptions & {
        readonly bufferSize?: number | undefined;
    } | undefined) => Stream.Stream<GeolocationPosition, GeolocationError>;
}
/**
 * @since 1.0.0
 * @category tags
 */
export declare const Geolocation: Context.Tag<Geolocation, Geolocation>;
/**
 * @since 1.0.0
 * @category type ids
 */
export declare const ErrorTypeId: unique symbol;
/**
 * @since 1.0.0
 * @category type ids
 */
export type ErrorTypeId = typeof ErrorTypeId;
declare const GeolocationError_base: new <A extends Record<string, any>>(args: import("effect/Types").Simplify<A>) => import("effect/Cause").YieldableError & Record<typeof ErrorTypeId, typeof ErrorTypeId> & {
    readonly _tag: "GeolocationError";
} & Readonly<A>;
/**
 * @since 1.0.0
 * @category errors
 */
export declare class GeolocationError extends GeolocationError_base<{
    readonly reason: "PositionUnavailable" | "PermissionDenied" | "Timeout";
    readonly cause: unknown;
}> {
    get message(): "PositionUnavailable" | "PermissionDenied" | "Timeout";
}
/**
 * @since 1.0.0
 * @category layers
 */
export declare const layer: Layer.Layer<Geolocation>;
/**
 * @since 1.0.0
 * @category accessors
 */
export declare const watchPosition: (options?: (PositionOptions & {
    readonly bufferSize?: number | undefined;
}) | undefined) => Stream.Stream<GeolocationPosition, GeolocationError, Geolocation>;
export {};
//# sourceMappingURL=Geolocation.d.ts.map