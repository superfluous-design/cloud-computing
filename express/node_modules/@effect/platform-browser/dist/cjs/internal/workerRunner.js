"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.make = exports.layerMessagePort = exports.layer = void 0;
var _WorkerError = require("@effect/platform/WorkerError");
var Runner = _interopRequireWildcard(require("@effect/platform/WorkerRunner"));
var Cause = _interopRequireWildcard(require("effect/Cause"));
var Context = _interopRequireWildcard(require("effect/Context"));
var Deferred = _interopRequireWildcard(require("effect/Deferred"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var ExecStrategy = _interopRequireWildcard(require("effect/ExecutionStrategy"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var FiberSet = _interopRequireWildcard(require("effect/FiberSet"));
var _Function = require("effect/Function");
var _GlobalValue = require("effect/GlobalValue");
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Mailbox = _interopRequireWildcard(require("effect/Mailbox"));
var Runtime = _interopRequireWildcard(require("effect/Runtime"));
var Scope = _interopRequireWildcard(require("effect/Scope"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
const cachedPorts = /*#__PURE__*/(0, _GlobalValue.globalValue)("@effect/platform-browser/Worker/cachedPorts", () => new Set());
function globalHandleConnect(event) {
  cachedPorts.add(event.ports[0]);
}
if (typeof self !== "undefined" && "onconnect" in self) {
  self.onconnect = globalHandleConnect;
}
/** @internal */
const make = self => Runner.PlatformRunner.of({
  [Runner.PlatformRunnerTypeId]: Runner.PlatformRunnerTypeId,
  start: Effect.fnUntraced(function* (closeLatch) {
    const disconnects = yield* Mailbox.make();
    let currentPortId = 0;
    const ports = new Map();
    const send = (portId, message, transfer) => Effect.sync(() => {
      ;
      (ports.get(portId)?.[0] ?? self).postMessage([1, message], {
        transfer: transfer
      });
    });
    const run = Effect.fnUntraced(function* (handler) {
      const scope = yield* Effect.scope;
      const runtime = (yield* Effect.interruptible(Effect.runtime())).pipe(Runtime.updateContext(Context.omit(Scope.Scope)));
      const fiberSet = yield* FiberSet.make();
      const runFork = Runtime.runFork(runtime);
      function onExit(exit) {
        if (exit._tag === "Failure" && !Cause.isInterruptedOnly(exit.cause)) {
          Deferred.unsafeDone(closeLatch, Exit.die(Cause.squash(exit.cause)));
        }
      }
      function onMessage(portId) {
        return function (event) {
          const message = event.data;
          if (message[0] === 0) {
            const result = handler(portId, message[1]);
            if (Effect.isEffect(result)) {
              const fiber = runFork(result);
              fiber.addObserver(onExit);
              FiberSet.unsafeAdd(fiberSet, fiber);
            }
          } else {
            const port = ports.get(portId);
            if (!port) {
              return;
            } else if (ports.size === 1) {
              // let the last port close with the outer scope
              return Deferred.unsafeDone(closeLatch, Exit.void);
            }
            ports.delete(portId);
            Effect.runFork(Scope.close(port[1], Exit.void));
          }
        };
      }
      function onMessageError(error) {
        Deferred.unsafeDone(closeLatch, new _WorkerError.WorkerError({
          reason: "decode",
          cause: error.data
        }));
      }
      function onError(error) {
        Deferred.unsafeDone(closeLatch, new _WorkerError.WorkerError({
          reason: "unknown",
          cause: error.data
        }));
      }
      function handlePort(port) {
        const fiber = Scope.fork(scope, ExecStrategy.sequential).pipe(Effect.flatMap(scope => {
          const portId = currentPortId++;
          ports.set(portId, [port, scope]);
          const onMsg = onMessage(portId);
          port.addEventListener("message", onMsg);
          port.addEventListener("messageerror", onMessageError);
          if ("start" in port) {
            port.start();
          }
          port.postMessage([0]);
          return Scope.addFinalizer(scope, Effect.sync(() => {
            port.removeEventListener("message", onMsg);
            port.removeEventListener("messageerror", onError);
            port.close();
          }));
        }), runFork);
        fiber.addObserver(onExit);
        FiberSet.unsafeAdd(fiberSet, fiber);
      }
      self.addEventListener("error", onError);
      let prevOnConnect;
      if ("onconnect" in self) {
        prevOnConnect = self.onconnect;
        self.onconnect = function (event) {
          const port = event.ports[0];
          handlePort(port);
        };
        for (const port of cachedPorts) {
          handlePort(port);
        }
        cachedPorts.clear();
        yield* Scope.addFinalizer(scope, Effect.sync(() => self.close()));
      } else {
        handlePort(self);
      }
      yield* Scope.addFinalizer(scope, Effect.sync(() => {
        self.removeEventListener("error", onError);
        if ("onconnect" in self) {
          self.onconnect = prevOnConnect;
        }
      }));
    });
    return (0, _Function.identity)({
      run,
      send,
      disconnects
    });
  })
});
/** @internal */
exports.make = make;
const layerMessagePort = port => Layer.succeed(Runner.PlatformRunner, make(port));
/** @internal */
exports.layerMessagePort = layerMessagePort;
const layer = exports.layer = /*#__PURE__*/Layer.sync(Runner.PlatformRunner, () => make(self));
//# sourceMappingURL=workerRunner.js.map