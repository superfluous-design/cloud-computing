"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.layer = void 0;
var _WorkerError = require("@effect/platform/WorkerError");
var Runner = _interopRequireWildcard(require("@effect/platform/WorkerRunner"));
var Cause = _interopRequireWildcard(require("effect/Cause"));
var Context = _interopRequireWildcard(require("effect/Context"));
var Deferred = _interopRequireWildcard(require("effect/Deferred"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var FiberSet = _interopRequireWildcard(require("effect/FiberSet"));
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Runtime = _interopRequireWildcard(require("effect/Runtime"));
var Scope = _interopRequireWildcard(require("effect/Scope"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
const platformRunnerImpl = /*#__PURE__*/Runner.PlatformRunner.of({
  [Runner.PlatformRunnerTypeId]: Runner.PlatformRunnerTypeId,
  start: /*#__PURE__*/Effect.fnUntraced(function* (closeLatch) {
    if (!("postMessage" in self)) {
      return yield* new _WorkerError.WorkerError({
        reason: "spawn",
        cause: new Error("not in a Worker context")
      });
    }
    const port = self;
    const run = Effect.fnUntraced(function* (handler) {
      const scope = yield* Effect.scope;
      const runtime = (yield* Effect.runtime().pipe(Effect.interruptible)).pipe(Runtime.updateContext(Context.omit(Scope.Scope)));
      const fiberSet = yield* FiberSet.make();
      const runFork = Runtime.runFork(runtime);
      const onExit = exit => {
        if (exit._tag === "Failure" && !Cause.isInterruptedOnly(exit.cause)) {
          Deferred.unsafeDone(closeLatch, Exit.die(Cause.squash(exit.cause)));
        }
      };
      function onMessage(event) {
        const message = event.data;
        if (message[0] === 0) {
          const result = handler(0, message[1]);
          if (Effect.isEffect(result)) {
            const fiber = runFork(result);
            fiber.addObserver(onExit);
            FiberSet.unsafeAdd(fiberSet, fiber);
          }
        } else {
          port.close();
          Deferred.unsafeDone(closeLatch, Exit.void);
        }
      }
      function onMessageError(error) {
        Deferred.unsafeDone(closeLatch, new _WorkerError.WorkerError({
          reason: "decode",
          cause: error.data
        }));
      }
      function onError(error) {
        Deferred.unsafeDone(closeLatch, new _WorkerError.WorkerError({
          reason: "unknown",
          cause: error.data
        }));
      }
      yield* Scope.addFinalizer(scope, Effect.sync(() => {
        port.removeEventListener("message", onMessage);
        port.removeEventListener("messageerror", onError);
      }));
      port.addEventListener("message", onMessage);
      port.addEventListener("messageerror", onMessageError);
      port.postMessage([0]);
    });
    const send = (_portId, message, transfer) => Effect.sync(() => port.postMessage([1, message], {
      transfer: transfer
    }));
    return {
      run,
      send
    };
  })
});
/** @internal */
const layer = exports.layer = /*#__PURE__*/Layer.succeed(Runner.PlatformRunner, platformRunnerImpl);
//# sourceMappingURL=workerRunner.js.map