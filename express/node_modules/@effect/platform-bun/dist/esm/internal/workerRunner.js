import { WorkerError } from "@effect/platform/WorkerError";
import * as Runner from "@effect/platform/WorkerRunner";
import * as Cause from "effect/Cause";
import * as Context from "effect/Context";
import * as Deferred from "effect/Deferred";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as FiberSet from "effect/FiberSet";
import * as Layer from "effect/Layer";
import * as Runtime from "effect/Runtime";
import * as Scope from "effect/Scope";
const platformRunnerImpl = /*#__PURE__*/Runner.PlatformRunner.of({
  [Runner.PlatformRunnerTypeId]: Runner.PlatformRunnerTypeId,
  start: /*#__PURE__*/Effect.fnUntraced(function* (closeLatch) {
    if (!("postMessage" in self)) {
      return yield* new WorkerError({
        reason: "spawn",
        cause: new Error("not in a Worker context")
      });
    }
    const port = self;
    const run = Effect.fnUntraced(function* (handler) {
      const scope = yield* Effect.scope;
      const runtime = (yield* Effect.runtime().pipe(Effect.interruptible)).pipe(Runtime.updateContext(Context.omit(Scope.Scope)));
      const fiberSet = yield* FiberSet.make();
      const runFork = Runtime.runFork(runtime);
      const onExit = exit => {
        if (exit._tag === "Failure" && !Cause.isInterruptedOnly(exit.cause)) {
          Deferred.unsafeDone(closeLatch, Exit.die(Cause.squash(exit.cause)));
        }
      };
      function onMessage(event) {
        const message = event.data;
        if (message[0] === 0) {
          const result = handler(0, message[1]);
          if (Effect.isEffect(result)) {
            const fiber = runFork(result);
            fiber.addObserver(onExit);
            FiberSet.unsafeAdd(fiberSet, fiber);
          }
        } else {
          port.close();
          Deferred.unsafeDone(closeLatch, Exit.void);
        }
      }
      function onMessageError(error) {
        Deferred.unsafeDone(closeLatch, new WorkerError({
          reason: "decode",
          cause: error.data
        }));
      }
      function onError(error) {
        Deferred.unsafeDone(closeLatch, new WorkerError({
          reason: "unknown",
          cause: error.data
        }));
      }
      yield* Scope.addFinalizer(scope, Effect.sync(() => {
        port.removeEventListener("message", onMessage);
        port.removeEventListener("messageerror", onError);
      }));
      port.addEventListener("message", onMessage);
      port.addEventListener("messageerror", onMessageError);
      port.postMessage([0]);
    });
    const send = (_portId, message, transfer) => Effect.sync(() => port.postMessage([1, message], {
      transfer: transfer
    }));
    return {
      run,
      send
    };
  })
});
/** @internal */
export const layer = /*#__PURE__*/Layer.succeed(Runner.PlatformRunner, platformRunnerImpl);
//# sourceMappingURL=workerRunner.js.map