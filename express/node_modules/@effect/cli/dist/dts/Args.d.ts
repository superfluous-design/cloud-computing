/**
 * @since 1.0.0
 */
import type { FileSystem } from "@effect/platform/FileSystem";
import type { Path } from "@effect/platform/Path";
import type { QuitException, Terminal } from "@effect/platform/Terminal";
import type { NonEmptyArray } from "effect/Array";
import type { Config } from "effect/Config";
import type { Effect } from "effect/Effect";
import type { Option } from "effect/Option";
import type { Pipeable } from "effect/Pipeable";
import type { Redacted } from "effect/Redacted";
import type { Schema } from "effect/Schema";
import type { Secret } from "effect/Secret";
import type { CliConfig } from "./CliConfig.js";
import type { HelpDoc } from "./HelpDoc.js";
import type { Primitive } from "./Primitive.js";
import type { Usage } from "./Usage.js";
import type { ValidationError } from "./ValidationError.js";
/**
 * @since 1.0.0
 * @category symbols
 */
export declare const ArgsTypeId: unique symbol;
/**
 * @since 1.0.0
 * @category symbols
 */
export type ArgsTypeId = typeof ArgsTypeId;
/**
 * Represents arguments that can be passed to a command-line application.
 *
 * @since 1.0.0
 * @category models
 */
export interface Args<A> extends Args.Variance<A>, Pipeable {
}
/**
 * @since 1.0.0
 */
export declare namespace Args {
    /**
     * @since 1.0.0
     * @category models
     */
    interface Variance<A> {
        readonly [ArgsTypeId]: {
            readonly _A: (_: never) => A;
        };
    }
    /**
     * @since 1.0.0
     * @category models
     */
    interface BaseArgsConfig {
        readonly name?: string;
    }
    /**
     * @since 1.0.0
     * @category models
     */
    interface PathArgsConfig extends BaseArgsConfig {
        readonly exists?: Primitive.PathExists;
    }
    /**
     * @since 1.0.0
     * @category models
     */
    interface FormatArgsConfig extends BaseArgsConfig {
        readonly format?: "json" | "yaml" | "ini" | "toml";
    }
}
/**
 * @since 1.0.0
 */
export declare namespace All {
    /**
     * @since 1.0.0
     */
    type ArgsAny = Args<any>;
    /**
     * @since 1.0.0
     */
    type ReturnIterable<T extends Iterable<ArgsAny>> = [T] extends [Iterable<Args.Variance<infer A>>] ? Args<Array<A>> : never;
    /**
     * @since 1.0.0
     */
    type ReturnTuple<T extends ReadonlyArray<unknown>> = Args<T[number] extends never ? [] : {
        -readonly [K in keyof T]: [T[K]] extends [Args.Variance<infer _A>] ? _A : never;
    }> extends infer X ? X : never;
    /**
     * @since 1.0.0
     */
    type ReturnObject<T> = [T] extends [{
        [K: string]: ArgsAny;
    }] ? Args<{
        -readonly [K in keyof T]: [T[K]] extends [Args.Variance<infer _A>] ? _A : never;
    }> : never;
    /**
     * @since 1.0.0
     */
    type Return<Arg extends Iterable<ArgsAny> | Record<string, ArgsAny>> = [Arg] extends [ReadonlyArray<ArgsAny>] ? ReturnTuple<Arg> : [Arg] extends [Iterable<ArgsAny>] ? ReturnIterable<Arg> : [Arg] extends [Record<string, ArgsAny>] ? ReturnObject<Arg> : never;
}
/**
 * @since 1.0.0
 * @category refinements
 */
export declare const isArgs: (u: unknown) => u is Args<unknown>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const all: <const Arg extends Iterable<Args<any>> | Record<string, Args<any>>>(arg: Arg) => All.Return<Arg>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const atLeast: {
    /**
     * @since 1.0.0
     * @category combinators
     */
    (times: 0): <A>(self: Args<A>) => Args<Array<A>>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    (times: number): <A>(self: Args<A>) => Args<NonEmptyArray<A>>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A>(self: Args<A>, times: 0): Args<Array<A>>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A>(self: Args<A>, times: number): Args<NonEmptyArray<A>>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const atMost: {
    /**
     * @since 1.0.0
     * @category combinators
     */
    (times: number): <A>(self: Args<A>) => Args<Array<A>>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A>(self: Args<A>, times: number): Args<Array<A>>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const between: {
    /**
     * @since 1.0.0
     * @category combinators
     */
    (min: 0, max: number): <A>(self: Args<A>) => Args<Array<A>>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    (min: number, max: number): <A>(self: Args<A>) => Args<NonEmptyArray<A>>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A>(self: Args<A>, min: 0, max: number): Args<Array<A>>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A>(self: Args<A>, min: number, max: number): Args<NonEmptyArray<A>>;
};
/**
 * Creates a boolean argument.
 *
 * Can optionally provide a custom argument name (defaults to `"boolean"`).
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const boolean: (options?: Args.BaseArgsConfig) => Args<boolean>;
/**
 * Creates a choice argument.
 *
 * Can optionally provide a custom argument name (defaults to `"choice"`).
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const choice: <A>(choices: ReadonlyArray<[string, A]>, config?: Args.BaseArgsConfig) => Args<A>;
/**
 * Creates a date argument.
 *
 * Can optionally provide a custom argument name (defaults to `"date"`).
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const date: (config?: Args.BaseArgsConfig) => Args<globalThis.Date>;
/**
 * Creates a directory argument.
 *
 * Can optionally provide a custom argument name (defaults to `"directory"`).
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const directory: (config?: Args.PathArgsConfig) => Args<string>;
/**
 * Creates a file argument.
 *
 * Can optionally provide a custom argument name (defaults to `"file"`).
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const file: (config?: Args.PathArgsConfig) => Args<string>;
/**
 * Creates a file argument that reads its contents.
 *
 * Can optionally provide a custom argument name (defaults to `"file"`).
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const fileContent: (config?: Args.BaseArgsConfig | undefined) => Args<readonly [path: string, content: Uint8Array]>;
/**
 * Creates a file argument that reads and parses its contents.
 *
 * Can optionally provide a custom argument name (defaults to `"file"`).
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const fileParse: (config?: Args.FormatArgsConfig | undefined) => Args<unknown>;
/**
 * Creates a file argument that reads, parses and validates its contents.
 *
 * Can optionally provide a custom argument name (defaults to `"file"`).
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const fileSchema: <I, A>(schema: Schema<A, I, FileSystem | Path | Terminal>, config?: Args.FormatArgsConfig | undefined) => Args<A>;
/**
 * Creates a file argument that reads it's contents.
 *
 * Can optionally provide a custom argument name (defaults to `"file"`).
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const fileText: (config?: Args.BaseArgsConfig | undefined) => Args<readonly [path: string, content: string]>;
/**
 * Creates a floating point number argument.
 *
 * Can optionally provide a custom argument name (defaults to `"float"`).
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const float: (config?: Args.BaseArgsConfig) => Args<number>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const getHelp: <A>(self: Args<A>) => HelpDoc;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const getIdentifier: <A>(self: Args<A>) => Option<string>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const getMinSize: <A>(self: Args<A>) => number;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const getMaxSize: <A>(self: Args<A>) => number;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const getUsage: <A>(self: Args<A>) => Usage;
/**
 * Creates an integer argument.
 *
 * Can optionally provide a custom argument name (defaults to `"integer"`).
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const integer: (config?: Args.BaseArgsConfig) => Args<number>;
/**
 * @since 1.0.0
 * @category mapping
 */
export declare const map: {
    /**
     * @since 1.0.0
     * @category mapping
     */
    <A, B>(f: (a: A) => B): (self: Args<A>) => Args<B>;
    /**
     * @since 1.0.0
     * @category mapping
     */
    <A, B>(self: Args<A>, f: (a: A) => B): Args<B>;
};
/**
 * @since 1.0.0
 * @category mapping
 */
export declare const mapEffect: {
    /**
     * @since 1.0.0
     * @category mapping
     */
    <A, B>(f: (a: A) => Effect<B, HelpDoc, FileSystem | Path | Terminal>): (self: Args<A>) => Args<B>;
    /**
     * @since 1.0.0
     * @category mapping
     */
    <A, B>(self: Args<A>, f: (a: A) => Effect<B, HelpDoc, FileSystem | Path | Terminal>): Args<B>;
};
/**
 * @since 1.0.0
 * @category mapping
 */
export declare const mapTryCatch: {
    /**
     * @since 1.0.0
     * @category mapping
     */
    <A, B>(f: (a: A) => B, onError: (e: unknown) => HelpDoc): (self: Args<A>) => Args<B>;
    /**
     * @since 1.0.0
     * @category mapping
     */
    <A, B>(self: Args<A>, f: (a: A) => B, onError: (e: unknown) => HelpDoc): Args<B>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const optional: <A>(self: Args<A>) => Args<Option<A>>;
/**
 *  Creates an empty argument.
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const none: Args<void>;
/**
 * Creates a path argument.
 *
 * Can optionally provide a custom argument name (defaults to `"path"`).
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const path: (config?: Args.PathArgsConfig) => Args<string>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const repeated: <A>(self: Args<A>) => Args<Array<A>>;
/**
 * Creates a text argument.
 *
 * Can optionally provide a custom argument name (defaults to `"redacted"`).
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const redacted: (config?: Args.BaseArgsConfig) => Args<Redacted>;
/**
 * Creates a text argument.
 *
 * Can optionally provide a custom argument name (defaults to `"secret"`).
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const secret: (config?: Args.BaseArgsConfig) => Args<Secret>;
/**
 * Creates a text argument.
 *
 * Can optionally provide a custom argument name (defaults to `"text"`).
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const text: (config?: Args.BaseArgsConfig) => Args<string>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const validate: {
    /**
     * @since 1.0.0
     * @category combinators
     */
    (args: ReadonlyArray<string>, config: CliConfig): <A>(self: Args<A>) => Effect<[
        Array<string>,
        A
    ], ValidationError, FileSystem | Path | Terminal>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A>(self: Args<A>, args: ReadonlyArray<string>, config: CliConfig): Effect<[
        Array<string>,
        A
    ], ValidationError, FileSystem | Path | Terminal>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const withDefault: {
    /**
     * @since 1.0.0
     * @category combinators
     */
    <const B>(fallback: B): <A>(self: Args<A>) => Args<B | A>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A, const B>(self: Args<A>, fallback: B): Args<A | B>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const withFallbackConfig: {
    /**
     * @since 1.0.0
     * @category combinators
     */
    <B>(config: Config<B>): <A>(self: Args<A>) => Args<B | A>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A, B>(self: Args<A>, config: Config<B>): Args<A | B>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const withDescription: {
    /**
     * @since 1.0.0
     * @category combinators
     */
    (description: string): <A>(self: Args<A>) => Args<A>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A>(self: Args<A>, description: string): Args<A>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const withSchema: {
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A, I extends A, B>(schema: Schema<B, I, FileSystem | Path | Terminal>): (self: Args<A>) => Args<B>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A, I extends A, B>(self: Args<A>, schema: Schema<B, I, FileSystem | Path | Terminal>): Args<B>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const wizard: {
    /**
     * @since 1.0.0
     * @category combinators
     */
    (config: CliConfig): <A>(self: Args<A>) => Effect<Array<string>, ValidationError | QuitException, FileSystem | Path | Terminal>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A>(self: Args<A>, config: CliConfig): Effect<Array<string>, ValidationError | QuitException, FileSystem | Path | Terminal>;
};
//# sourceMappingURL=Args.d.ts.map