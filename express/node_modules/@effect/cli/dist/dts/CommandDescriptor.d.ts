/**
 * @since 1.0.0
 */
import type { FileSystem } from "@effect/platform/FileSystem";
import type { Path } from "@effect/platform/Path";
import type { QuitException, Terminal } from "@effect/platform/Terminal";
import type { NonEmptyReadonlyArray } from "effect/Array";
import type { Effect } from "effect/Effect";
import type { HashMap } from "effect/HashMap";
import type { HashSet } from "effect/HashSet";
import type { Option } from "effect/Option";
import type { Pipeable } from "effect/Pipeable";
import type { Args } from "./Args.js";
import type { CliConfig } from "./CliConfig.js";
import type { CommandDirective } from "./CommandDirective.js";
import type { HelpDoc } from "./HelpDoc.js";
import type { Options } from "./Options.js";
import type { Prompt } from "./Prompt.js";
import type { Usage } from "./Usage.js";
import type { ValidationError } from "./ValidationError.js";
/**
 * @since 1.0.0
 * @category symbols
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category symbols
 */
export type TypeId = typeof TypeId;
/**
 * A `Command` represents a command in a command-line application.
 *
 * Every command-line application will have at least one command: the
 * application itself. Other command-line applications may support multiple
 * commands.
 *
 * @since 1.0.0
 * @category models
 */
export interface Command<A> extends Command.Variance<A>, Pipeable {
}
/**
 * @since 1.0.0
 */
export declare namespace Command {
    /**
     * @since 1.0.0
     * @category models
     */
    interface Variance<A> {
        readonly [TypeId]: {
            readonly _A: (_: never) => A;
        };
    }
    /**
     * @since 1.0.0
     * @category models
     */
    type ParsedStandardCommand<Name extends string, OptionsType, ArgsType> = Command.ComputeParsedType<{
        readonly name: Name;
        readonly options: OptionsType;
        readonly args: ArgsType;
    }>;
    /**
     * @since 1.0.0
     * @category models
     */
    type ParsedUserInputCommand<Name extends string, ValueType> = Command.ComputeParsedType<{
        readonly name: Name;
        readonly value: ValueType;
    }>;
    /**
     * @since 1.0.0
     * @category models
     */
    type GetParsedType<C> = C extends Command<infer P> ? P : never;
    /**
     * @since 1.0.0
     * @category models
     */
    type ComputeParsedType<A> = {
        [K in keyof A]: A[K];
    } extends infer X ? X : never;
    /**
     * @since 1.0.0
     * @category models
     */
    type Subcommands<A extends NonEmptyReadonlyArray<readonly [id: unknown, command: Command<any>]>> = {
        [I in keyof A]: A[I] extends readonly [infer Id, Command<infer Value>] ? readonly [id: Id, value: Value] : never;
    }[number];
}
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const getHelp: <A>(self: Command<A>, config: CliConfig) => HelpDoc;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const getBashCompletions: <A>(self: Command<A>, programName: string) => Effect<Array<string>>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const getFishCompletions: <A>(self: Command<A>, programName: string) => Effect<Array<string>>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const getZshCompletions: <A>(self: Command<A>, programName: string) => Effect<Array<string>>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const getNames: <A>(self: Command<A>) => HashSet<string>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const getSubcommands: <A>(self: Command<A>) => HashMap<string, Command<unknown>>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const getUsage: <A>(self: Command<A>) => Usage;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const map: {
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A, B>(f: (a: A) => B): (self: Command<A>) => Command<B>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A, B>(self: Command<A>, f: (a: A) => B): Command<B>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const mapEffect: {
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A, B>(f: (a: A) => Effect<B, ValidationError, FileSystem | Path | Terminal>): (self: Command<A>) => Command<B>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A, B>(self: Command<A>, f: (a: A) => Effect<B, ValidationError, FileSystem | Path | Terminal>): Command<B>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const parse: {
    /**
     * @since 1.0.0
     * @category combinators
     */
    (args: ReadonlyArray<string>, config: CliConfig): <A>(self: Command<A>) => Effect<CommandDirective<A>, ValidationError, FileSystem | Path | Terminal>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A>(self: Command<A>, args: ReadonlyArray<string>, config: CliConfig): Effect<CommandDirective<A>, ValidationError, FileSystem | Path | Terminal>;
};
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const prompt: <Name extends string, A>(name: Name, prompt: Prompt<A>) => Command<{
    readonly name: Name;
    readonly value: A;
}>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const make: <Name extends string, OptionsType = void, ArgsType = void>(name: Name, options?: Options<OptionsType>, args?: Args<ArgsType>) => Command<{
    readonly name: Name;
    readonly options: OptionsType;
    readonly args: ArgsType;
}>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const withDescription: {
    /**
     * @since 1.0.0
     * @category combinators
     */
    (description: string | HelpDoc): <A>(self: Command<A>) => Command<A>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A>(self: Command<A>, description: string | HelpDoc): Command<A>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const withSubcommands: {
    /**
     * @since 1.0.0
     * @category combinators
     */
    <const Subcommands extends readonly [
        readonly [id: unknown, command: Command<any>],
        ...Array<readonly [id: unknown, command: Command<any>]>
    ]>(subcommands: [...Subcommands]): <A>(self: Command<A>) => Command<Command.ComputeParsedType<A & Readonly<{
        subcommand: Option<Command.Subcommands<Subcommands>>;
    }>>>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A, const Subcommands extends readonly [
        readonly [id: unknown, command: Command<any>],
        ...Array<readonly [id: unknown, command: Command<any>]>
    ]>(self: Command<A>, subcommands: [...Subcommands]): Command<Command.ComputeParsedType<A & Readonly<{
        subcommand: Option<Command.Subcommands<Subcommands>>;
    }>>>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const wizard: {
    /**
     * @since 1.0.0
     * @category combinators
     */
    (prefix: ReadonlyArray<string>, config: CliConfig): <A>(self: Command<A>) => Effect<Array<string>, ValidationError | QuitException, FileSystem | Path | Terminal>;
    /**
     * @since 1.0.0
     * @category combinators
     */
    <A>(self: Command<A>, prefix: ReadonlyArray<string>, config: CliConfig): Effect<Array<string>, ValidationError | QuitException, FileSystem | Path | Terminal>;
};
//# sourceMappingURL=CommandDescriptor.d.ts.map