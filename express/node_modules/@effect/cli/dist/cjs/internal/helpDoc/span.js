"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.weak = exports.uri = exports.toAnsiDoc = exports.text = exports.strong = exports.spans = exports.space = exports.size = exports.isWeak = exports.isUri = exports.isText = exports.isStrong = exports.isSequence = exports.isEmpty = exports.highlight = exports.getText = exports.error = exports.empty = exports.concat = exports.code = void 0;
var Ansi = _interopRequireWildcard(require("@effect/printer-ansi/Ansi"));
var Doc = _interopRequireWildcard(require("@effect/printer-ansi/AnsiDoc"));
var Color = _interopRequireWildcard(require("@effect/printer-ansi/Color"));
var Arr = _interopRequireWildcard(require("effect/Array"));
var _Function = require("effect/Function");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/** @internal */
const text = value => ({
  _tag: "Text",
  value
});
/** @internal */
exports.text = text;
const empty = exports.empty = /*#__PURE__*/text("");
/** @internal */
const space = exports.space = /*#__PURE__*/text(" ");
/** @internal */
const code = value => highlight(value, Color.white);
/** @internal */
exports.code = code;
const error = value => highlight(value, Color.red);
/** @internal */
exports.error = error;
const highlight = (value, color) => ({
  _tag: "Highlight",
  value: typeof value === "string" ? text(value) : value,
  color
});
/** @internal */
exports.highlight = highlight;
const strong = value => ({
  _tag: "Strong",
  value: typeof value === "string" ? text(value) : value
});
/** @internal */
exports.strong = strong;
const uri = value => ({
  _tag: "URI",
  value
});
/** @internal */
exports.uri = uri;
const weak = value => ({
  _tag: "Weak",
  value: typeof value === "string" ? text(value) : value
});
/** @internal */
exports.weak = weak;
const isSequence = self => self._tag === "Sequence";
/** @internal */
exports.isSequence = isSequence;
const isStrong = self => self._tag === "Strong";
/** @internal */
exports.isStrong = isStrong;
const isText = self => self._tag === "Text";
/** @internal */
exports.isText = isText;
const isUri = self => self._tag === "URI";
/** @internal */
exports.isUri = isUri;
const isWeak = self => self._tag === "Weak";
/** @internal */
exports.isWeak = isWeak;
const concat = exports.concat = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => ({
  _tag: "Sequence",
  left: self,
  right: that
}));
const getText = self => {
  switch (self._tag) {
    case "Text":
    case "URI":
      {
        return self.value;
      }
    case "Highlight":
    case "Weak":
    case "Strong":
      {
        return getText(self.value);
      }
    case "Sequence":
      {
        return getText(self.left) + getText(self.right);
      }
  }
};
/** @internal */
exports.getText = getText;
const spans = spans => {
  const elements = Arr.fromIterable(spans);
  if (Arr.isNonEmptyReadonlyArray(elements)) {
    return elements.slice(1).reduce(concat, elements[0]);
  }
  return empty;
};
/** @internal */
exports.spans = spans;
const isEmpty = self => size(self) === 0;
/** @internal */
exports.isEmpty = isEmpty;
const size = self => {
  switch (self._tag) {
    case "Text":
    case "URI":
      {
        return self.value.length;
      }
    case "Highlight":
    case "Strong":
    case "Weak":
      {
        return size(self.value);
      }
    case "Sequence":
      {
        return size(self.left) + size(self.right);
      }
  }
};
/** @internal */
exports.size = size;
const toAnsiDoc = self => {
  switch (self._tag) {
    case "Highlight":
      {
        return Doc.annotate(toAnsiDoc(self.value), Ansi.color(self.color));
      }
    case "Sequence":
      {
        return Doc.cat(toAnsiDoc(self.left), toAnsiDoc(self.right));
      }
    case "Strong":
      {
        return Doc.annotate(toAnsiDoc(self.value), Ansi.bold);
      }
    case "Text":
      {
        return Doc.text(self.value);
      }
    case "URI":
      {
        return Doc.annotate(Doc.text(self.value), Ansi.underlined);
      }
    case "Weak":
      {
        return Doc.annotate(toAnsiDoc(self.value), Ansi.black);
      }
  }
};
exports.toAnsiDoc = toAnsiDoc;
//# sourceMappingURL=span.js.map