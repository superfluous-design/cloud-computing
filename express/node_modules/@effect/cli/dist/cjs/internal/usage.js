"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.repeated = exports.optional = exports.named = exports.mixed = exports.getHelp = exports.enumerate = exports.empty = exports.concat = exports.alternation = void 0;
var Arr = _interopRequireWildcard(require("effect/Array"));
var _Function = require("effect/Function");
var Option = _interopRequireWildcard(require("effect/Option"));
var InternalCliConfig = _interopRequireWildcard(require("./cliConfig.js"));
var InternalHelpDoc = _interopRequireWildcard(require("./helpDoc.js"));
var InternalSpan = _interopRequireWildcard(require("./helpDoc/span.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
// =============================================================================
// Constructors
// =============================================================================
/** @internal */
const empty = exports.empty = {
  _tag: "Empty"
};
/** @internal */
const mixed = exports.mixed = {
  _tag: "Empty"
};
/** @internal */
const named = (names, acceptedValues) => ({
  _tag: "Named",
  names,
  acceptedValues
});
/** @internal */
exports.named = named;
const optional = self => ({
  _tag: "Optional",
  usage: self
});
/** @internal */
exports.optional = optional;
const repeated = self => ({
  _tag: "Repeated",
  usage: self
});
exports.repeated = repeated;
const alternation = exports.alternation = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => ({
  _tag: "Alternation",
  left: self,
  right: that
}));
/** @internal */
const concat = exports.concat = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => ({
  _tag: "Concat",
  left: self,
  right: that
}));
// =============================================================================
// Combinators
// =============================================================================
/** @internal */
const getHelp = self => {
  const spans = enumerate(self, InternalCliConfig.defaultConfig);
  if (Arr.isNonEmptyReadonlyArray(spans)) {
    const head = Arr.headNonEmpty(spans);
    const tail = Arr.tailNonEmpty(spans);
    if (Arr.isNonEmptyReadonlyArray(tail)) {
      return (0, _Function.pipe)(Arr.map(spans, span => InternalHelpDoc.p(span)), Arr.reduceRight(InternalHelpDoc.empty, (left, right) => InternalHelpDoc.sequence(left, right)));
    }
    return InternalHelpDoc.p(head);
  }
  return InternalHelpDoc.empty;
};
/** @internal */
exports.getHelp = getHelp;
const enumerate = exports.enumerate = /*#__PURE__*/(0, _Function.dual)(2, (self, config) => render(simplify(self, config), config));
// =============================================================================
// Internals
// =============================================================================
const simplify = (self, config) => {
  switch (self._tag) {
    case "Empty":
      {
        return empty;
      }
    case "Mixed":
      {
        return mixed;
      }
    case "Named":
      {
        if (Option.isNone(Arr.head(render(self, config)))) {
          return empty;
        }
        return self;
      }
    case "Optional":
      {
        if (self.usage._tag === "Empty") {
          return empty;
        }
        const usage = simplify(self.usage, config);
        // No need to do anything for empty usage
        return usage._tag === "Empty" ? empty
        // Avoid re-wrapping the usage in an optional instruction
        : usage._tag === "Optional" ? usage : optional(usage);
      }
    case "Repeated":
      {
        const usage = simplify(self.usage, config);
        return usage._tag === "Empty" ? empty : repeated(usage);
      }
    case "Alternation":
      {
        const leftUsage = simplify(self.left, config);
        const rightUsage = simplify(self.right, config);
        return leftUsage._tag === "Empty" ? rightUsage : rightUsage._tag === "Empty" ? leftUsage : alternation(leftUsage, rightUsage);
      }
    case "Concat":
      {
        const leftUsage = simplify(self.left, config);
        const rightUsage = simplify(self.right, config);
        return leftUsage._tag === "Empty" ? rightUsage : rightUsage._tag === "Empty" ? leftUsage : concat(leftUsage, rightUsage);
      }
  }
};
const render = (self, config) => {
  switch (self._tag) {
    case "Empty":
      {
        return Arr.of(InternalSpan.text(""));
      }
    case "Mixed":
      {
        return Arr.of(InternalSpan.text("<command>"));
      }
    case "Named":
      {
        const typeInfo = config.showTypes ? Option.match(self.acceptedValues, {
          onNone: () => InternalSpan.empty,
          onSome: s => InternalSpan.concat(InternalSpan.space, InternalSpan.text(s))
        }) : InternalSpan.empty;
        const namesToShow = config.showAllNames ? self.names : self.names.length > 1 ? (0, _Function.pipe)(Arr.filter(self.names, name => name.startsWith("--")), Arr.head, Option.map(Arr.of), Option.getOrElse(() => self.names)) : self.names;
        const nameInfo = InternalSpan.text(Arr.join(namesToShow, ", "));
        return config.showAllNames && self.names.length > 1 ? Arr.of(InternalSpan.spans([InternalSpan.text("("), nameInfo, typeInfo, InternalSpan.text(")")])) : Arr.of(InternalSpan.concat(nameInfo, typeInfo));
      }
    case "Optional":
      {
        return Arr.map(render(self.usage, config), span => InternalSpan.spans([InternalSpan.text("["), span, InternalSpan.text("]")]));
      }
    case "Repeated":
      {
        return Arr.map(render(self.usage, config), span => InternalSpan.concat(span, InternalSpan.text("...")));
      }
    case "Alternation":
      {
        if (self.left._tag === "Repeated" || self.right._tag === "Repeated" || self.left._tag === "Concat" || self.right._tag === "Concat") {
          return Arr.appendAll(render(self.left, config), render(self.right, config));
        }
        return Arr.flatMap(render(self.left, config), left => Arr.map(render(self.right, config), right => InternalSpan.spans([left, InternalSpan.text("|"), right])));
      }
    case "Concat":
      {
        const leftSpan = render(self.left, config);
        const rightSpan = render(self.right, config);
        const separator = Arr.isNonEmptyReadonlyArray(leftSpan) && Arr.isNonEmptyReadonlyArray(rightSpan) ? InternalSpan.space : InternalSpan.empty;
        return Arr.flatMap(leftSpan, left => Arr.map(rightSpan, right => InternalSpan.spans([left, separator, right])));
      }
  }
};
//# sourceMappingURL=usage.js.map