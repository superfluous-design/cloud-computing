"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wizard = exports.withSchema = exports.withFallbackConfig = exports.withDescription = exports.withDefault = exports.validate = exports.text = exports.secret = exports.repeated = exports.redacted = exports.path = exports.optional = exports.none = exports.mapTryCatch = exports.mapEffect = exports.map = exports.isWithFallbackConfig = exports.isWithDefault = exports.isVariadic = exports.isSingle = exports.isMap = exports.isInstruction = exports.isEmpty = exports.isBoth = exports.isArgs = exports.integer = exports.getZshCompletions = exports.getUsage = exports.getMinSize = exports.getMaxSize = exports.getIdentifier = exports.getHelp = exports.getFishCompletions = exports.float = exports.fileText = exports.fileSchema = exports.fileParse = exports.fileContent = exports.file = exports.directory = exports.date = exports.choice = exports.boolean = exports.between = exports.atMost = exports.atLeast = exports.all = exports.ArgsTypeId = void 0;
var Arr = _interopRequireWildcard(require("effect/Array"));
var ConfigError = _interopRequireWildcard(require("effect/ConfigError"));
var Console = _interopRequireWildcard(require("effect/Console"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Either = _interopRequireWildcard(require("effect/Either"));
var _Function = require("effect/Function");
var Inspectable = _interopRequireWildcard(require("effect/Inspectable"));
var Option = _interopRequireWildcard(require("effect/Option"));
var ParseResult = _interopRequireWildcard(require("effect/ParseResult"));
var _Pipeable = require("effect/Pipeable");
var Predicate = _interopRequireWildcard(require("effect/Predicate"));
var Ref = _interopRequireWildcard(require("effect/Ref"));
var InternalFiles = _interopRequireWildcard(require("./files.js"));
var InternalHelpDoc = _interopRequireWildcard(require("./helpDoc.js"));
var InternalSpan = _interopRequireWildcard(require("./helpDoc/span.js"));
var InternalPrimitive = _interopRequireWildcard(require("./primitive.js"));
var InternalNumberPrompt = _interopRequireWildcard(require("./prompt/number.js"));
var InternalSelectPrompt = _interopRequireWildcard(require("./prompt/select.js"));
var InternalUsage = _interopRequireWildcard(require("./usage.js"));
var InternalValidationError = _interopRequireWildcard(require("./validationError.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
const ArgsSymbolKey = "@effect/cli/Args";
/** @internal */
const ArgsTypeId = exports.ArgsTypeId = /*#__PURE__*/Symbol.for(ArgsSymbolKey);
const proto = {
  [ArgsTypeId]: {
    _A: _ => _
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
// =============================================================================
// Refinements
// =============================================================================
/** @internal */
const isArgs = u => typeof u === "object" && u != null && ArgsTypeId in u;
/** @internal */
exports.isArgs = isArgs;
const isInstruction = self => self;
/** @internal */
exports.isInstruction = isInstruction;
const isEmpty = self => self._tag === "Empty";
/** @internal */
exports.isEmpty = isEmpty;
const isSingle = self => self._tag === "Single";
/** @internal */
exports.isSingle = isSingle;
const isBoth = self => self._tag === "Both";
/** @internal */
exports.isBoth = isBoth;
const isMap = self => self._tag === "Map";
/** @internal */
exports.isMap = isMap;
const isVariadic = self => self._tag === "Variadic";
/** @internal */
exports.isVariadic = isVariadic;
const isWithDefault = self => self._tag === "WithDefault";
/** @internal */
exports.isWithDefault = isWithDefault;
const isWithFallbackConfig = self => self._tag === "WithFallbackConfig";
// =============================================================================
// Constructors
// =============================================================================
/** @internal */
exports.isWithFallbackConfig = isWithFallbackConfig;
const all = function () {
  if (arguments.length === 1) {
    if (isArgs(arguments[0])) {
      return map(arguments[0], x => [x]);
    } else if (Arr.isArray(arguments[0])) {
      return allTupled(arguments[0]);
    } else {
      const entries = Object.entries(arguments[0]);
      let result = map(entries[0][1], value => ({
        [entries[0][0]]: value
      }));
      if (entries.length === 1) {
        return result;
      }
      const rest = entries.slice(1);
      for (const [key, options] of rest) {
        result = map(makeBoth(result, options), ([record, value]) => ({
          ...record,
          [key]: value
        }));
      }
      return result;
    }
  }
  return allTupled(arguments[0]);
};
/** @internal */
exports.all = all;
const boolean = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.boolean(Option.none()));
/** @internal */
exports.boolean = boolean;
const choice = (choices, config) => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.choice(choices));
/** @internal */
exports.choice = choice;
const date = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.date);
/** @internal */
exports.date = date;
const directory = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.path("directory", config?.exists || "either"));
/** @internal */
exports.directory = directory;
const file = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.path("file", config?.exists || "either"));
/** @internal */
exports.file = file;
const fileContent = config => mapEffect(file({
  ...config,
  exists: "yes"
}), path => Effect.mapError(InternalFiles.read(path), e => InternalHelpDoc.p(e)));
/** @internal */
exports.fileContent = fileContent;
const fileParse = config => mapEffect(fileText(config), ([path, content]) => Effect.mapError(InternalFiles.parse(path, content, config?.format), e => InternalHelpDoc.p(e)));
/** @internal */
exports.fileParse = fileParse;
const fileSchema = (schema, config) => withSchema(fileParse(config), schema);
/** @internal */
exports.fileSchema = fileSchema;
const fileText = config => mapEffect(file({
  ...config,
  exists: "yes"
}), path => Effect.mapError(InternalFiles.readString(path), e => InternalHelpDoc.p(e)));
/** @internal */
exports.fileText = fileText;
const float = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.float);
/** @internal */
exports.float = float;
const integer = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.integer);
/** @internal */
exports.integer = integer;
const none = exports.none = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "Empty";
  return op;
})();
/** @internal */
const path = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.path("either", config?.exists || "either"));
/** @internal */
exports.path = path;
const redacted = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.redacted);
/** @internal */
exports.redacted = redacted;
const secret = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.secret);
/** @internal */
exports.secret = secret;
const text = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.text);
// =============================================================================
// Combinators
// =============================================================================
/** @internal */
exports.text = text;
const atLeast = exports.atLeast = /*#__PURE__*/(0, _Function.dual)(2, (self, times) => makeVariadic(self, Option.some(times), Option.none()));
/** @internal */
const atMost = exports.atMost = /*#__PURE__*/(0, _Function.dual)(2, (self, times) => makeVariadic(self, Option.none(), Option.some(times)));
/** @internal */
const between = exports.between = /*#__PURE__*/(0, _Function.dual)(3, (self, min, max) => makeVariadic(self, Option.some(min), Option.some(max)));
/** @internal */
const getHelp = self => getHelpInternal(self);
/** @internal */
exports.getHelp = getHelp;
const getIdentifier = self => getIdentifierInternal(self);
/** @internal */
exports.getIdentifier = getIdentifier;
const getMinSize = self => getMinSizeInternal(self);
/** @internal */
exports.getMinSize = getMinSize;
const getMaxSize = self => getMaxSizeInternal(self);
/** @internal */
exports.getMaxSize = getMaxSize;
const getUsage = self => getUsageInternal(self);
/** @internal */
exports.getUsage = getUsage;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapEffect(self, a => Effect.succeed(f(a))));
/** @internal */
const mapEffect = exports.mapEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => makeMap(self, f));
/** @internal */
const mapTryCatch = exports.mapTryCatch = /*#__PURE__*/(0, _Function.dual)(3, (self, f, onError) => mapEffect(self, a => {
  try {
    return Either.right(f(a));
  } catch (e) {
    return Either.left(onError(e));
  }
}));
/** @internal */
const optional = self => makeWithDefault(map(self, Option.some), Option.none());
/** @internal */
exports.optional = optional;
const repeated = self => makeVariadic(self, Option.none(), Option.none());
/** @internal */
exports.repeated = repeated;
const validate = exports.validate = /*#__PURE__*/(0, _Function.dual)(3, (self, args, config) => validateInternal(self, args, config));
/** @internal */
const withDefault = exports.withDefault = /*#__PURE__*/(0, _Function.dual)(2, (self, fallback) => makeWithDefault(self, fallback));
/** @internal */
const withFallbackConfig = exports.withFallbackConfig = /*#__PURE__*/(0, _Function.dual)(2, (self, config) => {
  if (isInstruction(self) && isWithDefault(self)) {
    return makeWithDefault(withFallbackConfig(self.args, config), self.fallback);
  }
  return makeWithFallbackConfig(self, config);
});
/** @internal */
const withSchema = exports.withSchema = /*#__PURE__*/(0, _Function.dual)(2, (self, schema) => {
  const decode = ParseResult.decode(schema);
  return mapEffect(self, _ => Effect.mapError(decode(_), issue => InternalHelpDoc.p(ParseResult.TreeFormatter.formatIssueSync(issue))));
});
/** @internal */
const withDescription = exports.withDescription = /*#__PURE__*/(0, _Function.dual)(2, (self, description) => withDescriptionInternal(self, description));
/** @internal */
const wizard = exports.wizard = /*#__PURE__*/(0, _Function.dual)(2, (self, config) => wizardInternal(self, config));
// =============================================================================
// Internals
// =============================================================================
const allTupled = arg => {
  if (arg.length === 0) {
    return none;
  }
  if (arg.length === 1) {
    return map(arg[0], x => [x]);
  }
  let result = map(arg[0], x => [x]);
  for (let i = 1; i < arg.length; i++) {
    const curr = arg[i];
    result = map(makeBoth(result, curr), ([a, b]) => [...a, b]);
  }
  return result;
};
const getHelpInternal = self => {
  switch (self._tag) {
    case "Empty":
      {
        return InternalHelpDoc.empty;
      }
    case "Single":
      {
        return InternalHelpDoc.descriptionList([[InternalSpan.weak(self.name), InternalHelpDoc.sequence(InternalHelpDoc.p(InternalPrimitive.getHelp(self.primitiveType)), self.description)]]);
      }
    case "Map":
      {
        return getHelpInternal(self.args);
      }
    case "Both":
      {
        return InternalHelpDoc.sequence(getHelpInternal(self.left), getHelpInternal(self.right));
      }
    case "Variadic":
      {
        const help = getHelpInternal(self.args);
        return InternalHelpDoc.mapDescriptionList(help, (oldSpan, oldBlock) => {
          const min = getMinSizeInternal(self);
          const max = getMaxSizeInternal(self);
          const newSpan = InternalSpan.text(Option.isSome(self.max) ? ` ${min} - ${max}` : min === 0 ? "..." : ` ${min}+`);
          const newBlock = InternalHelpDoc.p(Option.isSome(self.max) ? `This argument must be repeated at least ${min} times and may be repeated up to ${max} times.` : min === 0 ? "This argument may be repeated zero or more times." : `This argument must be repeated at least ${min} times.`);
          return [InternalSpan.concat(oldSpan, newSpan), InternalHelpDoc.sequence(oldBlock, newBlock)];
        });
      }
    case "WithDefault":
      {
        return InternalHelpDoc.mapDescriptionList(getHelpInternal(self.args), (span, block) => {
          const optionalDescription = Option.isOption(self.fallback) ? Option.match(self.fallback, {
            onNone: () => InternalHelpDoc.p("This setting is optional."),
            onSome: fallbackValue => {
              const inspectableValue = Predicate.isObject(fallbackValue) ? fallbackValue : String(fallbackValue);
              const displayValue = Inspectable.toStringUnknown(inspectableValue, 0);
              return InternalHelpDoc.p(`This setting is optional. Defaults to: ${displayValue}`);
            }
          }) : InternalHelpDoc.p("This setting is optional.");
          return [span, InternalHelpDoc.sequence(block, optionalDescription)];
        });
      }
    case "WithFallbackConfig":
      {
        return InternalHelpDoc.mapDescriptionList(getHelpInternal(self.args), (span, block) => [span, InternalHelpDoc.sequence(block, InternalHelpDoc.p("This argument can be set from environment variables."))]);
      }
  }
};
const getIdentifierInternal = self => {
  switch (self._tag) {
    case "Empty":
      {
        return Option.none();
      }
    case "Single":
      {
        return Option.some(self.name);
      }
    case "Map":
    case "Variadic":
    case "WithDefault":
    case "WithFallbackConfig":
      {
        return getIdentifierInternal(self.args);
      }
    case "Both":
      {
        const ids = Arr.getSomes([getIdentifierInternal(self.left), getIdentifierInternal(self.right)]);
        return Arr.match(ids, {
          onEmpty: () => Option.none(),
          onNonEmpty: ids => Option.some(Arr.join(ids, ", "))
        });
      }
  }
};
const getMinSizeInternal = self => {
  switch (self._tag) {
    case "Empty":
    case "WithDefault":
    case "WithFallbackConfig":
      {
        return 0;
      }
    case "Single":
      {
        return 1;
      }
    case "Map":
      {
        return getMinSizeInternal(self.args);
      }
    case "Both":
      {
        const leftMinSize = getMinSizeInternal(self.left);
        const rightMinSize = getMinSizeInternal(self.right);
        return leftMinSize + rightMinSize;
      }
    case "Variadic":
      {
        const argsMinSize = getMinSizeInternal(self.args);
        return Math.floor(Option.getOrElse(self.min, () => 0) * argsMinSize);
      }
  }
};
const getMaxSizeInternal = self => {
  switch (self._tag) {
    case "Empty":
      {
        return 0;
      }
    case "Single":
      {
        return 1;
      }
    case "Map":
    case "WithDefault":
    case "WithFallbackConfig":
      {
        return getMaxSizeInternal(self.args);
      }
    case "Both":
      {
        const leftMaxSize = getMaxSizeInternal(self.left);
        const rightMaxSize = getMaxSizeInternal(self.right);
        return leftMaxSize + rightMaxSize;
      }
    case "Variadic":
      {
        const argsMaxSize = getMaxSizeInternal(self.args);
        return Math.floor(Option.getOrElse(self.max, () => Number.MAX_SAFE_INTEGER / 2) * argsMaxSize);
      }
  }
};
const getUsageInternal = self => {
  switch (self._tag) {
    case "Empty":
      {
        return InternalUsage.empty;
      }
    case "Single":
      {
        return InternalUsage.named(Arr.of(self.name), InternalPrimitive.getChoices(self.primitiveType));
      }
    case "Map":
      {
        return getUsageInternal(self.args);
      }
    case "Both":
      {
        return InternalUsage.concat(getUsageInternal(self.left), getUsageInternal(self.right));
      }
    case "Variadic":
      {
        return InternalUsage.repeated(getUsageInternal(self.args));
      }
    case "WithDefault":
    case "WithFallbackConfig":
      {
        return InternalUsage.optional(getUsageInternal(self.args));
      }
  }
};
const makeSingle = (pseudoName, primitiveType, description = InternalHelpDoc.empty) => {
  const op = Object.create(proto);
  op._tag = "Single";
  op.name = `<${Option.getOrElse(pseudoName, () => InternalPrimitive.getTypeName(primitiveType))}>`;
  op.pseudoName = pseudoName;
  op.primitiveType = primitiveType;
  op.description = description;
  return op;
};
const makeMap = (self, f) => {
  const op = Object.create(proto);
  op._tag = "Map";
  op.args = self;
  op.f = f;
  return op;
};
const makeBoth = (left, right) => {
  const op = Object.create(proto);
  op._tag = "Both";
  op.left = left;
  op.right = right;
  return op;
};
const makeWithDefault = (self, fallback) => {
  const op = Object.create(proto);
  op._tag = "WithDefault";
  op.args = self;
  op.fallback = fallback;
  return op;
};
const makeWithFallbackConfig = (args, config) => {
  const op = Object.create(proto);
  op._tag = "WithFallbackConfig";
  op.args = args;
  op.config = config;
  return op;
};
const makeVariadic = (args, min, max) => {
  const op = Object.create(proto);
  op._tag = "Variadic";
  op.args = args;
  op.min = min;
  op.max = max;
  return op;
};
const validateInternal = (self, args, config) => {
  switch (self._tag) {
    case "Empty":
      {
        return Effect.succeed([args, undefined]);
      }
    case "Single":
      {
        return Effect.suspend(() => {
          return Arr.matchLeft(args, {
            onEmpty: () => {
              const choices = InternalPrimitive.getChoices(self.primitiveType);
              if (Option.isSome(self.pseudoName) && Option.isSome(choices)) {
                return Effect.fail(InternalValidationError.missingValue(InternalHelpDoc.p(`Missing argument <${self.pseudoName.value}> with choices ${choices.value}`)));
              }
              if (Option.isSome(self.pseudoName)) {
                return Effect.fail(InternalValidationError.missingValue(InternalHelpDoc.p(`Missing argument <${self.pseudoName.value}>`)));
              }
              if (Option.isSome(choices)) {
                return Effect.fail(InternalValidationError.missingValue(InternalHelpDoc.p(`Missing argument ${InternalPrimitive.getTypeName(self.primitiveType)} with choices ${choices.value}`)));
              }
              return Effect.fail(InternalValidationError.missingValue(InternalHelpDoc.p(`Missing argument ${InternalPrimitive.getTypeName(self.primitiveType)}`)));
            },
            onNonEmpty: (head, tail) => InternalPrimitive.validate(self.primitiveType, Option.some(head), config).pipe(Effect.mapBoth({
              onFailure: text => InternalValidationError.invalidArgument(InternalHelpDoc.p(text)),
              onSuccess: a => [tail, a]
            }))
          });
        });
      }
    case "Map":
      {
        return validateInternal(self.args, args, config).pipe(Effect.flatMap(([leftover, a]) => Effect.matchEffect(self.f(a), {
          onFailure: doc => Effect.fail(InternalValidationError.invalidArgument(doc)),
          onSuccess: b => Effect.succeed([leftover, b])
        })));
      }
    case "Both":
      {
        return validateInternal(self.left, args, config).pipe(Effect.flatMap(([args, a]) => validateInternal(self.right, args, config).pipe(Effect.map(([args, b]) => [args, [a, b]]))));
      }
    case "Variadic":
      {
        const min1 = Option.getOrElse(self.min, () => 0);
        const max1 = Option.getOrElse(self.max, () => Number.MAX_SAFE_INTEGER);
        const loop = (args, acc) => {
          if (acc.length >= max1) {
            return Effect.succeed([args, acc]);
          }
          return validateInternal(self.args, args, config).pipe(Effect.matchEffect({
            onFailure: failure => acc.length >= min1 && Arr.isEmptyReadonlyArray(args) ? Effect.succeed([args, acc]) : Effect.fail(failure),
            onSuccess: ([args, a]) => loop(args, Arr.append(acc, a))
          }));
        };
        return loop(args, Arr.empty()).pipe(Effect.map(([args, acc]) => [args, acc]));
      }
    case "WithDefault":
      {
        return validateInternal(self.args, args, config).pipe(Effect.catchTag("MissingValue", () => Effect.succeed([args, self.fallback])));
      }
    case "WithFallbackConfig":
      {
        return validateInternal(self.args, args, config).pipe(Effect.catchTag("MissingValue", e => Effect.map(Effect.catchAll(self.config, e2 => {
          if (ConfigError.isMissingDataOnly(e2)) {
            const help = InternalHelpDoc.p(String(e2));
            const error = InternalValidationError.invalidValue(help);
            return Effect.fail(error);
          }
          return Effect.fail(e);
        }), value => [args, value])));
      }
  }
};
const withDescriptionInternal = (self, description) => {
  switch (self._tag) {
    case "Empty":
      {
        return none;
      }
    case "Single":
      {
        const desc = InternalHelpDoc.sequence(self.description, InternalHelpDoc.p(description));
        return makeSingle(self.pseudoName, self.primitiveType, desc);
      }
    case "Map":
      {
        return makeMap(withDescriptionInternal(self.args, description), self.f);
      }
    case "Both":
      {
        return makeBoth(withDescriptionInternal(self.left, description), withDescriptionInternal(self.right, description));
      }
    case "Variadic":
      {
        return makeVariadic(withDescriptionInternal(self.args, description), self.min, self.max);
      }
    case "WithDefault":
      {
        return makeWithDefault(withDescriptionInternal(self.args, description), self.fallback);
      }
    case "WithFallbackConfig":
      {
        return makeWithFallbackConfig(withDescriptionInternal(self.args, description), self.config);
      }
  }
};
const wizardInternal = (self, config) => {
  switch (self._tag) {
    case "Empty":
      {
        return Effect.succeed(Arr.empty());
      }
    case "Single":
      {
        const help = getHelpInternal(self);
        return InternalPrimitive.wizard(self.primitiveType, help).pipe(Effect.zipLeft(Console.log()), Effect.flatMap(input => {
          const args = Arr.of(input);
          return validateInternal(self, args, config).pipe(Effect.as(args));
        }));
      }
    case "Map":
      {
        return wizardInternal(self.args, config).pipe(Effect.tap(args => validateInternal(self.args, args, config)));
      }
    case "Both":
      {
        return Effect.zipWith(wizardInternal(self.left, config), wizardInternal(self.right, config), (left, right) => Arr.appendAll(left, right)).pipe(Effect.tap(args => validateInternal(self, args, config)));
      }
    case "Variadic":
      {
        const repeatHelp = InternalHelpDoc.p("How many times should this argument should be repeated?");
        const message = (0, _Function.pipe)(getHelpInternal(self), InternalHelpDoc.sequence(repeatHelp));
        return InternalNumberPrompt.integer({
          message: InternalHelpDoc.toAnsiText(message).trimEnd(),
          min: getMinSizeInternal(self),
          max: getMaxSizeInternal(self)
        }).pipe(Effect.zipLeft(Console.log()), Effect.flatMap(n => n <= 0 ? Effect.succeed(Arr.empty()) : Ref.make(Arr.empty()).pipe(Effect.flatMap(ref => wizardInternal(self.args, config).pipe(Effect.flatMap(args => Ref.update(ref, Arr.appendAll(args))), Effect.repeatN(n - 1), Effect.zipRight(Ref.get(ref)), Effect.tap(args => validateInternal(self, args, config)))))));
      }
    case "WithDefault":
      {
        const defaultHelp = InternalHelpDoc.p(`This argument is optional - use the default?`);
        const message = (0, _Function.pipe)(getHelpInternal(self.args), InternalHelpDoc.sequence(defaultHelp));
        return InternalSelectPrompt.select({
          message: InternalHelpDoc.toAnsiText(message).trimEnd(),
          choices: [{
            title: `Default ['${JSON.stringify(self.fallback)}']`,
            value: true
          }, {
            title: "Custom",
            value: false
          }]
        }).pipe(Effect.zipLeft(Console.log()), Effect.flatMap(useFallback => useFallback ? Effect.succeed(Arr.empty()) : wizardInternal(self.args, config)));
      }
    case "WithFallbackConfig":
      {
        const defaultHelp = InternalHelpDoc.p(`Try load this option from the environment?`);
        const message = (0, _Function.pipe)(getHelpInternal(self.args), InternalHelpDoc.sequence(defaultHelp));
        return InternalSelectPrompt.select({
          message: InternalHelpDoc.toAnsiText(message).trimEnd(),
          choices: [{
            title: `Use environment variables`,
            value: true
          }, {
            title: "Custom",
            value: false
          }]
        }).pipe(Effect.zipLeft(Console.log()), Effect.flatMap(useFallback => useFallback ? Effect.succeed(Arr.empty()) : wizardInternal(self.args, config)));
      }
  }
};
// =============================================================================
// Completion Internals
// =============================================================================
const getShortDescription = self => {
  switch (self._tag) {
    case "Empty":
    case "Both":
      {
        return "";
      }
    case "Single":
      {
        return InternalSpan.getText(InternalHelpDoc.getSpan(self.description));
      }
    case "Map":
    case "Variadic":
    case "WithDefault":
    case "WithFallbackConfig":
      {
        return getShortDescription(self.args);
      }
  }
};
/** @internal */
const getFishCompletions = self => {
  switch (self._tag) {
    case "Empty":
      {
        return Arr.empty();
      }
    case "Single":
      {
        const description = getShortDescription(self);
        return (0, _Function.pipe)(InternalPrimitive.getFishCompletions(self.primitiveType), Arr.appendAll(description.length === 0 ? Arr.empty() : Arr.of(`-d '${description}'`)), Arr.join(" "), Arr.of);
      }
    case "Both":
      {
        return (0, _Function.pipe)(getFishCompletions(self.left), Arr.appendAll(getFishCompletions(self.right)));
      }
    case "Map":
    case "Variadic":
    case "WithDefault":
    case "WithFallbackConfig":
      {
        return getFishCompletions(self.args);
      }
  }
};
exports.getFishCompletions = getFishCompletions;
const getZshCompletions = (self, state = {
  multiple: false,
  optional: false
}) => {
  switch (self._tag) {
    case "Empty":
      {
        return Arr.empty();
      }
    case "Single":
      {
        const multiple = state.multiple ? "*" : "";
        const optional = state.optional ? "::" : ":";
        const shortDescription = getShortDescription(self);
        const description = shortDescription.length > 0 ? ` -- ${shortDescription}` : "";
        const possibleValues = InternalPrimitive.getZshCompletions(self.primitiveType);
        return possibleValues.length === 0 ? Arr.empty() : Arr.of(`${multiple}${optional}${self.name}${description}${possibleValues}`);
      }
    case "Map":
      {
        return getZshCompletions(self.args, state);
      }
    case "Both":
      {
        const left = getZshCompletions(self.left, state);
        const right = getZshCompletions(self.right, state);
        return Arr.appendAll(left, right);
      }
    case "Variadic":
      {
        return Option.isSome(self.max) && self.max.value > 1 ? getZshCompletions(self.args, {
          ...state,
          multiple: true
        }) : getZshCompletions(self.args, state);
      }
    case "WithDefault":
    case "WithFallbackConfig":
      {
        return getZshCompletions(self.args, {
          ...state,
          optional: true
        });
      }
  }
};
exports.getZshCompletions = getZshCompletions;
//# sourceMappingURL=args.js.map