"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wizard = exports.withSubcommands = exports.withHandler = exports.withDescription = exports.transformHandler = exports.run = exports.provideSync = exports.provideEffectDiscard = exports.provideEffect = exports.provide = exports.prompt = exports.make = exports.getZshCompletions = exports.getUsage = exports.getSubcommands = exports.getNames = exports.getHelp = exports.getFishCompletions = exports.getBashCompletions = exports.fromDescriptor = exports.TypeId = void 0;
var Arr = _interopRequireWildcard(require("effect/Array"));
var Context = _interopRequireWildcard(require("effect/Context"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Effectable = _interopRequireWildcard(require("effect/Effectable"));
var _Function = require("effect/Function");
var _GlobalValue = require("effect/GlobalValue");
var _Pipeable = require("effect/Pipeable");
var ValidationError = _interopRequireWildcard(require("../ValidationError.js"));
var InternalArgs = _interopRequireWildcard(require("./args.js"));
var InternalCliApp = _interopRequireWildcard(require("./cliApp.js"));
var InternalDescriptor = _interopRequireWildcard(require("./commandDescriptor.js"));
var InternalOptions = _interopRequireWildcard(require("./options.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
const CommandSymbolKey = "@effect/cli/Command";
/** @internal */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for(CommandSymbolKey);
const parseConfig = config => {
  const args = [];
  let argsIndex = 0;
  const options = [];
  let optionsIndex = 0;
  function parse(config) {
    const tree = {};
    for (const key in config) {
      tree[key] = parseValue(config[key]);
    }
    return tree;
  }
  function parseValue(value) {
    if (Arr.isArray(value)) {
      return {
        _tag: "Array",
        children: Arr.map(value, parseValue)
      };
    } else if (InternalArgs.isArgs(value)) {
      args.push(value);
      return {
        _tag: "Args",
        index: argsIndex++
      };
    } else if (InternalOptions.isOptions(value)) {
      options.push(value);
      return {
        _tag: "Options",
        index: optionsIndex++
      };
    } else {
      return {
        _tag: "ParsedConfig",
        tree: parse(value)
      };
    }
  }
  return {
    args,
    options,
    tree: parse(config)
  };
};
const reconstructConfigTree = (tree, args, options) => {
  const output = {};
  for (const key in tree) {
    output[key] = nodeValue(tree[key]);
  }
  return output;
  function nodeValue(node) {
    if (node._tag === "Args") {
      return args[node.index];
    } else if (node._tag === "Options") {
      return options[node.index];
    } else if (node._tag === "Array") {
      return Arr.map(node.children, nodeValue);
    } else {
      return reconstructConfigTree(node.tree, args, options);
    }
  }
};
const Prototype = {
  ...Effectable.CommitPrototype,
  [TypeId]: TypeId,
  commit() {
    return this.tag;
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
const registeredDescriptors = /*#__PURE__*/(0, _GlobalValue.globalValue)("@effect/cli/Command/registeredDescriptors", () => new WeakMap());
const getDescriptor = self => registeredDescriptors.get(self.tag) ?? self.descriptor;
const makeProto = (descriptor, handler, tag, transform = _Function.identity) => {
  const self = Object.create(Prototype);
  self.descriptor = descriptor;
  self.handler = handler;
  self.transform = transform;
  self.tag = tag;
  return self;
};
const makeDerive = (self, options) => {
  const command = Object.create(Prototype);
  command.descriptor = options.descriptor ?? self.descriptor;
  command.handler = options.handler ?? self.handler;
  command.transform = options.transform ? (effect, opts) => options.transform(self.transform(effect, opts), opts) : self.transform;
  command.tag = self.tag;
  return command;
};
/** @internal */
const fromDescriptor = exports.fromDescriptor = /*#__PURE__*/(0, _Function.dual)(args => InternalDescriptor.isCommand(args[0]), (descriptor, handler) => {
  const self = makeProto(descriptor, handler ?? (_ => Effect.failSync(() => ValidationError.helpRequested(getDescriptor(self)))), Context.GenericTag(`@effect/cli/Command/(${Arr.fromIterable(InternalDescriptor.getNames(descriptor)).join("|")})`));
  return self;
});
const makeDescriptor = (name, config) => {
  const {
    args,
    options,
    tree
  } = parseConfig(config);
  return InternalDescriptor.map(InternalDescriptor.make(name, InternalOptions.all(options), InternalArgs.all(args)), ({
    args,
    options
  }) => reconstructConfigTree(tree, args, options));
};
/** @internal */
const make = (name, config = {}, handler) => fromDescriptor(makeDescriptor(name, config), handler);
/** @internal */
exports.make = make;
const getHelp = (self, config) => InternalDescriptor.getHelp(self.descriptor, config);
/** @internal */
exports.getHelp = getHelp;
const getNames = self => InternalDescriptor.getNames(self.descriptor);
/** @internal */
exports.getNames = getNames;
const getBashCompletions = (self, programName) => InternalDescriptor.getBashCompletions(self.descriptor, programName);
/** @internal */
exports.getBashCompletions = getBashCompletions;
const getFishCompletions = (self, programName) => InternalDescriptor.getFishCompletions(self.descriptor, programName);
/** @internal */
exports.getFishCompletions = getFishCompletions;
const getZshCompletions = (self, programName) => InternalDescriptor.getZshCompletions(self.descriptor, programName);
/** @internal */
exports.getZshCompletions = getZshCompletions;
const getSubcommands = self => InternalDescriptor.getSubcommands(self.descriptor);
/** @internal */
exports.getSubcommands = getSubcommands;
const getUsage = self => InternalDescriptor.getUsage(self.descriptor);
exports.getUsage = getUsage;
const mapDescriptor = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => makeDerive(self, {
  descriptor: f(self.descriptor)
}));
/** @internal */
const prompt = (name, prompt, handler) => makeProto(InternalDescriptor.map(InternalDescriptor.prompt(name, prompt), _ => _.value), handler, Context.GenericTag(`@effect/cli/Prompt/${name}`));
/** @internal */
exports.prompt = prompt;
const withHandler = exports.withHandler = /*#__PURE__*/(0, _Function.dual)(2, (self, handler) => makeDerive(self, {
  handler,
  transform: _Function.identity
}));
/** @internal */
const transformHandler = exports.transformHandler = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => makeDerive(self, {
  transform: f
}));
/** @internal */
const provide = exports.provide = /*#__PURE__*/(0, _Function.dual)(2, (self, layer) => makeDerive(self, {
  transform: (effect, config) => Effect.provide(effect, typeof layer === "function" ? layer(config) : layer)
}));
/** @internal */
const provideEffect = exports.provideEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, effect_) => makeDerive(self, {
  transform: (self, config) => {
    const effect = typeof effect_ === "function" ? effect_(config) : effect_;
    return Effect.provideServiceEffect(self, tag, effect);
  }
}));
/** @internal */
const provideEffectDiscard = exports.provideEffectDiscard = /*#__PURE__*/(0, _Function.dual)(2, (self, effect_) => makeDerive(self, {
  transform: (self, config) => {
    const effect = typeof effect_ === "function" ? effect_(config) : effect_;
    return Effect.zipRight(effect, self);
  }
}));
/** @internal */
const provideSync = exports.provideSync = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, f) => makeDerive(self, {
  transform: (self, config) => {
    const service = typeof f === "function" ? f(config) : f;
    return Effect.provideService(self, tag, service);
  }
}));
/** @internal */
const withDescription = exports.withDescription = /*#__PURE__*/(0, _Function.dual)(2, (self, help) => mapDescriptor(self, InternalDescriptor.withDescription(help)));
/** @internal */
const withSubcommands = exports.withSubcommands = /*#__PURE__*/(0, _Function.dual)(2, (self, subcommands) => {
  const command = InternalDescriptor.withSubcommands(self.descriptor, Arr.map(subcommands, _ => [_.tag, _.descriptor]));
  const subcommandMap = Arr.reduce(subcommands, new Map(), (handlers, subcommand) => {
    handlers.set(subcommand.tag, subcommand);
    registeredDescriptors.set(subcommand.tag, subcommand.descriptor);
    return handlers;
  });
  function handler(args) {
    if (args.subcommand._tag === "Some") {
      const [tag, value] = args.subcommand.value;
      const subcommand = subcommandMap.get(tag);
      const subcommandEffect = subcommand.transform(subcommand.handler(value), value);
      return Effect.provideService(subcommandEffect, self.tag, args);
    }
    return self.handler(args);
  }
  return makeDerive(self, {
    descriptor: command,
    handler
  });
});
/** @internal */
const wizard = exports.wizard = /*#__PURE__*/(0, _Function.dual)(3, (self, prefix, config) => InternalDescriptor.wizard(self.descriptor, prefix, config));
/** @internal */
const run = exports.run = /*#__PURE__*/(0, _Function.dual)(2, (self, config) => {
  const app = InternalCliApp.make({
    ...config,
    command: self.descriptor
  });
  registeredDescriptors.set(self.tag, self.descriptor);
  const handler = args => self.transform(self.handler(args), args);
  return args => InternalCliApp.run(app, args, handler);
});
//# sourceMappingURL=command.js.map