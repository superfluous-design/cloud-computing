"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.text = exports.password = exports.hidden = void 0;
var Terminal = _interopRequireWildcard(require("@effect/platform/Terminal"));
var Ansi = _interopRequireWildcard(require("@effect/printer-ansi/Ansi"));
var Doc = _interopRequireWildcard(require("@effect/printer-ansi/AnsiDoc"));
var Optimize = _interopRequireWildcard(require("@effect/printer/Optimize"));
var Arr = _interopRequireWildcard(require("effect/Array"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Option = _interopRequireWildcard(require("effect/Option"));
var Redacted = _interopRequireWildcard(require("effect/Redacted"));
var InternalPrompt = _interopRequireWildcard(require("../prompt.js"));
var _action = require("./action.js");
var InternalAnsiUtils = _interopRequireWildcard(require("./ansi-utils.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
function getValue(state, options) {
  return state.value.length > 0 ? state.value : options.default;
}
const renderBeep = /*#__PURE__*/Doc.render(Doc.beep, {
  style: "pretty"
});
function renderClearScreen(state, options) {
  return Effect.gen(function* () {
    const terminal = yield* Terminal.Terminal;
    const columns = yield* terminal.columns;
    // Erase the current line and place the cursor in column one
    const resetCurrentLine = Doc.cat(Doc.eraseLine, Doc.cursorLeft);
    // Check for any error output
    const clearError = Option.match(state.error, {
      onNone: () => Doc.empty,
      onSome: error =>
      // If there was an error, move the cursor down to the final error line and
      // then clear all lines of error output
      Doc.cursorDown(InternalAnsiUtils.lines(error, columns)).pipe(
      // Add a leading newline to the error message to ensure that the corrrect
      // number of error lines are erased
      Doc.cat(InternalAnsiUtils.eraseText(`\n${error}`, columns)))
    });
    // Ensure that the prior prompt output is cleaned up
    const clearOutput = InternalAnsiUtils.eraseText(options.message, columns);
    // Concatenate and render all documents
    return clearError.pipe(Doc.cat(clearOutput), Doc.cat(resetCurrentLine), Optimize.optimize(Optimize.Deep), Doc.render({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderInput(nextState, options, submitted) {
  const text = getValue(nextState, options);
  const annotation = Option.match(nextState.error, {
    onNone: () => {
      if (submitted) {
        return Ansi.white;
      }
      if (nextState.value.length === 0) {
        return Ansi.blackBright;
      }
      return Ansi.combine(Ansi.underlined, Ansi.cyanBright);
    },
    onSome: () => Ansi.red
  });
  switch (options.type) {
    case "hidden":
      {
        return Doc.empty;
      }
    case "password":
      {
        return Doc.annotate(Doc.text("*".repeat(text.length)), annotation);
      }
    case "text":
      {
        return Doc.annotate(Doc.text(text), annotation);
      }
  }
}
function renderError(nextState, pointer) {
  return Option.match(nextState.error, {
    onNone: () => Doc.empty,
    onSome: error => Arr.match(error.split(/\r?\n/), {
      onEmpty: () => Doc.empty,
      onNonEmpty: errorLines => {
        const annotateLine = line => Doc.text(line).pipe(Doc.annotate(Ansi.combine(Ansi.italicized, Ansi.red)));
        const prefix = Doc.cat(Doc.annotate(pointer, Ansi.red), Doc.space);
        const lines = Arr.map(errorLines, str => annotateLine(str));
        return Doc.cursorSavePosition.pipe(Doc.cat(Doc.hardLine), Doc.cat(prefix), Doc.cat(Doc.align(Doc.vsep(lines))), Doc.cat(Doc.cursorRestorePosition));
      }
    })
  });
}
function renderOutput(nextState, leadingSymbol, trailingSymbol, options, submitted = false) {
  const annotateLine = line => Doc.annotate(Doc.text(line), Ansi.bold);
  const promptLines = options.message.split(/\r?\n/);
  const prefix = Doc.cat(leadingSymbol, Doc.space);
  if (Arr.isNonEmptyReadonlyArray(promptLines)) {
    const lines = Arr.map(promptLines, line => annotateLine(line));
    return prefix.pipe(Doc.cat(Doc.nest(Doc.vsep(lines), 2)), Doc.cat(Doc.space), Doc.cat(trailingSymbol), Doc.cat(Doc.space), Doc.cat(renderInput(nextState, options, submitted)));
  }
  return Doc.hsep([prefix, trailingSymbol, renderInput(nextState, options, submitted)]);
}
function renderNextFrame(state, options) {
  return Effect.gen(function* () {
    const terminal = yield* Terminal.Terminal;
    const columns = yield* terminal.columns;
    const figures = yield* InternalAnsiUtils.figures;
    const leadingSymbol = Doc.annotate(Doc.text("?"), Ansi.cyanBright);
    const trailingSymbol = Doc.annotate(figures.pointerSmall, Ansi.blackBright);
    const promptMsg = renderOutput(state, leadingSymbol, trailingSymbol, options);
    const errorMsg = renderError(state, figures.pointerSmall);
    return promptMsg.pipe(Doc.cat(errorMsg), Doc.cat(Doc.cursorMove(state.offset)), Optimize.optimize(Optimize.Deep), Doc.render({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission(state, options) {
  return Effect.gen(function* () {
    const terminal = yield* Terminal.Terminal;
    const columns = yield* terminal.columns;
    const figures = yield* InternalAnsiUtils.figures;
    const leadingSymbol = Doc.annotate(figures.tick, Ansi.green);
    const trailingSymbol = Doc.annotate(figures.ellipsis, Ansi.blackBright);
    const promptMsg = renderOutput(state, leadingSymbol, trailingSymbol, options, true);
    return promptMsg.pipe(Doc.cat(Doc.hardLine), Optimize.optimize(Optimize.Deep), Doc.render({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processBackspace(state) {
  if (state.cursor <= 0) {
    return Effect.succeed(_action.Action.Beep());
  }
  const beforeCursor = state.value.slice(0, state.cursor - 1);
  const afterCursor = state.value.slice(state.cursor);
  const cursor = state.cursor - 1;
  const value = `${beforeCursor}${afterCursor}`;
  return Effect.succeed(_action.Action.NextFrame({
    state: {
      ...state,
      cursor,
      value,
      error: Option.none()
    }
  }));
}
function processCursorLeft(state) {
  if (state.cursor <= 0) {
    return Effect.succeed(_action.Action.Beep());
  }
  const cursor = state.cursor - 1;
  const offset = state.offset - 1;
  return Effect.succeed(_action.Action.NextFrame({
    state: {
      ...state,
      cursor,
      offset,
      error: Option.none()
    }
  }));
}
function processCursorRight(state) {
  if (state.cursor >= state.value.length) {
    return Effect.succeed(_action.Action.Beep());
  }
  const cursor = Math.min(state.cursor + 1, state.value.length);
  const offset = Math.min(state.offset + 1, state.value.length);
  return Effect.succeed(_action.Action.NextFrame({
    state: {
      ...state,
      cursor,
      offset,
      error: Option.none()
    }
  }));
}
function processTab(state, options) {
  if (state.value === options.default) {
    return Effect.succeed(_action.Action.Beep());
  }
  const value = getValue(state, options);
  const cursor = value.length;
  return Effect.succeed(_action.Action.NextFrame({
    state: {
      ...state,
      value,
      cursor,
      error: Option.none()
    }
  }));
}
function defaultProcessor(input, state) {
  const beforeCursor = state.value.slice(0, state.cursor);
  const afterCursor = state.value.slice(state.cursor);
  const value = `${beforeCursor}${input}${afterCursor}`;
  const cursor = beforeCursor.length + 1;
  return Effect.succeed(_action.Action.NextFrame({
    state: {
      ...state,
      cursor,
      value,
      error: Option.none()
    }
  }));
}
const initialState = {
  cursor: 0,
  offset: 0,
  value: "",
  error: /*#__PURE__*/Option.none()
};
function handleRender(options) {
  return (state, action) => {
    return _action.Action.$match(action, {
      Beep: () => Effect.succeed(renderBeep),
      NextFrame: ({
        state
      }) => renderNextFrame(state, options),
      Submit: () => renderSubmission(state, options)
    });
  };
}
function handleProcess(options) {
  return (input, state) => {
    switch (input.key.name) {
      case "backspace":
        {
          return processBackspace(state);
        }
      case "left":
        {
          return processCursorLeft(state);
        }
      case "right":
        {
          return processCursorRight(state);
        }
      case "enter":
      case "return":
        {
          const value = getValue(state, options);
          return Effect.match(options.validate(value), {
            onFailure: error => _action.Action.NextFrame({
              state: {
                ...state,
                value,
                error: Option.some(error)
              }
            }),
            onSuccess: value => _action.Action.Submit({
              value
            })
          });
        }
      case "tab":
        {
          return processTab(state, options);
        }
      default:
        {
          const value = Option.getOrElse(input.input, () => "");
          return defaultProcessor(value, state);
        }
    }
  };
}
function handleClear(options) {
  return (state, _) => {
    return renderClearScreen(state, options);
  };
}
function basePrompt(options, type) {
  const opts = {
    default: "",
    type,
    validate: Effect.succeed,
    ...options
  };
  return InternalPrompt.custom(initialState, {
    render: handleRender(opts),
    process: handleProcess(opts),
    clear: handleClear(opts)
  });
}
/** @internal */
const hidden = options => basePrompt(options, "hidden").pipe(InternalPrompt.map(Redacted.make));
/** @internal */
exports.hidden = hidden;
const password = options => basePrompt(options, "password").pipe(InternalPrompt.map(Redacted.make));
/** @internal */
exports.password = password;
const text = options => basePrompt(options, "text");
exports.text = text;
//# sourceMappingURL=text.js.map