"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleClear = handleClear;
exports.multiSelect = void 0;
var Terminal = _interopRequireWildcard(require("@effect/platform/Terminal"));
var Ansi = _interopRequireWildcard(require("@effect/printer-ansi/Ansi"));
var Doc = _interopRequireWildcard(require("@effect/printer-ansi/AnsiDoc"));
var Optimize = _interopRequireWildcard(require("@effect/printer/Optimize"));
var Arr = _interopRequireWildcard(require("effect/Array"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Number = _interopRequireWildcard(require("effect/Number"));
var Option = _interopRequireWildcard(require("effect/Option"));
var InternalPrompt = _interopRequireWildcard(require("../prompt.js"));
var _action = require("./action.js");
var InternalAnsiUtils = _interopRequireWildcard(require("./ansi-utils.js"));
var _utils = require("./utils.js");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
const renderBeep = /*#__PURE__*/Doc.render(Doc.beep, {
  style: "pretty"
});
const NEWLINE_REGEX = /\r?\n/;
function renderOutput(leadingSymbol, trailingSymbol, options) {
  const annotateLine = line => Doc.annotate(Doc.text(line), Ansi.bold);
  const prefix = Doc.cat(leadingSymbol, Doc.space);
  return Arr.match(options.message.split(NEWLINE_REGEX), {
    onEmpty: () => Doc.hsep([prefix, trailingSymbol]),
    onNonEmpty: promptLines => {
      const lines = Arr.map(promptLines, line => annotateLine(line));
      return prefix.pipe(Doc.cat(Doc.nest(Doc.vsep(lines), 2)), Doc.cat(Doc.space), Doc.cat(trailingSymbol), Doc.cat(Doc.space));
    }
  });
}
function renderError(state, pointer) {
  return Option.match(state.error, {
    onNone: () => Doc.empty,
    onSome: error => Arr.match(error.split(NEWLINE_REGEX), {
      onEmpty: () => Doc.empty,
      onNonEmpty: errorLines => {
        const annotateLine = line => Doc.annotate(Doc.text(line), Ansi.combine(Ansi.italicized, Ansi.red));
        const prefix = Doc.cat(Doc.annotate(pointer, Ansi.red), Doc.space);
        const lines = Arr.map(errorLines, str => annotateLine(str));
        return Doc.cursorSavePosition.pipe(Doc.cat(Doc.hardLine), Doc.cat(prefix), Doc.cat(Doc.align(Doc.vsep(lines))), Doc.cat(Doc.cursorRestorePosition));
      }
    })
  });
}
function renderChoiceDescription(choice, isHighlighted) {
  if (!choice.disabled && choice.description && isHighlighted) {
    return Doc.char("-").pipe(Doc.cat(Doc.space), Doc.cat(Doc.text(choice.description)), Doc.annotate(Ansi.blackBright));
  }
  return Doc.empty;
}
const metaOptionsCount = 2;
function renderChoices(state, options, figures) {
  const choices = options.choices;
  const totalChoices = choices.length;
  const selectedCount = state.selectedIndices.size;
  const allSelected = selectedCount === totalChoices;
  const selectAllText = allSelected ? options?.selectNone ?? "Select None" : options?.selectAll ?? "Select All";
  const inverseSelectionText = options?.inverseSelection ?? "Inverse Selection";
  const metaOptions = [{
    title: selectAllText
  }, {
    title: inverseSelectionText
  }];
  const allChoices = [...metaOptions, ...choices];
  const toDisplay = (0, _utils.entriesToDisplay)(state.index, allChoices.length, options.maxPerPage);
  const documents = [];
  for (let index = toDisplay.startIndex; index < toDisplay.endIndex; index++) {
    const choice = allChoices[index];
    const isHighlighted = state.index === index;
    let prefix = Doc.space;
    if (index === toDisplay.startIndex && toDisplay.startIndex > 0) {
      prefix = figures.arrowUp;
    } else if (index === toDisplay.endIndex - 1 && toDisplay.endIndex < allChoices.length) {
      prefix = figures.arrowDown;
    }
    if (index < metaOptions.length) {
      // Meta options
      const title = isHighlighted ? Doc.annotate(Doc.text(choice.title), Ansi.cyanBright) : Doc.text(choice.title);
      documents.push(prefix.pipe(Doc.cat(Doc.space), Doc.cat(title)));
    } else {
      // Regular choices
      const choiceIndex = index - metaOptions.length;
      const isSelected = state.selectedIndices.has(choiceIndex);
      const checkbox = isSelected ? figures.checkboxOn : figures.checkboxOff;
      const annotatedCheckbox = isHighlighted ? Doc.annotate(checkbox, Ansi.cyanBright) : checkbox;
      const title = Doc.text(choice.title);
      const description = renderChoiceDescription(choice, isHighlighted);
      documents.push(prefix.pipe(Doc.cat(Doc.space), Doc.cat(annotatedCheckbox), Doc.cat(Doc.space), Doc.cat(title), Doc.cat(Doc.space), Doc.cat(description)));
    }
  }
  return Doc.vsep(documents);
}
function renderNextFrame(state, options) {
  return Effect.gen(function* () {
    const terminal = yield* Terminal.Terminal;
    const columns = yield* terminal.columns;
    const figures = yield* InternalAnsiUtils.figures;
    const choices = renderChoices(state, options, figures);
    const leadingSymbol = Doc.annotate(Doc.text("?"), Ansi.cyanBright);
    const trailingSymbol = Doc.annotate(figures.pointerSmall, Ansi.blackBright);
    const promptMsg = renderOutput(leadingSymbol, trailingSymbol, options);
    const error = renderError(state, figures.pointer);
    return Doc.cursorHide.pipe(Doc.cat(promptMsg), Doc.cat(Doc.hardLine), Doc.cat(choices), Doc.cat(error), Doc.render({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission(state, options) {
  return Effect.gen(function* () {
    const terminal = yield* Terminal.Terminal;
    const columns = yield* terminal.columns;
    const figures = yield* InternalAnsiUtils.figures;
    const selectedChoices = Array.from(state.selectedIndices).sort(Number.Order).map(index => options.choices[index].title);
    const selectedText = selectedChoices.join(", ");
    const selected = Doc.text(selectedText);
    const leadingSymbol = Doc.annotate(figures.tick, Ansi.green);
    const trailingSymbol = Doc.annotate(figures.ellipsis, Ansi.blackBright);
    const promptMsg = renderOutput(leadingSymbol, trailingSymbol, options);
    return promptMsg.pipe(Doc.cat(Doc.space), Doc.cat(Doc.annotate(selected, Ansi.white)), Doc.cat(Doc.hardLine), Doc.render({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processCursorUp(state, totalChoices) {
  const newIndex = state.index === 0 ? totalChoices - 1 : state.index - 1;
  return Effect.succeed(_action.Action.NextFrame({
    state: {
      ...state,
      index: newIndex
    }
  }));
}
function processCursorDown(state, totalChoices) {
  const newIndex = (state.index + 1) % totalChoices;
  return Effect.succeed(_action.Action.NextFrame({
    state: {
      ...state,
      index: newIndex
    }
  }));
}
function processSpace(state, options) {
  const selectedIndices = new Set(state.selectedIndices);
  if (state.index === 0) {
    if (state.selectedIndices.size === options.choices.length) {
      selectedIndices.clear();
    } else {
      for (let i = 0; i < options.choices.length; i++) {
        selectedIndices.add(i);
      }
    }
  } else if (state.index === 1) {
    for (let i = 0; i < options.choices.length; i++) {
      if (state.selectedIndices.has(i)) {
        selectedIndices.delete(i);
      } else {
        selectedIndices.add(i);
      }
    }
  } else {
    const choiceIndex = state.index - metaOptionsCount;
    if (selectedIndices.has(choiceIndex)) {
      selectedIndices.delete(choiceIndex);
    } else {
      selectedIndices.add(choiceIndex);
    }
  }
  return Effect.succeed(_action.Action.NextFrame({
    state: {
      ...state,
      selectedIndices
    }
  }));
}
function handleClear(options) {
  return Effect.gen(function* () {
    const terminal = yield* Terminal.Terminal;
    const columns = yield* terminal.columns;
    const clearPrompt = Doc.cat(Doc.eraseLine, Doc.cursorLeft);
    const text = "\n".repeat(Math.min(options.choices.length + 2, options.maxPerPage)) + options.message + 1;
    const clearOutput = InternalAnsiUtils.eraseText(text, columns);
    return clearOutput.pipe(Doc.cat(clearPrompt), Optimize.optimize(Optimize.Deep), Doc.render({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function handleProcess(options) {
  return (input, state) => {
    const totalChoices = options.choices.length + metaOptionsCount;
    switch (input.key.name) {
      case "k":
      case "up":
        {
          return processCursorUp({
            ...state,
            error: Option.none()
          }, totalChoices);
        }
      case "j":
      case "down":
      case "tab":
        {
          return processCursorDown({
            ...state,
            error: Option.none()
          }, totalChoices);
        }
      case "space":
        {
          return processSpace(state, options);
        }
      case "enter":
      case "return":
        {
          const selectedCount = state.selectedIndices.size;
          if (options.min !== undefined && selectedCount < options.min) {
            return Effect.succeed(_action.Action.NextFrame({
              state: {
                ...state,
                error: Option.some(`At least ${options.min} are required`)
              }
            }));
          }
          if (options.max !== undefined && selectedCount > options.max) {
            return Effect.succeed(_action.Action.NextFrame({
              state: {
                ...state,
                error: Option.some(`At most ${options.max} choices are allowed`)
              }
            }));
          }
          const selectedValues = Array.from(state.selectedIndices).sort(Number.Order).map(index => options.choices[index].value);
          return Effect.succeed(_action.Action.Submit({
            value: selectedValues
          }));
        }
      default:
        {
          return Effect.succeed(_action.Action.Beep());
        }
    }
  };
}
function handleRender(options) {
  return (state, action) => {
    return _action.Action.$match(action, {
      Beep: () => Effect.succeed(renderBeep),
      NextFrame: ({
        state
      }) => renderNextFrame(state, options),
      Submit: () => renderSubmission(state, options)
    });
  };
}
/** @internal */
const multiSelect = options => {
  const opts = {
    maxPerPage: 10,
    ...options
  };
  return InternalPrompt.custom({
    index: 0,
    selectedIndices: new Set(),
    error: Option.none()
  }, {
    render: handleRender(opts),
    process: handleProcess(opts),
    clear: () => handleClear(opts)
  });
};
exports.multiSelect = multiSelect;
//# sourceMappingURL=multi-select.js.map