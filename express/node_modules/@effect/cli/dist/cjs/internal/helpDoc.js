"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toAnsiText = exports.toAnsiDoc = exports.sequence = exports.p = exports.orElse = exports.mapDescriptionList = exports.isSequence = exports.isParagraph = exports.isHeader = exports.isEnumeration = exports.isEmpty = exports.isDescriptionList = exports.h3 = exports.h2 = exports.h1 = exports.getSpan = exports.enumeration = exports.empty = exports.descriptionList = exports.blocks = void 0;
var Ansi = _interopRequireWildcard(require("@effect/printer-ansi/Ansi"));
var Doc = _interopRequireWildcard(require("@effect/printer-ansi/AnsiDoc"));
var Optimize = _interopRequireWildcard(require("@effect/printer/Optimize"));
var Arr = _interopRequireWildcard(require("effect/Array"));
var _Function = require("effect/Function");
var InternalSpan = _interopRequireWildcard(require("./helpDoc/span.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/** @internal */
const isEmpty = helpDoc => helpDoc._tag === "Empty";
/** @internal */
exports.isEmpty = isEmpty;
const isHeader = helpDoc => helpDoc._tag === "Header";
/** @internal */
exports.isHeader = isHeader;
const isParagraph = helpDoc => helpDoc._tag === "Paragraph";
/** @internal */
exports.isParagraph = isParagraph;
const isDescriptionList = helpDoc => helpDoc._tag === "DescriptionList";
/** @internal */
exports.isDescriptionList = isDescriptionList;
const isEnumeration = helpDoc => helpDoc._tag === "Enumeration";
/** @internal */
exports.isEnumeration = isEnumeration;
const isSequence = helpDoc => helpDoc._tag === "Sequence";
/** @internal */
exports.isSequence = isSequence;
const empty = exports.empty = {
  _tag: "Empty"
};
/** @internal */
const sequence = exports.sequence = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {
  if (isEmpty(self)) {
    return that;
  }
  if (isEmpty(that)) {
    return self;
  }
  return {
    _tag: "Sequence",
    left: self,
    right: that
  };
});
/** @internal */
const orElse = exports.orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => isEmpty(self) ? that : self);
/** @internal */
const blocks = helpDocs => {
  const elements = Arr.fromIterable(helpDocs);
  if (Arr.isNonEmptyReadonlyArray(elements)) {
    return elements.slice(1).reduce(sequence, elements[0]);
  }
  return empty;
};
/** @internal */
exports.blocks = blocks;
const getSpan = self => isHeader(self) || isParagraph(self) ? self.value : InternalSpan.empty;
/** @internal */
exports.getSpan = getSpan;
const descriptionList = definitions => ({
  _tag: "DescriptionList",
  definitions
});
/** @internal */
exports.descriptionList = descriptionList;
const enumeration = elements => ({
  _tag: "Enumeration",
  elements
});
/** @internal */
exports.enumeration = enumeration;
const h1 = value => ({
  _tag: "Header",
  value: typeof value === "string" ? InternalSpan.text(value) : value,
  level: 1
});
/** @internal */
exports.h1 = h1;
const h2 = value => ({
  _tag: "Header",
  value: typeof value === "string" ? InternalSpan.text(value) : value,
  level: 2
});
/** @internal */
exports.h2 = h2;
const h3 = value => ({
  _tag: "Header",
  value: typeof value === "string" ? InternalSpan.text(value) : value,
  level: 3
});
/** @internal */
exports.h3 = h3;
const p = value => ({
  _tag: "Paragraph",
  value: typeof value === "string" ? InternalSpan.text(value) : value
});
/** @internal */
exports.p = p;
const mapDescriptionList = exports.mapDescriptionList = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => isDescriptionList(self) ? descriptionList(Arr.map(self.definitions, ([span, helpDoc]) => f(span, helpDoc))) : self);
/** @internal */
const toAnsiDoc = self => Optimize.optimize(toAnsiDocInternal(self), Optimize.Deep);
/** @internal */
exports.toAnsiDoc = toAnsiDoc;
const toAnsiText = self => Doc.render(toAnsiDoc(self), {
  style: "pretty"
});
// =============================================================================
// Internals
// =============================================================================
exports.toAnsiText = toAnsiText;
const toAnsiDocInternal = self => {
  switch (self._tag) {
    case "Empty":
      {
        return Doc.empty;
      }
    case "Header":
      {
        return (0, _Function.pipe)(Doc.annotate(InternalSpan.toAnsiDoc(self.value), Ansi.bold), Doc.cat(Doc.hardLine));
      }
    case "Paragraph":
      {
        return (0, _Function.pipe)(InternalSpan.toAnsiDoc(self.value), Doc.cat(Doc.hardLine));
      }
    case "DescriptionList":
      {
        const definitions = self.definitions.map(([span, doc]) => Doc.cats([Doc.annotate(InternalSpan.toAnsiDoc(span), Ansi.bold), Doc.empty, Doc.indent(toAnsiDocInternal(doc), 2)]));
        return Doc.vsep(definitions);
      }
    case "Enumeration":
      {
        const elements = self.elements.map(doc => Doc.cat(Doc.text("- "), toAnsiDocInternal(doc)));
        return Doc.indent(Doc.vsep(elements), 2);
      }
    case "Sequence":
      {
        return Doc.vsep([toAnsiDocInternal(self.left), toAnsiDocInternal(self.right)]);
      }
  }
};
//# sourceMappingURL=helpDoc.js.map