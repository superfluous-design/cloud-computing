import * as Terminal from "@effect/platform/Terminal";
import * as Ansi from "@effect/printer-ansi/Ansi";
import * as Doc from "@effect/printer-ansi/AnsiDoc";
import * as Optimize from "@effect/printer/Optimize";
import * as Arr from "effect/Array";
import * as Effect from "effect/Effect";
import * as InternalPrompt from "../prompt.js";
import { Action } from "./action.js";
import * as InternalAnsiUtils from "./ansi-utils.js";
import { entriesToDisplay } from "./utils.js";
const renderBeep = /*#__PURE__*/Doc.render(Doc.beep, {
  style: "pretty"
});
const NEWLINE_REGEX = /\r?\n/;
function renderOutput(leadingSymbol, trailingSymbol, options) {
  const annotateLine = line => Doc.annotate(Doc.text(line), Ansi.bold);
  const prefix = Doc.cat(leadingSymbol, Doc.space);
  return Arr.match(options.message.split(NEWLINE_REGEX), {
    onEmpty: () => Doc.hsep([prefix, trailingSymbol]),
    onNonEmpty: promptLines => {
      const lines = Arr.map(promptLines, line => annotateLine(line));
      return prefix.pipe(Doc.cat(Doc.nest(Doc.vsep(lines), 2)), Doc.cat(Doc.space), Doc.cat(trailingSymbol), Doc.cat(Doc.space));
    }
  });
}
function renderChoicePrefix(state, choices, toDisplay, currentIndex, figures) {
  let prefix = Doc.space;
  if (currentIndex === toDisplay.startIndex && toDisplay.startIndex > 0) {
    prefix = figures.arrowUp;
  } else if (currentIndex === toDisplay.endIndex - 1 && toDisplay.endIndex < choices.length) {
    prefix = figures.arrowDown;
  }
  if (choices[currentIndex].disabled) {
    const annotation = Ansi.combine(Ansi.bold, Ansi.blackBright);
    return state === currentIndex ? figures.pointer.pipe(Doc.annotate(annotation), Doc.cat(prefix)) : prefix.pipe(Doc.cat(Doc.space));
  }
  return state === currentIndex ? figures.pointer.pipe(Doc.annotate(Ansi.cyanBright), Doc.cat(prefix)) : prefix.pipe(Doc.cat(Doc.space));
}
function renderChoiceTitle(choice, isSelected) {
  const title = Doc.text(choice.title);
  if (isSelected) {
    return choice.disabled ? Doc.annotate(title, Ansi.combine(Ansi.underlined, Ansi.blackBright)) : Doc.annotate(title, Ansi.combine(Ansi.underlined, Ansi.cyanBright));
  }
  return choice.disabled ? Doc.annotate(title, Ansi.combine(Ansi.strikethrough, Ansi.blackBright)) : title;
}
function renderChoiceDescription(choice, isSelected) {
  if (!choice.disabled && choice.description && isSelected) {
    return Doc.char("-").pipe(Doc.cat(Doc.space), Doc.cat(Doc.text(choice.description)), Doc.annotate(Ansi.blackBright));
  }
  return Doc.empty;
}
function renderChoices(state, options, figures) {
  const choices = options.choices;
  const toDisplay = entriesToDisplay(state, choices.length, options.maxPerPage);
  const documents = [];
  for (let index = toDisplay.startIndex; index < toDisplay.endIndex; index++) {
    const choice = choices[index];
    const isSelected = state === index;
    const prefix = renderChoicePrefix(state, choices, toDisplay, index, figures);
    const title = renderChoiceTitle(choice, isSelected);
    const description = renderChoiceDescription(choice, isSelected);
    documents.push(prefix.pipe(Doc.cat(title), Doc.cat(Doc.space), Doc.cat(description)));
  }
  return Doc.vsep(documents);
}
function renderNextFrame(state, options) {
  return Effect.gen(function* () {
    const terminal = yield* Terminal.Terminal;
    const columns = yield* terminal.columns;
    const figures = yield* InternalAnsiUtils.figures;
    const choices = renderChoices(state, options, figures);
    const leadingSymbol = Doc.annotate(Doc.text("?"), Ansi.cyanBright);
    const trailingSymbol = Doc.annotate(figures.pointerSmall, Ansi.blackBright);
    const promptMsg = renderOutput(leadingSymbol, trailingSymbol, options);
    return Doc.cursorHide.pipe(Doc.cat(promptMsg), Doc.cat(Doc.hardLine), Doc.cat(choices), Doc.render({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission(state, options) {
  return Effect.gen(function* () {
    const terminal = yield* Terminal.Terminal;
    const columns = yield* terminal.columns;
    const figures = yield* InternalAnsiUtils.figures;
    const selected = Doc.text(options.choices[state].title);
    const leadingSymbol = Doc.annotate(figures.tick, Ansi.green);
    const trailingSymbol = Doc.annotate(figures.ellipsis, Ansi.blackBright);
    const promptMsg = renderOutput(leadingSymbol, trailingSymbol, options);
    return promptMsg.pipe(Doc.cat(Doc.space), Doc.cat(Doc.annotate(selected, Ansi.white)), Doc.cat(Doc.hardLine), Doc.render({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processCursorUp(state, choices) {
  if (state === 0) {
    return Effect.succeed(Action.NextFrame({
      state: choices.length - 1
    }));
  }
  return Effect.succeed(Action.NextFrame({
    state: state - 1
  }));
}
function processCursorDown(state, choices) {
  if (state === choices.length - 1) {
    return Effect.succeed(Action.NextFrame({
      state: 0
    }));
  }
  return Effect.succeed(Action.NextFrame({
    state: state + 1
  }));
}
function processNext(state, choices) {
  return Effect.succeed(Action.NextFrame({
    state: (state + 1) % choices.length
  }));
}
function handleRender(options) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => Effect.succeed(renderBeep),
      NextFrame: ({
        state
      }) => renderNextFrame(state, options),
      Submit: () => renderSubmission(state, options)
    });
  };
}
export function handleClear(options) {
  return Effect.gen(function* () {
    const terminal = yield* Terminal.Terminal;
    const columns = yield* terminal.columns;
    const clearPrompt = Doc.cat(Doc.eraseLine, Doc.cursorLeft);
    const text = "\n".repeat(Math.min(options.choices.length, options.maxPerPage)) + options.message;
    const clearOutput = InternalAnsiUtils.eraseText(text, columns);
    return clearOutput.pipe(Doc.cat(clearPrompt), Optimize.optimize(Optimize.Deep), Doc.render({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function handleProcess(options) {
  return (input, state) => {
    switch (input.key.name) {
      case "k":
      case "up":
        {
          return processCursorUp(state, options.choices);
        }
      case "j":
      case "down":
        {
          return processCursorDown(state, options.choices);
        }
      case "tab":
        {
          return processNext(state, options.choices);
        }
      case "enter":
      case "return":
        {
          const selected = options.choices[state];
          if (selected.disabled) {
            return Effect.succeed(Action.Beep());
          }
          return Effect.succeed(Action.Submit({
            value: selected.value
          }));
        }
      default:
        {
          return Effect.succeed(Action.Beep());
        }
    }
  };
}
/** @internal */
export const select = options => {
  const opts = {
    maxPerPage: 10,
    ...options
  };
  return InternalPrompt.custom(0, {
    render: handleRender(opts),
    process: handleProcess(opts),
    clear: () => handleClear(opts)
  });
};
//# sourceMappingURL=select.js.map