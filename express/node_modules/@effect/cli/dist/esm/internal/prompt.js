import * as Terminal from "@effect/platform/Terminal";
import * as Doc from "@effect/printer-ansi/AnsiDoc";
import * as Effect from "effect/Effect";
import * as Effectable from "effect/Effectable";
import { dual } from "effect/Function";
import * as Pipeable from "effect/Pipeable";
import * as Ref from "effect/Ref";
import { Action } from "./prompt/action.js";
/** @internal */
const PromptSymbolKey = "@effect/cli/Prompt";
/** @internal */
export const PromptTypeId = /*#__PURE__*/Symbol.for(PromptSymbolKey);
/** @internal */
const proto = {
  ...Effectable.CommitPrototype,
  [PromptTypeId]: {
    _Output: _ => _
  },
  commit() {
    return run(this);
  },
  pipe() {
    return Pipeable.pipeArguments(this, arguments);
  }
};
/** @internal */
export const isPrompt = u => typeof u === "object" && u != null && PromptTypeId in u;
const allTupled = arg => {
  if (arg.length === 0) {
    return succeed([]);
  }
  if (arg.length === 1) {
    return map(arg[0], x => [x]);
  }
  let result = map(arg[0], x => [x]);
  for (let i = 1; i < arg.length; i++) {
    const curr = arg[i];
    result = flatMap(result, tuple => map(curr, a => [...tuple, a]));
  }
  return result;
};
/** @internal */
export const all = function () {
  if (arguments.length === 1) {
    if (isPrompt(arguments[0])) {
      return map(arguments[0], x => [x]);
    } else if (Array.isArray(arguments[0])) {
      return allTupled(arguments[0]);
    } else {
      const entries = Object.entries(arguments[0]);
      let result = map(entries[0][1], value => ({
        [entries[0][0]]: value
      }));
      if (entries.length === 1) {
        return result;
      }
      const rest = entries.slice(1);
      for (const [key, prompt] of rest) {
        result = result.pipe(flatMap(record => prompt.pipe(map(value => ({
          ...record,
          [key]: value
        })))));
      }
      return result;
    }
  }
  return allTupled(arguments[0]);
};
/** @internal */
export const custom = (initialState, handlers) => {
  const op = Object.create(proto);
  op._tag = "Loop";
  op.initialState = initialState;
  op.render = handlers.render;
  op.process = handlers.process;
  op.clear = handlers.clear;
  return op;
};
/** @internal */
export const map = /*#__PURE__*/dual(2, (self, f) => flatMap(self, a => succeed(f(a))));
/** @internal */
export const flatMap = /*#__PURE__*/dual(2, (self, f) => {
  const op = Object.create(proto);
  op._tag = "OnSuccess";
  op.prompt = self;
  op.onSuccess = f;
  return op;
});
/** @internal */
export const run = self => Effect.flatMap(Terminal.Terminal, terminal => {
  const op = self;
  switch (op._tag) {
    case "Loop":
      {
        const makeStateRef = Effect.isEffect(op.initialState) ? op.initialState.pipe(Effect.flatMap(Ref.make)) : Ref.make(op.initialState);
        return makeStateRef.pipe(Effect.flatMap(ref => {
          const loop = action => Ref.get(ref).pipe(Effect.flatMap(state => op.render(state, action).pipe(Effect.flatMap(msg => Effect.orDie(terminal.display(msg))), Effect.zipRight(terminal.readInput), Effect.flatMap(input => op.process(input, state)), Effect.flatMap(action => {
            switch (action._tag) {
              case "Beep":
                {
                  return loop(action);
                }
              case "NextFrame":
                {
                  return op.clear(state, action).pipe(Effect.flatMap(clear => Effect.orDie(terminal.display(clear))), Effect.zipRight(Ref.set(ref, action.state)), Effect.zipRight(loop(action)));
                }
              case "Submit":
                {
                  return op.clear(state, action).pipe(Effect.flatMap(clear => Effect.orDie(terminal.display(clear))), Effect.zipRight(op.render(state, action)), Effect.flatMap(msg => Effect.orDie(terminal.display(msg))), Effect.zipRight(Effect.succeed(action.value)));
                }
            }
          }))));
          return Ref.get(ref).pipe(Effect.flatMap(state => loop(Action.NextFrame({
            state
          }))));
        }),
        // Always make sure to restore the display of the cursor
        Effect.ensuring(Effect.orDie(terminal.display(Doc.render(Doc.cursorShow, {
          style: "pretty"
        })))));
      }
    case "OnSuccess":
      {
        return Effect.flatMap(run(op.prompt), a => run(op.onSuccess(a)));
      }
    case "Succeed":
      {
        return Effect.succeed(op.value);
      }
  }
});
/** @internal */
export const succeed = value => {
  const op = Object.create(proto);
  op._tag = "Succeed";
  op.value = value;
  return op;
};
//# sourceMappingURL=prompt.js.map