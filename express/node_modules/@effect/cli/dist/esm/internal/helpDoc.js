import * as Ansi from "@effect/printer-ansi/Ansi";
import * as Doc from "@effect/printer-ansi/AnsiDoc";
import * as Optimize from "@effect/printer/Optimize";
import * as Arr from "effect/Array";
import { dual, pipe } from "effect/Function";
import * as InternalSpan from "./helpDoc/span.js";
/** @internal */
export const isEmpty = helpDoc => helpDoc._tag === "Empty";
/** @internal */
export const isHeader = helpDoc => helpDoc._tag === "Header";
/** @internal */
export const isParagraph = helpDoc => helpDoc._tag === "Paragraph";
/** @internal */
export const isDescriptionList = helpDoc => helpDoc._tag === "DescriptionList";
/** @internal */
export const isEnumeration = helpDoc => helpDoc._tag === "Enumeration";
/** @internal */
export const isSequence = helpDoc => helpDoc._tag === "Sequence";
/** @internal */
export const empty = {
  _tag: "Empty"
};
/** @internal */
export const sequence = /*#__PURE__*/dual(2, (self, that) => {
  if (isEmpty(self)) {
    return that;
  }
  if (isEmpty(that)) {
    return self;
  }
  return {
    _tag: "Sequence",
    left: self,
    right: that
  };
});
/** @internal */
export const orElse = /*#__PURE__*/dual(2, (self, that) => isEmpty(self) ? that : self);
/** @internal */
export const blocks = helpDocs => {
  const elements = Arr.fromIterable(helpDocs);
  if (Arr.isNonEmptyReadonlyArray(elements)) {
    return elements.slice(1).reduce(sequence, elements[0]);
  }
  return empty;
};
/** @internal */
export const getSpan = self => isHeader(self) || isParagraph(self) ? self.value : InternalSpan.empty;
/** @internal */
export const descriptionList = definitions => ({
  _tag: "DescriptionList",
  definitions
});
/** @internal */
export const enumeration = elements => ({
  _tag: "Enumeration",
  elements
});
/** @internal */
export const h1 = value => ({
  _tag: "Header",
  value: typeof value === "string" ? InternalSpan.text(value) : value,
  level: 1
});
/** @internal */
export const h2 = value => ({
  _tag: "Header",
  value: typeof value === "string" ? InternalSpan.text(value) : value,
  level: 2
});
/** @internal */
export const h3 = value => ({
  _tag: "Header",
  value: typeof value === "string" ? InternalSpan.text(value) : value,
  level: 3
});
/** @internal */
export const p = value => ({
  _tag: "Paragraph",
  value: typeof value === "string" ? InternalSpan.text(value) : value
});
/** @internal */
export const mapDescriptionList = /*#__PURE__*/dual(2, (self, f) => isDescriptionList(self) ? descriptionList(Arr.map(self.definitions, ([span, helpDoc]) => f(span, helpDoc))) : self);
/** @internal */
export const toAnsiDoc = self => Optimize.optimize(toAnsiDocInternal(self), Optimize.Deep);
/** @internal */
export const toAnsiText = self => Doc.render(toAnsiDoc(self), {
  style: "pretty"
});
// =============================================================================
// Internals
// =============================================================================
const toAnsiDocInternal = self => {
  switch (self._tag) {
    case "Empty":
      {
        return Doc.empty;
      }
    case "Header":
      {
        return pipe(Doc.annotate(InternalSpan.toAnsiDoc(self.value), Ansi.bold), Doc.cat(Doc.hardLine));
      }
    case "Paragraph":
      {
        return pipe(InternalSpan.toAnsiDoc(self.value), Doc.cat(Doc.hardLine));
      }
    case "DescriptionList":
      {
        const definitions = self.definitions.map(([span, doc]) => Doc.cats([Doc.annotate(InternalSpan.toAnsiDoc(span), Ansi.bold), Doc.empty, Doc.indent(toAnsiDocInternal(doc), 2)]));
        return Doc.vsep(definitions);
      }
    case "Enumeration":
      {
        const elements = self.elements.map(doc => Doc.cat(Doc.text("- "), toAnsiDocInternal(doc)));
        return Doc.indent(Doc.vsep(elements), 2);
      }
    case "Sequence":
      {
        return Doc.vsep([toAnsiDocInternal(self.left), toAnsiDocInternal(self.right)]);
      }
  }
};
//# sourceMappingURL=helpDoc.js.map