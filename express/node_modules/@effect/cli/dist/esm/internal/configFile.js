import * as FileSystem from "@effect/platform/FileSystem";
import * as Path from "@effect/platform/Path";
import * as Cause from "effect/Cause";
import * as ConfigProvider from "effect/ConfigProvider";
import * as Context from "effect/Context";
import * as DefaultServices from "effect/DefaultServices";
import * as Effect from "effect/Effect";
import { pipe } from "effect/Function";
import * as Layer from "effect/Layer";
import * as InternalFiles from "./files.js";
const fileExtensions = {
  json: ["json"],
  yaml: ["yaml", "yml"],
  ini: ["ini"],
  toml: ["toml", "tml"]
};
const allFileExtensions = /*#__PURE__*/Object.values(fileExtensions).flat();
/** @internal */
export const makeProvider = (fileName, options) => Effect.gen(function* () {
  const path = yield* Path.Path;
  const fs = yield* FileSystem.FileSystem;
  const searchPaths = options?.searchPaths && options.searchPaths.length ? options.searchPaths : ["."];
  const extensions = options?.formats && options.formats.length ? options.formats.flatMap(_ => fileExtensions[_]) : allFileExtensions;
  const filePaths = yield* Effect.filter(searchPaths.flatMap(searchPath => extensions.map(ext => path.join(searchPath, `${fileName}.${ext}`))), path => Effect.orElseSucceed(fs.exists(path), () => false));
  const providers = yield* Effect.forEach(filePaths, path => pipe(fs.readFileString(path), Effect.mapError(_ => ConfigFileError(`Could not read file (${path})`)), Effect.flatMap(content => Effect.mapError(InternalFiles.parse(path, content), message => ConfigFileError(message))), Effect.map(data => ConfigProvider.fromJson(data))));
  if (providers.length === 0) {
    return ConfigProvider.fromMap(new Map());
  }
  return providers.reduce((acc, provider) => ConfigProvider.orElse(acc, () => provider));
});
/** @internal */
export const layer = (fileName, options) => pipe(makeProvider(fileName, options), Effect.map(provider => Layer.fiberRefLocallyScopedWith(DefaultServices.currentServices, services => {
  const current = Context.get(services, ConfigProvider.ConfigProvider);
  return Context.add(services, ConfigProvider.ConfigProvider, ConfigProvider.orElse(current, () => provider));
})), Layer.unwrapEffect);
/** @internal */
export const ConfigErrorTypeId = /*#__PURE__*/Symbol.for("@effect/cli/ConfigFile/ConfigFileError");
const ConfigFileErrorProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(Cause.YieldableError.prototype), {
  [ConfigErrorTypeId]: ConfigErrorTypeId
});
/** @internal */
export const ConfigFileError = message => {
  const self = Object.create(ConfigFileErrorProto);
  self._tag = "ConfigFileError";
  self.message = message;
  return self;
};
//# sourceMappingURL=configFile.js.map