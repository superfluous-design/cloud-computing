import * as Arr from "effect/Array";
import * as Config from "effect/Config";
import * as ConfigError from "effect/ConfigError";
import * as Console from "effect/Console";
import * as Effect from "effect/Effect";
import * as Either from "effect/Either";
import { dual, pipe } from "effect/Function";
import * as HashMap from "effect/HashMap";
import * as Inspectable from "effect/Inspectable";
import * as Option from "effect/Option";
import * as Order from "effect/Order";
import * as ParseResult from "effect/ParseResult";
import { pipeArguments } from "effect/Pipeable";
import * as Predicate from "effect/Predicate";
import * as Ref from "effect/Ref";
import * as InternalAutoCorrect from "./autoCorrect.js";
import * as InternalCliConfig from "./cliConfig.js";
import * as InternalFiles from "./files.js";
import * as InternalHelpDoc from "./helpDoc.js";
import * as InternalSpan from "./helpDoc/span.js";
import * as InternalPrimitive from "./primitive.js";
import * as InternalPrompt from "./prompt.js";
import * as InternalListPrompt from "./prompt/list.js";
import * as InternalNumberPrompt from "./prompt/number.js";
import * as InternalSelectPrompt from "./prompt/select.js";
import * as InternalUsage from "./usage.js";
import * as InternalValidationError from "./validationError.js";
const OptionsSymbolKey = "@effect/cli/Options";
/** @internal */
export const OptionsTypeId = /*#__PURE__*/Symbol.for(OptionsSymbolKey);
const proto = {
  [OptionsTypeId]: {
    _A: _ => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// =============================================================================
// Refinements
// =============================================================================
/** @internal */
export const isOptions = u => typeof u === "object" && u != null && OptionsTypeId in u;
/** @internal */
export const isInstruction = self => self;
/** @internal */
export const isEmpty = self => self._tag === "Empty";
/** @internal */
export const isSingle = self => self._tag === "Single";
/** @internal */
export const isKeyValueMap = self => self._tag === "KeyValueMap";
/** @internal */
export const isMap = self => self._tag === "Map";
/** @internal */
export const isBoth = self => self._tag === "Both";
/** @internal */
export const isOrElse = self => self._tag === "OrElse";
/** @internal */
export const isWithDefault = self => self._tag === "WithDefault";
/** @internal */
export const isWithFallback = self => self._tag === "WithFallback";
// =============================================================================
// Constructors
// =============================================================================
/** @internal */
export const all = function () {
  if (arguments.length === 1) {
    if (isOptions(arguments[0])) {
      return map(arguments[0], x => [x]);
    } else if (Arr.isArray(arguments[0])) {
      return allTupled(arguments[0]);
    } else {
      const entries = Object.entries(arguments[0]);
      let result = map(entries[0][1], value => ({
        [entries[0][0]]: value
      }));
      if (entries.length === 1) {
        return result;
      }
      const rest = entries.slice(1);
      for (const [key, options] of rest) {
        result = map(makeBoth(result, options), ([record, value]) => ({
          ...record,
          [key]: value
        }));
      }
      return result;
    }
  }
  return allTupled(arguments[0]);
};
const defaultBooleanOptions = {
  ifPresent: true,
  negationNames: [],
  aliases: []
};
/** @internal */
export const boolean = (name, options) => {
  const {
    aliases,
    ifPresent,
    negationNames
  } = {
    ...defaultBooleanOptions,
    ...options
  };
  const option = makeSingle(name, aliases, InternalPrimitive.boolean(Option.some(ifPresent)));
  if (Arr.isNonEmptyReadonlyArray(negationNames)) {
    const head = Arr.headNonEmpty(negationNames);
    const tail = Arr.tailNonEmpty(negationNames);
    const negationOption = makeSingle(head, tail, InternalPrimitive.boolean(Option.some(!ifPresent)));
    return withDefault(orElse(option, negationOption), !ifPresent);
  }
  return withDefault(option, !ifPresent);
};
/** @internal */
export const choice = (name, choices) => {
  const primitive = InternalPrimitive.choice(Arr.map(choices, choice => [choice, choice]));
  return makeSingle(name, Arr.empty(), primitive);
};
/** @internal */
export const choiceWithValue = (name, choices) => makeSingle(name, Arr.empty(), InternalPrimitive.choice(choices));
/** @internal */
export const date = name => makeSingle(name, Arr.empty(), InternalPrimitive.date);
/** @internal */
export const directory = (name, config) => makeSingle(name, Arr.empty(), InternalPrimitive.path("directory", config?.exists ?? "either"));
/** @internal */
export const file = (name, config) => makeSingle(name, Arr.empty(), InternalPrimitive.path("file", config?.exists ?? "either"));
/** @internal */
export const fileContent = name => mapEffect(file(name, {
  exists: "yes"
}), path => Effect.mapError(InternalFiles.read(path), msg => InternalValidationError.invalidValue(InternalHelpDoc.p(msg))));
/** @internal */
export const fileParse = (name, format) => mapEffect(fileText(name), ([path, content]) => Effect.mapError(InternalFiles.parse(path, content, format), error => InternalValidationError.invalidValue(InternalHelpDoc.p(error))));
/** @internal */
export const fileSchema = (name, schema, format) => withSchema(fileParse(name, format), schema);
/** @internal */
export const fileText = name => mapEffect(file(name, {
  exists: "yes"
}), path => Effect.mapError(InternalFiles.readString(path), error => InternalValidationError.invalidValue(InternalHelpDoc.p(error))));
/** @internal */
export const filterMap = /*#__PURE__*/dual(3, (self, f, message) => mapEffect(self, a => Option.match(f(a), {
  onNone: () => Either.left(InternalValidationError.invalidValue(InternalHelpDoc.p(message))),
  onSome: Either.right
})));
/** @internal */
export const float = name => makeSingle(name, Arr.empty(), InternalPrimitive.float);
/** @internal */
export const integer = name => makeSingle(name, Arr.empty(), InternalPrimitive.integer);
/** @internal */
export const keyValueMap = option => {
  if (typeof option === "string") {
    const single = makeSingle(option, Arr.empty(), InternalPrimitive.text);
    return makeKeyValueMap(single);
  }
  if (!isSingle(option)) {
    throw new Error("InvalidArgumentException: only single options can be key/value maps");
  } else {
    return makeKeyValueMap(option);
  }
};
/** @internal */
export const none = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "Empty";
  return op;
})();
/** @internal */
export const redacted = name => makeSingle(name, Arr.empty(), InternalPrimitive.redacted);
/** @internal */
export const secret = name => makeSingle(name, Arr.empty(), InternalPrimitive.secret);
/** @internal */
export const text = name => makeSingle(name, Arr.empty(), InternalPrimitive.text);
// =============================================================================
// Combinators
// =============================================================================
/** @internal */
export const atLeast = /*#__PURE__*/dual(2, (self, times) => makeVariadic(self, Option.some(times), Option.none()));
/** @internal */
export const atMost = /*#__PURE__*/dual(2, (self, times) => makeVariadic(self, Option.none(), Option.some(times)));
/** @internal */
export const between = /*#__PURE__*/dual(3, (self, min, max) => makeVariadic(self, Option.some(min), Option.some(max)));
/** @internal */
export const isBool = self => isBoolInternal(self);
/** @internal */
export const getHelp = self => getHelpInternal(self);
/** @internal */
export const getIdentifier = self => getIdentifierInternal(self);
/** @internal */
export const getMinSize = self => getMinSizeInternal(self);
/** @internal */
export const getMaxSize = self => getMaxSizeInternal(self);
/** @internal */
export const getUsage = self => getUsageInternal(self);
/** @internal */
export const map = /*#__PURE__*/dual(2, (self, f) => makeMap(self, a => Either.right(f(a))));
/** @internal */
export const mapEffect = /*#__PURE__*/dual(2, (self, f) => makeMap(self, f));
/** @internal */
export const mapTryCatch = /*#__PURE__*/dual(3, (self, f, onError) => mapEffect(self, a => {
  try {
    return Either.right(f(a));
  } catch (e) {
    return Either.left(InternalValidationError.invalidValue(onError(e)));
  }
}));
/** @internal */
export const optional = self => withDefault(map(self, Option.some), Option.none());
/** @internal */
export const orElse = /*#__PURE__*/dual(2, (self, that) => orElseEither(self, that).pipe(map(Either.merge)));
/** @internal */
export const orElseEither = /*#__PURE__*/dual(2, (self, that) => makeOrElse(self, that));
/** @internal */
export const parse = /*#__PURE__*/dual(3, (self, args, config) => parseInternal(self, args, config));
/** @internal */
export const processCommandLine = /*#__PURE__*/dual(3, (self, args, config) => matchOptions(args, toParseableInstruction(self), config).pipe(Effect.flatMap(([error, commandArgs, matchedOptions]) => parseInternal(self, matchedOptions, config).pipe(Effect.catchAll(e => Option.match(error, {
  onNone: () => Effect.fail(e),
  onSome: err => Effect.fail(err)
})), Effect.map(a => [error, commandArgs, a])))));
/** @internal */
export const repeated = self => makeVariadic(self, Option.none(), Option.none());
/** @internal */
export const withAlias = /*#__PURE__*/dual(2, (self, alias) => modifySingle(self, single => {
  const aliases = Arr.append(single.aliases, alias);
  return makeSingle(single.name, aliases, single.primitiveType, single.description, single.pseudoName);
}));
/** @internal */
export const withDefault = /*#__PURE__*/dual(2, (self, fallback) => makeWithDefault(self, fallback));
/** @internal */
export const withFallbackConfig = /*#__PURE__*/dual(2, (self, config) => {
  if (isInstruction(self) && isWithDefault(self)) {
    return makeWithDefault(withFallbackConfig(self.options, config), self.fallback);
  }
  return makeWithFallback(self, config);
});
/** @internal */
export const withFallbackPrompt = /*#__PURE__*/dual(2, (self, prompt) => {
  if (isInstruction(self) && isWithDefault(self)) {
    return makeWithDefault(withFallbackPrompt(self.options, prompt), self.fallback);
  }
  return makeWithFallback(self, prompt);
});
/** @internal */
export const withDescription = /*#__PURE__*/dual(2, (self, desc) => modifySingle(self, single => {
  const description = InternalHelpDoc.sequence(single.description, InternalHelpDoc.p(desc));
  return makeSingle(single.name, single.aliases, single.primitiveType, description, single.pseudoName);
}));
/** @internal */
export const withPseudoName = /*#__PURE__*/dual(2, (self, pseudoName) => modifySingle(self, single => makeSingle(single.name, single.aliases, single.primitiveType, single.description, Option.some(pseudoName))));
/** @internal */
export const withSchema = /*#__PURE__*/dual(2, (self, schema) => {
  const decode = ParseResult.decode(schema);
  return mapEffect(self, _ => Effect.mapError(decode(_), issue => InternalValidationError.invalidValue(InternalHelpDoc.p(ParseResult.TreeFormatter.formatIssueSync(issue)))));
});
/** @internal */
export const wizard = /*#__PURE__*/dual(2, (self, config) => wizardInternal(self, config));
// =============================================================================
// Internals
// =============================================================================
const allTupled = arg => {
  if (arg.length === 0) {
    return none;
  }
  if (arg.length === 1) {
    return map(arg[0], x => [x]);
  }
  let result = map(arg[0], x => [x]);
  for (let i = 1; i < arg.length; i++) {
    const curr = arg[i];
    result = map(makeBoth(result, curr), ([a, b]) => [...a, b]);
  }
  return result;
};
const getHelpInternal = self => {
  switch (self._tag) {
    case "Empty":
      {
        return InternalHelpDoc.empty;
      }
    case "Single":
      {
        return InternalHelpDoc.descriptionList(Arr.of([InternalHelpDoc.getSpan(InternalUsage.getHelp(getUsageInternal(self))), InternalHelpDoc.sequence(InternalHelpDoc.p(InternalPrimitive.getHelp(self.primitiveType)), self.description)]));
      }
    case "KeyValueMap":
      {
        // Single options always have an identifier, so we can safely `getOrThrow`
        const identifier = Option.getOrThrow(getIdentifierInternal(self.argumentOption));
        return InternalHelpDoc.mapDescriptionList(getHelpInternal(self.argumentOption), (span, oldBlock) => {
          const header = InternalHelpDoc.p("This setting is a property argument which:");
          const single = `${identifier} key1=value key2=value2`;
          const multiple = `${identifier} key1=value ${identifier} key2=value2`;
          const description = InternalHelpDoc.enumeration([InternalHelpDoc.p(`May be specified a single time:  '${single}'`), InternalHelpDoc.p(`May be specified multiple times: '${multiple}'`)]);
          const newBlock = pipe(oldBlock, InternalHelpDoc.sequence(header), InternalHelpDoc.sequence(description));
          return [span, newBlock];
        });
      }
    case "Map":
      {
        return getHelpInternal(self.options);
      }
    case "Both":
    case "OrElse":
      {
        return InternalHelpDoc.sequence(getHelpInternal(self.left), getHelpInternal(self.right));
      }
    case "Variadic":
      {
        const help = getHelpInternal(self.argumentOption);
        return InternalHelpDoc.mapDescriptionList(help, (oldSpan, oldBlock) => {
          const min = getMinSizeInternal(self);
          const max = getMaxSizeInternal(self);
          const newSpan = InternalSpan.text(Option.isSome(self.max) ? ` ${min} - ${max}` : min === 0 ? "..." : ` ${min}+`);
          const newBlock = InternalHelpDoc.p(Option.isSome(self.max) ? `This option must be repeated at least ${min} times and may be repeated up to ${max} times.` : min === 0 ? "This option may be repeated zero or more times." : `This option must be repeated at least ${min} times.`);
          return [InternalSpan.concat(oldSpan, newSpan), InternalHelpDoc.sequence(oldBlock, newBlock)];
        });
      }
    case "WithDefault":
      {
        return InternalHelpDoc.mapDescriptionList(getHelpInternal(self.options), (span, block) => {
          const optionalDescription = Option.isOption(self.fallback) ? Option.match(self.fallback, {
            onNone: () => InternalHelpDoc.p("This setting is optional."),
            onSome: fallbackValue => {
              const inspectableValue = Predicate.isObject(fallbackValue) ? fallbackValue : String(fallbackValue);
              const displayValue = Inspectable.toStringUnknown(inspectableValue, 0);
              return InternalHelpDoc.p(`This setting is optional. Defaults to: ${displayValue}`);
            }
          }) : InternalHelpDoc.p("This setting is optional.");
          return [span, InternalHelpDoc.sequence(block, optionalDescription)];
        });
      }
    case "WithFallback":
      {
        const helpDoc = Config.isConfig(self.effect) ? InternalHelpDoc.p("This option can be set from environment variables.") : InternalPrompt.isPrompt(self.effect) ? InternalHelpDoc.p("Will prompt the user for input if this option is not provided.") : InternalHelpDoc.empty;
        return InternalHelpDoc.mapDescriptionList(getHelpInternal(self.options), (span, block) => [span, InternalHelpDoc.sequence(block, helpDoc)]);
      }
  }
};
const getIdentifierInternal = self => {
  switch (self._tag) {
    case "Empty":
      {
        return Option.none();
      }
    case "Single":
      {
        return Option.some(self.fullName);
      }
    case "Both":
    case "OrElse":
      {
        const ids = Arr.getSomes([getIdentifierInternal(self.left), getIdentifierInternal(self.right)]);
        return Arr.match(ids, {
          onEmpty: () => Option.none(),
          onNonEmpty: ids => Option.some(Arr.join(ids, ", "))
        });
      }
    case "KeyValueMap":
    case "Variadic":
      {
        return getIdentifierInternal(self.argumentOption);
      }
    case "Map":
    case "WithFallback":
    case "WithDefault":
      {
        return getIdentifierInternal(self.options);
      }
  }
};
const getMinSizeInternal = self => {
  switch (self._tag) {
    case "Empty":
    case "WithDefault":
    case "WithFallback":
      {
        return 0;
      }
    case "Single":
    case "KeyValueMap":
      {
        return 1;
      }
    case "Map":
      {
        return getMinSizeInternal(self.options);
      }
    case "Both":
      {
        const leftMinSize = getMinSizeInternal(self.left);
        const rightMinSize = getMinSizeInternal(self.right);
        return leftMinSize + rightMinSize;
      }
    case "OrElse":
      {
        const leftMinSize = getMinSizeInternal(self.left);
        const rightMinSize = getMinSizeInternal(self.right);
        return Math.min(leftMinSize, rightMinSize);
      }
    case "Variadic":
      {
        const selfMinSize = Option.getOrElse(self.min, () => 0);
        const argumentOptionMinSize = getMinSizeInternal(self.argumentOption);
        return selfMinSize * argumentOptionMinSize;
      }
  }
};
const getMaxSizeInternal = self => {
  switch (self._tag) {
    case "Empty":
      {
        return 0;
      }
    case "Single":
      {
        return 1;
      }
    case "KeyValueMap":
      {
        return Number.MAX_SAFE_INTEGER;
      }
    case "Map":
    case "WithDefault":
    case "WithFallback":
      {
        return getMaxSizeInternal(self.options);
      }
    case "Both":
      {
        const leftMaxSize = getMaxSizeInternal(self.left);
        const rightMaxSize = getMaxSizeInternal(self.right);
        return leftMaxSize + rightMaxSize;
      }
    case "OrElse":
      {
        const leftMin = getMaxSizeInternal(self.left);
        const rightMin = getMaxSizeInternal(self.right);
        return Math.min(leftMin, rightMin);
      }
    case "Variadic":
      {
        const selfMaxSize = Option.getOrElse(self.max, () => Number.MAX_SAFE_INTEGER / 2);
        const optionsMaxSize = getMaxSizeInternal(self.argumentOption);
        return Math.floor(selfMaxSize * optionsMaxSize);
      }
  }
};
const getUsageInternal = self => {
  switch (self._tag) {
    case "Empty":
      {
        return InternalUsage.empty;
      }
    case "Single":
      {
        const acceptedValues = InternalPrimitive.isBool(self.primitiveType) ? Option.none() : Option.orElse(InternalPrimitive.getChoices(self.primitiveType), () => Option.some(self.placeholder));
        return InternalUsage.named(getNames(self), acceptedValues);
      }
    case "KeyValueMap":
      {
        return getUsageInternal(self.argumentOption);
      }
    case "Map":
      {
        return getUsageInternal(self.options);
      }
    case "Both":
      {
        return InternalUsage.concat(getUsageInternal(self.left), getUsageInternal(self.right));
      }
    case "OrElse":
      {
        return InternalUsage.alternation(getUsageInternal(self.left), getUsageInternal(self.right));
      }
    case "Variadic":
      {
        return InternalUsage.repeated(getUsageInternal(self.argumentOption));
      }
    case "WithDefault":
    case "WithFallback":
      {
        return InternalUsage.optional(getUsageInternal(self.options));
      }
  }
};
const isBoolInternal = self => {
  switch (self._tag) {
    case "Single":
      {
        return InternalPrimitive.isBool(self.primitiveType);
      }
    case "Map":
      {
        return isBoolInternal(self.options);
      }
    case "WithDefault":
      {
        return isBoolInternal(self.options);
      }
    default:
      {
        return false;
      }
  }
};
const makeBoth = (left, right) => {
  const op = Object.create(proto);
  op._tag = "Both";
  op.left = left;
  op.right = right;
  return op;
};
const makeFullName = str => str.length === 1 ? [true, `-${str}`] : [false, `--${str}`];
const makeKeyValueMap = argumentOption => {
  const op = Object.create(proto);
  op._tag = "KeyValueMap";
  op.argumentOption = argumentOption;
  return op;
};
const makeMap = (options, f) => {
  const op = Object.create(proto);
  op._tag = "Map";
  op.options = options;
  op.f = f;
  return op;
};
const makeOrElse = (left, right) => {
  const op = Object.create(proto);
  op._tag = "OrElse";
  op.left = left;
  op.right = right;
  return op;
};
const makeSingle = (name, aliases, primitiveType, description = InternalHelpDoc.empty, pseudoName = Option.none()) => {
  const op = Object.create(proto);
  op._tag = "Single";
  op.name = name;
  op.fullName = makeFullName(name)[1];
  op.placeholder = `${Option.getOrElse(pseudoName, () => InternalPrimitive.getTypeName(primitiveType))}`;
  op.aliases = aliases;
  op.primitiveType = primitiveType;
  op.description = description;
  op.pseudoName = pseudoName;
  return op;
};
const makeVariadic = (argumentOption, min, max) => {
  if (!isSingle(argumentOption)) {
    throw new Error("InvalidArgumentException: only single options can be variadic");
  }
  const op = Object.create(proto);
  op._tag = "Variadic";
  op.argumentOption = argumentOption;
  op.min = min;
  op.max = max;
  return op;
};
const makeWithDefault = (options, fallback) => {
  const op = Object.create(proto);
  op._tag = "WithDefault";
  op.options = options;
  op.fallback = fallback;
  return op;
};
const makeWithFallback = (options, effect) => {
  const op = Object.create(proto);
  op._tag = "WithFallback";
  op.options = options;
  op.effect = effect;
  return op;
};
const modifySingle = (self, f) => {
  switch (self._tag) {
    case "Empty":
      {
        return none;
      }
    case "Single":
      {
        return f(self);
      }
    case "KeyValueMap":
      {
        return makeKeyValueMap(f(self.argumentOption));
      }
    case "Map":
      {
        return makeMap(modifySingle(self.options, f), self.f);
      }
    case "Both":
      {
        return makeBoth(modifySingle(self.left, f), modifySingle(self.right, f));
      }
    case "OrElse":
      {
        return makeOrElse(modifySingle(self.left, f), modifySingle(self.right, f));
      }
    case "Variadic":
      {
        return makeVariadic(f(self.argumentOption), self.min, self.max);
      }
    case "WithDefault":
      {
        return makeWithDefault(modifySingle(self.options, f), self.fallback);
      }
    case "WithFallback":
      {
        return makeWithFallback(modifySingle(self.options, f), self.effect);
      }
  }
};
/** @internal */
export const getNames = self => {
  const loop = self => {
    switch (self._tag) {
      case "Empty":
        {
          return Arr.empty();
        }
      case "Single":
        {
          return Arr.prepend(self.aliases, self.name);
        }
      case "KeyValueMap":
      case "Variadic":
        {
          return loop(self.argumentOption);
        }
      case "Map":
      case "WithDefault":
      case "WithFallback":
        {
          return loop(self.options);
        }
      case "Both":
      case "OrElse":
        {
          const left = loop(self.left);
          const right = loop(self.right);
          return Arr.appendAll(left, right);
        }
    }
  };
  const order = Order.mapInput(Order.boolean, tuple => !tuple[0]);
  return pipe(loop(self), Arr.map(str => makeFullName(str)), Arr.sort(order), Arr.map(tuple => tuple[1]));
};
const toParseableInstruction = self => {
  switch (self._tag) {
    case "Empty":
      {
        return Arr.empty();
      }
    case "Single":
    case "KeyValueMap":
    case "Variadic":
      {
        return Arr.of(self);
      }
    case "Map":
    case "WithDefault":
    case "WithFallback":
      {
        return toParseableInstruction(self.options);
      }
    case "Both":
    case "OrElse":
      {
        return Arr.appendAll(toParseableInstruction(self.left), toParseableInstruction(self.right));
      }
  }
};
/** @internal */
const keyValueSplitter = /=(.*)/;
const parseInternal = (self, args, config) => {
  switch (self._tag) {
    case "Empty":
      {
        return Effect.void;
      }
    case "Single":
      {
        const singleNames = Arr.filterMap(getNames(self), name => HashMap.get(args, name));
        if (Arr.isNonEmptyReadonlyArray(singleNames)) {
          const head = Arr.headNonEmpty(singleNames);
          const tail = Arr.tailNonEmpty(singleNames);
          if (Arr.isEmptyReadonlyArray(tail)) {
            if (Arr.isEmptyReadonlyArray(head)) {
              return InternalPrimitive.validate(self.primitiveType, Option.none(), config).pipe(Effect.mapError(e => InternalValidationError.invalidValue(InternalHelpDoc.p(e))));
            }
            if (Arr.isNonEmptyReadonlyArray(head) && Arr.isEmptyReadonlyArray(Arr.tailNonEmpty(head))) {
              const value = Arr.headNonEmpty(head);
              return InternalPrimitive.validate(self.primitiveType, Option.some(value), config).pipe(Effect.mapError(e => InternalValidationError.invalidValue(InternalHelpDoc.p(e))));
            }
            return Effect.fail(InternalValidationError.multipleValuesDetected(InternalHelpDoc.empty, head));
          }
          const error = InternalHelpDoc.p(`More than one reference to option '${self.fullName}' detected`);
          return Effect.fail(InternalValidationError.invalidValue(error));
        }
        const error = InternalHelpDoc.p(`Expected to find option: '${self.fullName}'`);
        return Effect.fail(InternalValidationError.missingValue(error));
      }
    case "KeyValueMap":
      {
        const extractKeyValue = value => {
          const split = value.trim().split(keyValueSplitter, 2);
          if (Arr.isNonEmptyReadonlyArray(split) && split.length === 2 && split[1] !== "") {
            return Effect.succeed(split);
          }
          const error = InternalHelpDoc.p(`Expected a key/value pair but received '${value}'`);
          return Effect.fail(InternalValidationError.invalidArgument(error));
        };
        return parseInternal(self.argumentOption, args, config).pipe(Effect.matchEffect({
          onFailure: e => InternalValidationError.isMultipleValuesDetected(e) ? Effect.forEach(e.values, kv => extractKeyValue(kv)).pipe(Effect.map(HashMap.fromIterable)) : Effect.fail(e),
          onSuccess: kv => extractKeyValue(kv).pipe(Effect.map(HashMap.make))
        }));
      }
    case "Map":
      {
        return parseInternal(self.options, args, config).pipe(Effect.flatMap(a => self.f(a)));
      }
    case "Both":
      {
        return parseInternal(self.left, args, config).pipe(Effect.catchAll(err1 => parseInternal(self.right, args, config).pipe(Effect.matchEffect({
          onFailure: err2 => {
            const error = InternalHelpDoc.sequence(err1.error, err2.error);
            return Effect.fail(InternalValidationError.missingValue(error));
          },
          onSuccess: () => Effect.fail(err1)
        }))), Effect.zip(parseInternal(self.right, args, config)));
      }
    case "OrElse":
      {
        return parseInternal(self.left, args, config).pipe(Effect.matchEffect({
          onFailure: err1 => parseInternal(self.right, args, config).pipe(Effect.mapBoth({
            onFailure: err2 =>
            // orElse option is only missing in case neither option was given
            InternalValidationError.isMissingValue(err1) && InternalValidationError.isMissingValue(err2) ? InternalValidationError.missingValue(InternalHelpDoc.sequence(err1.error, err2.error)) : InternalValidationError.invalidValue(InternalHelpDoc.sequence(err1.error, err2.error)),
            onSuccess: b => Either.right(b)
          })),
          onSuccess: a => parseInternal(self.right, args, config).pipe(Effect.matchEffect({
            onFailure: () => Effect.succeed(Either.left(a)),
            onSuccess: () => {
              // The `identifier` will only be `None` for `Options.Empty`, which
              // means the user would have had to purposefully compose
              // `Options.Empty | otherArgument`
              const leftUid = Option.getOrElse(getIdentifierInternal(self.left), () => "???");
              const rightUid = Option.getOrElse(getIdentifierInternal(self.right), () => "???");
              const error = InternalHelpDoc.p("Collision between two options detected - you can only specify " + `one of either: ['${leftUid}', '${rightUid}']`);
              return Effect.fail(InternalValidationError.invalidValue(error));
            }
          }))
        }));
      }
    case "Variadic":
      {
        const min = Option.getOrElse(self.min, () => 0);
        const max = Option.getOrElse(self.max, () => Number.MAX_SAFE_INTEGER);
        const matchedArgument = Arr.filterMap(getNames(self), name => HashMap.get(args, name));
        const validateMinMax = values => {
          if (values.length < min) {
            const name = self.argumentOption.fullName;
            const error = `Expected at least ${min} value(s) for option: '${name}'`;
            return Effect.fail(InternalValidationError.invalidValue(InternalHelpDoc.p(error)));
          }
          if (values.length > max) {
            const name = self.argumentOption.fullName;
            const error = `Expected at most ${max} value(s) for option: '${name}'`;
            return Effect.fail(InternalValidationError.invalidValue(InternalHelpDoc.p(error)));
          }
          const primitive = self.argumentOption.primitiveType;
          const validatePrimitive = value => InternalPrimitive.validate(primitive, Option.some(value), config).pipe(Effect.mapError(e => InternalValidationError.invalidValue(InternalHelpDoc.p(e))));
          return Effect.forEach(values, value => validatePrimitive(value));
        };
        // If we did not receive any variadic arguments then perform the bounds
        // checks with an empty array
        if (Arr.every(matchedArgument, Arr.isEmptyReadonlyArray)) {
          return validateMinMax(Arr.empty());
        }
        return parseInternal(self.argumentOption, args, config).pipe(Effect.matchEffect({
          onFailure: error => InternalValidationError.isMultipleValuesDetected(error) ? validateMinMax(error.values) : Effect.fail(error),
          onSuccess: value => validateMinMax(Arr.of(value))
        }));
      }
    case "WithDefault":
      {
        return parseInternal(self.options, args, config).pipe(Effect.catchTag("MissingValue", () => Effect.succeed(self.fallback)));
      }
    case "WithFallback":
      {
        return parseInternal(self.options, args, config).pipe(Effect.catchTag("MissingValue", e => self.effect.pipe(Effect.catchAll(e2 => {
          if (Predicate.isTagged(e2, "QuitException")) {
            return Effect.die(e2);
          }
          if (ConfigError.isConfigError(e2) && !ConfigError.isMissingDataOnly(e2)) {
            const help = InternalHelpDoc.p(String(e2));
            const error = InternalValidationError.invalidValue(help);
            return Effect.fail(error);
          }
          return Effect.fail(e);
        }))));
      }
  }
};
const wizardInternal = (self, config) => {
  switch (self._tag) {
    case "Empty":
      {
        return Effect.succeed(Arr.empty());
      }
    case "Single":
      {
        const help = getHelpInternal(self);
        return InternalPrimitive.wizard(self.primitiveType, help).pipe(Effect.flatMap(input => {
          // There will always be at least one name in names
          const args = Arr.make(getNames(self)[0], input);
          return parseCommandLine(self, args, config).pipe(Effect.as(args));
        }), Effect.zipLeft(Console.log()));
      }
    case "KeyValueMap":
      {
        const message = InternalHelpDoc.p("Enter `key=value` pairs separated by spaces");
        return InternalListPrompt.list({
          message: InternalHelpDoc.toAnsiText(message).trim(),
          delimiter: " "
        }).pipe(Effect.flatMap(args => {
          const identifier = Option.getOrElse(getIdentifierInternal(self), () => "");
          return parseInternal(self, HashMap.make([identifier, args]), config).pipe(Effect.as(Arr.prepend(args, identifier)));
        }), Effect.zipLeft(Console.log()));
      }
    case "Map":
      {
        return wizardInternal(self.options, config);
      }
    case "Both":
      {
        return Effect.zipWith(wizardInternal(self.left, config), wizardInternal(self.right, config), (left, right) => Arr.appendAll(left, right));
      }
    case "OrElse":
      {
        const alternativeHelp = InternalHelpDoc.p("Select which option you would like to use");
        const message = pipe(getHelpInternal(self), InternalHelpDoc.sequence(alternativeHelp));
        const makeChoice = (title, value) => ({
          title,
          value
        });
        const choices = Arr.getSomes([Option.map(getIdentifierInternal(self.left), title => makeChoice(title, self.left)), Option.map(getIdentifierInternal(self.right), title => makeChoice(title, self.right))]);
        return InternalSelectPrompt.select({
          message: InternalHelpDoc.toAnsiText(message).trimEnd(),
          choices
        }).pipe(Effect.flatMap(option => wizardInternal(option, config)));
      }
    case "Variadic":
      {
        const repeatHelp = InternalHelpDoc.p("How many times should this argument be repeated?");
        const message = pipe(getHelpInternal(self), InternalHelpDoc.sequence(repeatHelp));
        return InternalNumberPrompt.integer({
          message: InternalHelpDoc.toAnsiText(message).trimEnd(),
          min: getMinSizeInternal(self),
          max: getMaxSizeInternal(self)
        }).pipe(Effect.flatMap(n => n <= 0 ? Effect.succeed(Arr.empty()) : Ref.make(Arr.empty()).pipe(Effect.flatMap(ref => wizardInternal(self.argumentOption, config).pipe(Effect.flatMap(args => Ref.update(ref, Arr.appendAll(args))), Effect.repeatN(n - 1), Effect.zipRight(Ref.get(ref)))))));
      }
    case "WithDefault":
      {
        if (isBoolInternal(self.options)) {
          return wizardInternal(self.options, config);
        }
        const defaultHelp = InternalHelpDoc.p(`This option is optional - use the default?`);
        const message = pipe(getHelpInternal(self.options), InternalHelpDoc.sequence(defaultHelp));
        return InternalSelectPrompt.select({
          message: InternalHelpDoc.toAnsiText(message).trimEnd(),
          choices: [{
            title: "Yes",
            value: true,
            description: `use the default ${Option.isOption(self.fallback) ? Option.match(self.fallback, {
              onNone: () => "",
              onSome: a => `(${JSON.stringify(a)})`
            }) : `(${JSON.stringify(self.fallback)})`}`
          }, {
            title: "No",
            value: false,
            description: "use a custom value"
          }]
        }).pipe(Effect.zipLeft(Console.log()), Effect.flatMap(useFallback => useFallback ? Effect.succeed(Arr.empty()) : wizardInternal(self.options, config)));
      }
    case "WithFallback":
      {
        if (isBoolInternal(self.options)) {
          return wizardInternal(self.options, config);
        }
        // TODO: should we use the prompt directly here?
        if (InternalPrompt.isPrompt(self.effect)) {
          return wizardInternal(self.options, config);
        }
        const defaultHelp = InternalHelpDoc.p(`Try load this option from the environment?`);
        const message = pipe(getHelpInternal(self.options), InternalHelpDoc.sequence(defaultHelp));
        return InternalSelectPrompt.select({
          message: InternalHelpDoc.toAnsiText(message).trimEnd(),
          choices: [{
            title: `Use environment variables`,
            value: true
          }, {
            title: "Custom",
            value: false
          }]
        }).pipe(Effect.zipLeft(Console.log()), Effect.flatMap(useFallback => useFallback ? Effect.succeed(Arr.empty()) : wizardInternal(self.options, config)));
      }
  }
};
// =============================================================================
// Parsing Internals
// =============================================================================
/**
 * Returns a possible `ValidationError` when parsing the commands, leftover
 * arguments from `input` and a mapping between each flag and its values.
 */
const matchOptions = (input, options, config) => {
  if (Arr.isNonEmptyReadonlyArray(options)) {
    return findOptions(input, options, config).pipe(Effect.flatMap(([otherArgs, otherOptions, map1]) => {
      if (HashMap.isEmpty(map1)) {
        return Effect.succeed([Option.none(), input, map1]);
      }
      return matchOptions(otherArgs, otherOptions, config).pipe(Effect.map(([error, otherArgs, map2]) => [error, otherArgs, merge(map1, Arr.fromIterable(map2))]));
    }), Effect.catchAll(e => Effect.succeed([Option.some(e), input, HashMap.empty()])));
  }
  return Arr.isEmptyReadonlyArray(input) ? Effect.succeed([Option.none(), Arr.empty(), HashMap.empty()]) : Effect.succeed([Option.none(), input, HashMap.empty()]);
};
/**
 * Returns the leftover arguments, leftover options, and a mapping between the
 * first argument with its values if it corresponds to an option flag.
 */
const findOptions = (input, options, config) => Arr.matchLeft(options, {
  onEmpty: () => Effect.succeed([input, Arr.empty(), HashMap.empty()]),
  onNonEmpty: (head, tail) => parseCommandLine(head, input, config).pipe(Effect.flatMap(({
    leftover,
    parsed
  }) => Option.match(parsed, {
    onNone: () => findOptions(leftover, tail, config).pipe(Effect.map(([nextArgs, nextOptions, map]) => [nextArgs, Arr.prepend(nextOptions, head), map])),
    onSome: ({
      name,
      values
    }) => Effect.succeed([leftover, tail, HashMap.make([name, values])])
  })), Effect.catchTags({
    CorrectedFlag: e => findOptions(input, tail, config).pipe(Effect.catchSome(() => Option.some(Effect.fail(e))), Effect.flatMap(([otherArgs, otherOptions, map]) => Effect.fail(e).pipe(Effect.when(() => HashMap.isEmpty(map)), Effect.as([otherArgs, Arr.prepend(otherOptions, head), map])))),
    MissingFlag: () => findOptions(input, tail, config).pipe(Effect.map(([otherArgs, otherOptions, map]) => [otherArgs, Arr.prepend(otherOptions, head), map])),
    UnclusteredFlag: e => matchUnclustered(e.unclustered, e.rest, options, config).pipe(Effect.catchAll(() => Effect.fail(e)))
  }))
});
const CLUSTERED_REGEX = /^-{1}([^-]{2,}$)/;
const FLAG_REGEX = /^(--[^=]+)(?:=(.+))?$/;
/**
 * Normalizes the leading command-line argument by performing the following:
 *   1. If a clustered series of short command-line options is encountered,
 *      uncluster the options and return a `ValidationError.UnclusteredFlag`
 *      to be handled later on in the parsing algorithm
 *   2. If a long command-line option with a value is encountered, ensure that
 *      the option and it's value are separated (i.e. `--option=value` becomes
 *      ["--option", "value"])
 */
const processArgs = args => Arr.matchLeft(args, {
  onEmpty: () => Effect.succeed(Arr.empty()),
  onNonEmpty: (head, tail) => {
    const value = head.trim();
    // Attempt to match clustered short command-line arguments (i.e. `-abc`)
    if (CLUSTERED_REGEX.test(value)) {
      const unclustered = value.substring(1).split("").map(c => `-${c}`);
      return Effect.fail(InternalValidationError.unclusteredFlag(InternalHelpDoc.empty, unclustered, tail));
    }
    // Attempt to match a long command-line argument and ensure the option and
    // it's value have been separated and added back to the arguments
    if (FLAG_REGEX.test(value)) {
      const result = FLAG_REGEX.exec(value);
      if (result !== null && result[2] !== undefined) {
        return Effect.succeed(Arr.appendAll([result[1], result[2]], tail));
      }
    }
    // Otherwise return the original command-line arguments
    return Effect.succeed(args);
  }
});
/**
 * Processes the command-line arguments for a parseable option, returning the
 * parsed command line results, which inclue:
 *   - The name of the option and its associated value(s), if any
 *   - Any leftover command-line arguments
 */
const parseCommandLine = (self, args, config) => {
  switch (self._tag) {
    case "Single":
      {
        return processArgs(args).pipe(Effect.flatMap(args => Arr.matchLeft(args, {
          onEmpty: () => {
            const error = InternalHelpDoc.p(`Expected to find option: '${self.fullName}'`);
            return Effect.fail(InternalValidationError.missingFlag(error));
          },
          onNonEmpty: (head, tail) => {
            const normalize = value => InternalCliConfig.normalizeCase(config, value);
            const normalizedHead = normalize(head);
            const normalizedNames = Arr.map(getNames(self), name => normalize(name));
            if (Arr.contains(normalizedNames, normalizedHead)) {
              if (InternalPrimitive.isBool(self.primitiveType)) {
                return Arr.matchLeft(tail, {
                  onEmpty: () => {
                    const parsed = Option.some({
                      name: head,
                      values: Arr.empty()
                    });
                    return Effect.succeed({
                      parsed,
                      leftover: tail
                    });
                  },
                  onNonEmpty: (value, leftover) => {
                    if (InternalPrimitive.isTrueValue(value)) {
                      const parsed = Option.some({
                        name: head,
                        values: Arr.of("true")
                      });
                      return Effect.succeed({
                        parsed,
                        leftover
                      });
                    }
                    if (InternalPrimitive.isFalseValue(value)) {
                      const parsed = Option.some({
                        name: head,
                        values: Arr.of("false")
                      });
                      return Effect.succeed({
                        parsed,
                        leftover
                      });
                    }
                    const parsed = Option.some({
                      name: head,
                      values: Arr.empty()
                    });
                    return Effect.succeed({
                      parsed,
                      leftover: tail
                    });
                  }
                });
              }
              return Arr.matchLeft(tail, {
                onEmpty: () => {
                  const error = InternalHelpDoc.p(`Expected a value following option: '${self.fullName}'`);
                  return Effect.fail(InternalValidationError.missingValue(error));
                },
                onNonEmpty: (value, leftover) => {
                  const parsed = Option.some({
                    name: head,
                    values: Arr.of(value)
                  });
                  return Effect.succeed({
                    parsed,
                    leftover
                  });
                }
              });
            }
            if (self.name.length > config.autoCorrectLimit + 1 && InternalAutoCorrect.levensteinDistance(head, self.fullName, config) <= config.autoCorrectLimit) {
              const error = InternalHelpDoc.p(`The flag '${head}' is not recognized. Did you mean '${self.fullName}'?`);
              return Effect.fail(InternalValidationError.correctedFlag(error));
            }
            const error = InternalHelpDoc.p(`Expected to find option: '${self.fullName}'`);
            return Effect.fail(InternalValidationError.missingFlag(error));
          }
        })));
      }
    case "KeyValueMap":
      {
        const normalizedNames = Arr.map(getNames(self.argumentOption), name => InternalCliConfig.normalizeCase(config, name));
        return Arr.matchLeft(args, {
          onEmpty: () => Effect.succeed({
            parsed: Option.none(),
            leftover: args
          }),
          onNonEmpty: (head, tail) => {
            const loop = args => {
              let keyValues = Arr.empty();
              let leftover = args;
              while (Arr.isNonEmptyReadonlyArray(leftover)) {
                const name = Arr.headNonEmpty(leftover).trim();
                const normalizedName = InternalCliConfig.normalizeCase(config, name);
                // Can be in the form of "--flag key1=value1 --flag key2=value2"
                if (leftover.length >= 2 && Arr.contains(normalizedNames, normalizedName)) {
                  const keyValue = leftover[1].trim();
                  const [key, value] = keyValue.split("=");
                  if (key !== undefined && value !== undefined && value.length > 0) {
                    keyValues = Arr.append(keyValues, keyValue);
                    leftover = leftover.slice(2);
                    continue;
                  }
                }
                // Can be in the form of "--flag key1=value1 key2=value2")
                if (name.includes("=")) {
                  const [key, value] = name.split("=");
                  if (key !== undefined && value !== undefined && value.length > 0) {
                    keyValues = Arr.append(keyValues, name);
                    leftover = leftover.slice(1);
                    continue;
                  }
                }
                break;
              }
              return [keyValues, leftover];
            };
            const normalizedName = InternalCliConfig.normalizeCase(config, head);
            if (Arr.contains(normalizedNames, normalizedName)) {
              const [values, leftover] = loop(tail);
              return Effect.succeed({
                parsed: Option.some({
                  name: head,
                  values
                }),
                leftover
              });
            }
            return Effect.succeed({
              parsed: Option.none(),
              leftover: args
            });
          }
        });
      }
    case "Variadic":
      {
        const normalizedNames = Arr.map(getNames(self.argumentOption), name => InternalCliConfig.normalizeCase(config, name));
        let optionName = undefined;
        let values = Arr.empty();
        let unparsed = args;
        let leftover = Arr.empty();
        while (Arr.isNonEmptyReadonlyArray(unparsed)) {
          const name = Arr.headNonEmpty(unparsed);
          const normalizedName = InternalCliConfig.normalizeCase(config, name);
          if (Arr.contains(normalizedNames, normalizedName)) {
            if (optionName === undefined) {
              optionName = name;
            }
            const value = unparsed[1];
            if (value !== undefined && value.length > 0) {
              values = Arr.append(values, value.trim());
            }
            unparsed = unparsed.slice(2);
          } else {
            leftover = Arr.append(leftover, Arr.headNonEmpty(unparsed));
            unparsed = unparsed.slice(1);
          }
        }
        const parsed = Option.fromNullable(optionName).pipe(Option.orElse(() => Option.some(self.argumentOption.fullName)), Option.map(name => ({
          name,
          values
        })));
        return Effect.succeed({
          parsed,
          leftover
        });
      }
  }
};
const matchUnclustered = (input, tail, options, config) => {
  if (Arr.isNonEmptyReadonlyArray(input)) {
    const flag = Arr.headNonEmpty(input);
    const otherFlags = Arr.tailNonEmpty(input);
    return findOptions(Arr.of(flag), options, config).pipe(Effect.flatMap(([_, opts1, map1]) => {
      if (HashMap.isEmpty(map1)) {
        return Effect.fail(InternalValidationError.unclusteredFlag(InternalHelpDoc.empty, Arr.empty(), tail));
      }
      return matchUnclustered(otherFlags, tail, opts1, config).pipe(Effect.map(([_, opts2, map2]) => [tail, opts2, merge(map1, Arr.fromIterable(map2))]));
    }));
  }
  return Effect.succeed([tail, options, HashMap.empty()]);
};
/**
 * Sums the list associated with the same key.
 */
const merge = (map1, map2) => {
  if (Arr.isNonEmptyReadonlyArray(map2)) {
    const head = Arr.headNonEmpty(map2);
    const tail = Arr.tailNonEmpty(map2);
    const newMap = Option.match(HashMap.get(map1, head[0]), {
      onNone: () => HashMap.set(map1, head[0], head[1]),
      onSome: elems => HashMap.set(map1, head[0], Arr.appendAll(elems, head[1]))
    });
    return merge(newMap, tail);
  }
  return map1;
};
// =============================================================================
// Completion Internals
// =============================================================================
const escape = string => string.replaceAll("\\", "\\\\").replaceAll("'", "'\\''").replaceAll("[", "\\[").replaceAll("]", "\\]").replaceAll(":", "\\:").replaceAll("$", "\\$").replaceAll("`", "\\`").replaceAll("(", "\\(").replaceAll(")", "\\)");
const getShortDescription = self => {
  switch (self._tag) {
    case "Empty":
    case "Both":
    case "OrElse":
      {
        return "";
      }
    case "Single":
      {
        return InternalSpan.getText(InternalHelpDoc.getSpan(self.description));
      }
    case "KeyValueMap":
    case "Variadic":
      {
        return getShortDescription(self.argumentOption);
      }
    case "Map":
    case "WithDefault":
    case "WithFallback":
      {
        return getShortDescription(self.options);
      }
  }
};
/** @internal */
export const getBashCompletions = self => {
  switch (self._tag) {
    case "Empty":
      {
        return Arr.empty();
      }
    case "Single":
      {
        const names = getNames(self);
        const cases = Arr.join(names, "|");
        const compgen = InternalPrimitive.getBashCompletions(self.primitiveType);
        return Arr.make(`${cases})`, `    COMPREPLY=( ${compgen} )`, `    return 0`, `    ;;`);
      }
    case "KeyValueMap":
    case "Variadic":
      {
        return getBashCompletions(self.argumentOption);
      }
    case "Map":
    case "WithDefault":
    case "WithFallback":
      {
        return getBashCompletions(self.options);
      }
    case "Both":
    case "OrElse":
      {
        const left = getBashCompletions(self.left);
        const right = getBashCompletions(self.right);
        return Arr.appendAll(left, right);
      }
  }
};
/** @internal */
export const getFishCompletions = self => {
  switch (self._tag) {
    case "Empty":
      {
        return Arr.empty();
      }
    case "Single":
      {
        const description = getShortDescription(self);
        const order = Order.mapInput(Order.boolean, tuple => !tuple[0]);
        return pipe(Arr.prepend(self.aliases, self.name), Arr.map(name => [name.length === 1, name]), Arr.sort(order), Arr.flatMap(([isShort, name]) => Arr.make(isShort ? "-s" : "-l", name)), Arr.appendAll(InternalPrimitive.getFishCompletions(self.primitiveType)), Arr.appendAll(description.length === 0 ? Arr.empty() : Arr.of(`-d '${description}'`)), Arr.join(" "), Arr.of);
      }
    case "KeyValueMap":
    case "Variadic":
      {
        return getFishCompletions(self.argumentOption);
      }
    case "Map":
    case "WithDefault":
    case "WithFallback":
      {
        return getFishCompletions(self.options);
      }
    case "Both":
    case "OrElse":
      {
        return pipe(getFishCompletions(self.left), Arr.appendAll(getFishCompletions(self.right)));
      }
  }
};
/** @internal */
export const getZshCompletions = (self, state = {
  conflicts: Arr.empty(),
  multiple: false
}) => {
  switch (self._tag) {
    case "Empty":
      {
        return Arr.empty();
      }
    case "Single":
      {
        const names = getNames(self);
        const description = getShortDescription(self);
        const possibleValues = InternalPrimitive.getZshCompletions(self.primitiveType);
        const multiple = state.multiple ? "*" : "";
        const conflicts = Arr.isNonEmptyReadonlyArray(state.conflicts) ? `(${Arr.join(state.conflicts, " ")})` : "";
        return Arr.map(names, name => `${conflicts}${multiple}${name}[${escape(description)}]${possibleValues}`);
      }
    case "KeyValueMap":
      {
        return getZshCompletions(self.argumentOption, {
          ...state,
          multiple: true
        });
      }
    case "Map":
    case "WithDefault":
    case "WithFallback":
      {
        return getZshCompletions(self.options, state);
      }
    case "Both":
      {
        const left = getZshCompletions(self.left, state);
        const right = getZshCompletions(self.right, state);
        return Arr.appendAll(left, right);
      }
    case "OrElse":
      {
        const leftNames = getNames(self.left);
        const rightNames = getNames(self.right);
        const left = getZshCompletions(self.left, {
          ...state,
          conflicts: Arr.appendAll(state.conflicts, rightNames)
        });
        const right = getZshCompletions(self.right, {
          ...state,
          conflicts: Arr.appendAll(state.conflicts, leftNames)
        });
        return Arr.appendAll(left, right);
      }
    case "Variadic":
      {
        return Option.isSome(self.max) && self.max.value > 1 ? getZshCompletions(self.argumentOption, {
          ...state,
          multiple: true
        }) : getZshCompletions(self.argumentOption, state);
      }
  }
};
//# sourceMappingURL=options.js.map