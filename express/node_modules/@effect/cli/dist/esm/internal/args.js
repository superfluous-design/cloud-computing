import * as Arr from "effect/Array";
import * as ConfigError from "effect/ConfigError";
import * as Console from "effect/Console";
import * as Effect from "effect/Effect";
import * as Either from "effect/Either";
import { dual, pipe } from "effect/Function";
import * as Inspectable from "effect/Inspectable";
import * as Option from "effect/Option";
import * as ParseResult from "effect/ParseResult";
import { pipeArguments } from "effect/Pipeable";
import * as Predicate from "effect/Predicate";
import * as Ref from "effect/Ref";
import * as InternalFiles from "./files.js";
import * as InternalHelpDoc from "./helpDoc.js";
import * as InternalSpan from "./helpDoc/span.js";
import * as InternalPrimitive from "./primitive.js";
import * as InternalNumberPrompt from "./prompt/number.js";
import * as InternalSelectPrompt from "./prompt/select.js";
import * as InternalUsage from "./usage.js";
import * as InternalValidationError from "./validationError.js";
const ArgsSymbolKey = "@effect/cli/Args";
/** @internal */
export const ArgsTypeId = /*#__PURE__*/Symbol.for(ArgsSymbolKey);
const proto = {
  [ArgsTypeId]: {
    _A: _ => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// =============================================================================
// Refinements
// =============================================================================
/** @internal */
export const isArgs = u => typeof u === "object" && u != null && ArgsTypeId in u;
/** @internal */
export const isInstruction = self => self;
/** @internal */
export const isEmpty = self => self._tag === "Empty";
/** @internal */
export const isSingle = self => self._tag === "Single";
/** @internal */
export const isBoth = self => self._tag === "Both";
/** @internal */
export const isMap = self => self._tag === "Map";
/** @internal */
export const isVariadic = self => self._tag === "Variadic";
/** @internal */
export const isWithDefault = self => self._tag === "WithDefault";
/** @internal */
export const isWithFallbackConfig = self => self._tag === "WithFallbackConfig";
// =============================================================================
// Constructors
// =============================================================================
/** @internal */
export const all = function () {
  if (arguments.length === 1) {
    if (isArgs(arguments[0])) {
      return map(arguments[0], x => [x]);
    } else if (Arr.isArray(arguments[0])) {
      return allTupled(arguments[0]);
    } else {
      const entries = Object.entries(arguments[0]);
      let result = map(entries[0][1], value => ({
        [entries[0][0]]: value
      }));
      if (entries.length === 1) {
        return result;
      }
      const rest = entries.slice(1);
      for (const [key, options] of rest) {
        result = map(makeBoth(result, options), ([record, value]) => ({
          ...record,
          [key]: value
        }));
      }
      return result;
    }
  }
  return allTupled(arguments[0]);
};
/** @internal */
export const boolean = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.boolean(Option.none()));
/** @internal */
export const choice = (choices, config) => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.choice(choices));
/** @internal */
export const date = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.date);
/** @internal */
export const directory = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.path("directory", config?.exists || "either"));
/** @internal */
export const file = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.path("file", config?.exists || "either"));
/** @internal */
export const fileContent = config => mapEffect(file({
  ...config,
  exists: "yes"
}), path => Effect.mapError(InternalFiles.read(path), e => InternalHelpDoc.p(e)));
/** @internal */
export const fileParse = config => mapEffect(fileText(config), ([path, content]) => Effect.mapError(InternalFiles.parse(path, content, config?.format), e => InternalHelpDoc.p(e)));
/** @internal */
export const fileSchema = (schema, config) => withSchema(fileParse(config), schema);
/** @internal */
export const fileText = config => mapEffect(file({
  ...config,
  exists: "yes"
}), path => Effect.mapError(InternalFiles.readString(path), e => InternalHelpDoc.p(e)));
/** @internal */
export const float = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.float);
/** @internal */
export const integer = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.integer);
/** @internal */
export const none = /*#__PURE__*/(() => {
  const op = /*#__PURE__*/Object.create(proto);
  op._tag = "Empty";
  return op;
})();
/** @internal */
export const path = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.path("either", config?.exists || "either"));
/** @internal */
export const redacted = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.redacted);
/** @internal */
export const secret = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.secret);
/** @internal */
export const text = config => makeSingle(Option.fromNullable(config?.name), InternalPrimitive.text);
// =============================================================================
// Combinators
// =============================================================================
/** @internal */
export const atLeast = /*#__PURE__*/dual(2, (self, times) => makeVariadic(self, Option.some(times), Option.none()));
/** @internal */
export const atMost = /*#__PURE__*/dual(2, (self, times) => makeVariadic(self, Option.none(), Option.some(times)));
/** @internal */
export const between = /*#__PURE__*/dual(3, (self, min, max) => makeVariadic(self, Option.some(min), Option.some(max)));
/** @internal */
export const getHelp = self => getHelpInternal(self);
/** @internal */
export const getIdentifier = self => getIdentifierInternal(self);
/** @internal */
export const getMinSize = self => getMinSizeInternal(self);
/** @internal */
export const getMaxSize = self => getMaxSizeInternal(self);
/** @internal */
export const getUsage = self => getUsageInternal(self);
/** @internal */
export const map = /*#__PURE__*/dual(2, (self, f) => mapEffect(self, a => Effect.succeed(f(a))));
/** @internal */
export const mapEffect = /*#__PURE__*/dual(2, (self, f) => makeMap(self, f));
/** @internal */
export const mapTryCatch = /*#__PURE__*/dual(3, (self, f, onError) => mapEffect(self, a => {
  try {
    return Either.right(f(a));
  } catch (e) {
    return Either.left(onError(e));
  }
}));
/** @internal */
export const optional = self => makeWithDefault(map(self, Option.some), Option.none());
/** @internal */
export const repeated = self => makeVariadic(self, Option.none(), Option.none());
/** @internal */
export const validate = /*#__PURE__*/dual(3, (self, args, config) => validateInternal(self, args, config));
/** @internal */
export const withDefault = /*#__PURE__*/dual(2, (self, fallback) => makeWithDefault(self, fallback));
/** @internal */
export const withFallbackConfig = /*#__PURE__*/dual(2, (self, config) => {
  if (isInstruction(self) && isWithDefault(self)) {
    return makeWithDefault(withFallbackConfig(self.args, config), self.fallback);
  }
  return makeWithFallbackConfig(self, config);
});
/** @internal */
export const withSchema = /*#__PURE__*/dual(2, (self, schema) => {
  const decode = ParseResult.decode(schema);
  return mapEffect(self, _ => Effect.mapError(decode(_), issue => InternalHelpDoc.p(ParseResult.TreeFormatter.formatIssueSync(issue))));
});
/** @internal */
export const withDescription = /*#__PURE__*/dual(2, (self, description) => withDescriptionInternal(self, description));
/** @internal */
export const wizard = /*#__PURE__*/dual(2, (self, config) => wizardInternal(self, config));
// =============================================================================
// Internals
// =============================================================================
const allTupled = arg => {
  if (arg.length === 0) {
    return none;
  }
  if (arg.length === 1) {
    return map(arg[0], x => [x]);
  }
  let result = map(arg[0], x => [x]);
  for (let i = 1; i < arg.length; i++) {
    const curr = arg[i];
    result = map(makeBoth(result, curr), ([a, b]) => [...a, b]);
  }
  return result;
};
const getHelpInternal = self => {
  switch (self._tag) {
    case "Empty":
      {
        return InternalHelpDoc.empty;
      }
    case "Single":
      {
        return InternalHelpDoc.descriptionList([[InternalSpan.weak(self.name), InternalHelpDoc.sequence(InternalHelpDoc.p(InternalPrimitive.getHelp(self.primitiveType)), self.description)]]);
      }
    case "Map":
      {
        return getHelpInternal(self.args);
      }
    case "Both":
      {
        return InternalHelpDoc.sequence(getHelpInternal(self.left), getHelpInternal(self.right));
      }
    case "Variadic":
      {
        const help = getHelpInternal(self.args);
        return InternalHelpDoc.mapDescriptionList(help, (oldSpan, oldBlock) => {
          const min = getMinSizeInternal(self);
          const max = getMaxSizeInternal(self);
          const newSpan = InternalSpan.text(Option.isSome(self.max) ? ` ${min} - ${max}` : min === 0 ? "..." : ` ${min}+`);
          const newBlock = InternalHelpDoc.p(Option.isSome(self.max) ? `This argument must be repeated at least ${min} times and may be repeated up to ${max} times.` : min === 0 ? "This argument may be repeated zero or more times." : `This argument must be repeated at least ${min} times.`);
          return [InternalSpan.concat(oldSpan, newSpan), InternalHelpDoc.sequence(oldBlock, newBlock)];
        });
      }
    case "WithDefault":
      {
        return InternalHelpDoc.mapDescriptionList(getHelpInternal(self.args), (span, block) => {
          const optionalDescription = Option.isOption(self.fallback) ? Option.match(self.fallback, {
            onNone: () => InternalHelpDoc.p("This setting is optional."),
            onSome: fallbackValue => {
              const inspectableValue = Predicate.isObject(fallbackValue) ? fallbackValue : String(fallbackValue);
              const displayValue = Inspectable.toStringUnknown(inspectableValue, 0);
              return InternalHelpDoc.p(`This setting is optional. Defaults to: ${displayValue}`);
            }
          }) : InternalHelpDoc.p("This setting is optional.");
          return [span, InternalHelpDoc.sequence(block, optionalDescription)];
        });
      }
    case "WithFallbackConfig":
      {
        return InternalHelpDoc.mapDescriptionList(getHelpInternal(self.args), (span, block) => [span, InternalHelpDoc.sequence(block, InternalHelpDoc.p("This argument can be set from environment variables."))]);
      }
  }
};
const getIdentifierInternal = self => {
  switch (self._tag) {
    case "Empty":
      {
        return Option.none();
      }
    case "Single":
      {
        return Option.some(self.name);
      }
    case "Map":
    case "Variadic":
    case "WithDefault":
    case "WithFallbackConfig":
      {
        return getIdentifierInternal(self.args);
      }
    case "Both":
      {
        const ids = Arr.getSomes([getIdentifierInternal(self.left), getIdentifierInternal(self.right)]);
        return Arr.match(ids, {
          onEmpty: () => Option.none(),
          onNonEmpty: ids => Option.some(Arr.join(ids, ", "))
        });
      }
  }
};
const getMinSizeInternal = self => {
  switch (self._tag) {
    case "Empty":
    case "WithDefault":
    case "WithFallbackConfig":
      {
        return 0;
      }
    case "Single":
      {
        return 1;
      }
    case "Map":
      {
        return getMinSizeInternal(self.args);
      }
    case "Both":
      {
        const leftMinSize = getMinSizeInternal(self.left);
        const rightMinSize = getMinSizeInternal(self.right);
        return leftMinSize + rightMinSize;
      }
    case "Variadic":
      {
        const argsMinSize = getMinSizeInternal(self.args);
        return Math.floor(Option.getOrElse(self.min, () => 0) * argsMinSize);
      }
  }
};
const getMaxSizeInternal = self => {
  switch (self._tag) {
    case "Empty":
      {
        return 0;
      }
    case "Single":
      {
        return 1;
      }
    case "Map":
    case "WithDefault":
    case "WithFallbackConfig":
      {
        return getMaxSizeInternal(self.args);
      }
    case "Both":
      {
        const leftMaxSize = getMaxSizeInternal(self.left);
        const rightMaxSize = getMaxSizeInternal(self.right);
        return leftMaxSize + rightMaxSize;
      }
    case "Variadic":
      {
        const argsMaxSize = getMaxSizeInternal(self.args);
        return Math.floor(Option.getOrElse(self.max, () => Number.MAX_SAFE_INTEGER / 2) * argsMaxSize);
      }
  }
};
const getUsageInternal = self => {
  switch (self._tag) {
    case "Empty":
      {
        return InternalUsage.empty;
      }
    case "Single":
      {
        return InternalUsage.named(Arr.of(self.name), InternalPrimitive.getChoices(self.primitiveType));
      }
    case "Map":
      {
        return getUsageInternal(self.args);
      }
    case "Both":
      {
        return InternalUsage.concat(getUsageInternal(self.left), getUsageInternal(self.right));
      }
    case "Variadic":
      {
        return InternalUsage.repeated(getUsageInternal(self.args));
      }
    case "WithDefault":
    case "WithFallbackConfig":
      {
        return InternalUsage.optional(getUsageInternal(self.args));
      }
  }
};
const makeSingle = (pseudoName, primitiveType, description = InternalHelpDoc.empty) => {
  const op = Object.create(proto);
  op._tag = "Single";
  op.name = `<${Option.getOrElse(pseudoName, () => InternalPrimitive.getTypeName(primitiveType))}>`;
  op.pseudoName = pseudoName;
  op.primitiveType = primitiveType;
  op.description = description;
  return op;
};
const makeMap = (self, f) => {
  const op = Object.create(proto);
  op._tag = "Map";
  op.args = self;
  op.f = f;
  return op;
};
const makeBoth = (left, right) => {
  const op = Object.create(proto);
  op._tag = "Both";
  op.left = left;
  op.right = right;
  return op;
};
const makeWithDefault = (self, fallback) => {
  const op = Object.create(proto);
  op._tag = "WithDefault";
  op.args = self;
  op.fallback = fallback;
  return op;
};
const makeWithFallbackConfig = (args, config) => {
  const op = Object.create(proto);
  op._tag = "WithFallbackConfig";
  op.args = args;
  op.config = config;
  return op;
};
const makeVariadic = (args, min, max) => {
  const op = Object.create(proto);
  op._tag = "Variadic";
  op.args = args;
  op.min = min;
  op.max = max;
  return op;
};
const validateInternal = (self, args, config) => {
  switch (self._tag) {
    case "Empty":
      {
        return Effect.succeed([args, undefined]);
      }
    case "Single":
      {
        return Effect.suspend(() => {
          return Arr.matchLeft(args, {
            onEmpty: () => {
              const choices = InternalPrimitive.getChoices(self.primitiveType);
              if (Option.isSome(self.pseudoName) && Option.isSome(choices)) {
                return Effect.fail(InternalValidationError.missingValue(InternalHelpDoc.p(`Missing argument <${self.pseudoName.value}> with choices ${choices.value}`)));
              }
              if (Option.isSome(self.pseudoName)) {
                return Effect.fail(InternalValidationError.missingValue(InternalHelpDoc.p(`Missing argument <${self.pseudoName.value}>`)));
              }
              if (Option.isSome(choices)) {
                return Effect.fail(InternalValidationError.missingValue(InternalHelpDoc.p(`Missing argument ${InternalPrimitive.getTypeName(self.primitiveType)} with choices ${choices.value}`)));
              }
              return Effect.fail(InternalValidationError.missingValue(InternalHelpDoc.p(`Missing argument ${InternalPrimitive.getTypeName(self.primitiveType)}`)));
            },
            onNonEmpty: (head, tail) => InternalPrimitive.validate(self.primitiveType, Option.some(head), config).pipe(Effect.mapBoth({
              onFailure: text => InternalValidationError.invalidArgument(InternalHelpDoc.p(text)),
              onSuccess: a => [tail, a]
            }))
          });
        });
      }
    case "Map":
      {
        return validateInternal(self.args, args, config).pipe(Effect.flatMap(([leftover, a]) => Effect.matchEffect(self.f(a), {
          onFailure: doc => Effect.fail(InternalValidationError.invalidArgument(doc)),
          onSuccess: b => Effect.succeed([leftover, b])
        })));
      }
    case "Both":
      {
        return validateInternal(self.left, args, config).pipe(Effect.flatMap(([args, a]) => validateInternal(self.right, args, config).pipe(Effect.map(([args, b]) => [args, [a, b]]))));
      }
    case "Variadic":
      {
        const min1 = Option.getOrElse(self.min, () => 0);
        const max1 = Option.getOrElse(self.max, () => Number.MAX_SAFE_INTEGER);
        const loop = (args, acc) => {
          if (acc.length >= max1) {
            return Effect.succeed([args, acc]);
          }
          return validateInternal(self.args, args, config).pipe(Effect.matchEffect({
            onFailure: failure => acc.length >= min1 && Arr.isEmptyReadonlyArray(args) ? Effect.succeed([args, acc]) : Effect.fail(failure),
            onSuccess: ([args, a]) => loop(args, Arr.append(acc, a))
          }));
        };
        return loop(args, Arr.empty()).pipe(Effect.map(([args, acc]) => [args, acc]));
      }
    case "WithDefault":
      {
        return validateInternal(self.args, args, config).pipe(Effect.catchTag("MissingValue", () => Effect.succeed([args, self.fallback])));
      }
    case "WithFallbackConfig":
      {
        return validateInternal(self.args, args, config).pipe(Effect.catchTag("MissingValue", e => Effect.map(Effect.catchAll(self.config, e2 => {
          if (ConfigError.isMissingDataOnly(e2)) {
            const help = InternalHelpDoc.p(String(e2));
            const error = InternalValidationError.invalidValue(help);
            return Effect.fail(error);
          }
          return Effect.fail(e);
        }), value => [args, value])));
      }
  }
};
const withDescriptionInternal = (self, description) => {
  switch (self._tag) {
    case "Empty":
      {
        return none;
      }
    case "Single":
      {
        const desc = InternalHelpDoc.sequence(self.description, InternalHelpDoc.p(description));
        return makeSingle(self.pseudoName, self.primitiveType, desc);
      }
    case "Map":
      {
        return makeMap(withDescriptionInternal(self.args, description), self.f);
      }
    case "Both":
      {
        return makeBoth(withDescriptionInternal(self.left, description), withDescriptionInternal(self.right, description));
      }
    case "Variadic":
      {
        return makeVariadic(withDescriptionInternal(self.args, description), self.min, self.max);
      }
    case "WithDefault":
      {
        return makeWithDefault(withDescriptionInternal(self.args, description), self.fallback);
      }
    case "WithFallbackConfig":
      {
        return makeWithFallbackConfig(withDescriptionInternal(self.args, description), self.config);
      }
  }
};
const wizardInternal = (self, config) => {
  switch (self._tag) {
    case "Empty":
      {
        return Effect.succeed(Arr.empty());
      }
    case "Single":
      {
        const help = getHelpInternal(self);
        return InternalPrimitive.wizard(self.primitiveType, help).pipe(Effect.zipLeft(Console.log()), Effect.flatMap(input => {
          const args = Arr.of(input);
          return validateInternal(self, args, config).pipe(Effect.as(args));
        }));
      }
    case "Map":
      {
        return wizardInternal(self.args, config).pipe(Effect.tap(args => validateInternal(self.args, args, config)));
      }
    case "Both":
      {
        return Effect.zipWith(wizardInternal(self.left, config), wizardInternal(self.right, config), (left, right) => Arr.appendAll(left, right)).pipe(Effect.tap(args => validateInternal(self, args, config)));
      }
    case "Variadic":
      {
        const repeatHelp = InternalHelpDoc.p("How many times should this argument should be repeated?");
        const message = pipe(getHelpInternal(self), InternalHelpDoc.sequence(repeatHelp));
        return InternalNumberPrompt.integer({
          message: InternalHelpDoc.toAnsiText(message).trimEnd(),
          min: getMinSizeInternal(self),
          max: getMaxSizeInternal(self)
        }).pipe(Effect.zipLeft(Console.log()), Effect.flatMap(n => n <= 0 ? Effect.succeed(Arr.empty()) : Ref.make(Arr.empty()).pipe(Effect.flatMap(ref => wizardInternal(self.args, config).pipe(Effect.flatMap(args => Ref.update(ref, Arr.appendAll(args))), Effect.repeatN(n - 1), Effect.zipRight(Ref.get(ref)), Effect.tap(args => validateInternal(self, args, config)))))));
      }
    case "WithDefault":
      {
        const defaultHelp = InternalHelpDoc.p(`This argument is optional - use the default?`);
        const message = pipe(getHelpInternal(self.args), InternalHelpDoc.sequence(defaultHelp));
        return InternalSelectPrompt.select({
          message: InternalHelpDoc.toAnsiText(message).trimEnd(),
          choices: [{
            title: `Default ['${JSON.stringify(self.fallback)}']`,
            value: true
          }, {
            title: "Custom",
            value: false
          }]
        }).pipe(Effect.zipLeft(Console.log()), Effect.flatMap(useFallback => useFallback ? Effect.succeed(Arr.empty()) : wizardInternal(self.args, config)));
      }
    case "WithFallbackConfig":
      {
        const defaultHelp = InternalHelpDoc.p(`Try load this option from the environment?`);
        const message = pipe(getHelpInternal(self.args), InternalHelpDoc.sequence(defaultHelp));
        return InternalSelectPrompt.select({
          message: InternalHelpDoc.toAnsiText(message).trimEnd(),
          choices: [{
            title: `Use environment variables`,
            value: true
          }, {
            title: "Custom",
            value: false
          }]
        }).pipe(Effect.zipLeft(Console.log()), Effect.flatMap(useFallback => useFallback ? Effect.succeed(Arr.empty()) : wizardInternal(self.args, config)));
      }
  }
};
// =============================================================================
// Completion Internals
// =============================================================================
const getShortDescription = self => {
  switch (self._tag) {
    case "Empty":
    case "Both":
      {
        return "";
      }
    case "Single":
      {
        return InternalSpan.getText(InternalHelpDoc.getSpan(self.description));
      }
    case "Map":
    case "Variadic":
    case "WithDefault":
    case "WithFallbackConfig":
      {
        return getShortDescription(self.args);
      }
  }
};
/** @internal */
export const getFishCompletions = self => {
  switch (self._tag) {
    case "Empty":
      {
        return Arr.empty();
      }
    case "Single":
      {
        const description = getShortDescription(self);
        return pipe(InternalPrimitive.getFishCompletions(self.primitiveType), Arr.appendAll(description.length === 0 ? Arr.empty() : Arr.of(`-d '${description}'`)), Arr.join(" "), Arr.of);
      }
    case "Both":
      {
        return pipe(getFishCompletions(self.left), Arr.appendAll(getFishCompletions(self.right)));
      }
    case "Map":
    case "Variadic":
    case "WithDefault":
    case "WithFallbackConfig":
      {
        return getFishCompletions(self.args);
      }
  }
};
export const getZshCompletions = (self, state = {
  multiple: false,
  optional: false
}) => {
  switch (self._tag) {
    case "Empty":
      {
        return Arr.empty();
      }
    case "Single":
      {
        const multiple = state.multiple ? "*" : "";
        const optional = state.optional ? "::" : ":";
        const shortDescription = getShortDescription(self);
        const description = shortDescription.length > 0 ? ` -- ${shortDescription}` : "";
        const possibleValues = InternalPrimitive.getZshCompletions(self.primitiveType);
        return possibleValues.length === 0 ? Arr.empty() : Arr.of(`${multiple}${optional}${self.name}${description}${possibleValues}`);
      }
    case "Map":
      {
        return getZshCompletions(self.args, state);
      }
    case "Both":
      {
        const left = getZshCompletions(self.left, state);
        const right = getZshCompletions(self.right, state);
        return Arr.appendAll(left, right);
      }
    case "Variadic":
      {
        return Option.isSome(self.max) && self.max.value > 1 ? getZshCompletions(self.args, {
          ...state,
          multiple: true
        }) : getZshCompletions(self.args, state);
      }
    case "WithDefault":
    case "WithFallbackConfig":
      {
        return getZshCompletions(self.args, {
          ...state,
          optional: true
        });
      }
  }
};
//# sourceMappingURL=args.js.map