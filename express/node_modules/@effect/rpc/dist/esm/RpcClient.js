/**
 * @since 1.0.0
 */
import * as Headers from "@effect/platform/Headers";
import * as HttpBody from "@effect/platform/HttpBody";
import * as HttpClient from "@effect/platform/HttpClient";
import * as HttpClientRequest from "@effect/platform/HttpClientRequest";
import * as Socket from "@effect/platform/Socket";
import * as Transferable from "@effect/platform/Transferable";
import * as Worker from "@effect/platform/Worker";
import * as Cause from "effect/Cause";
import * as Chunk from "effect/Chunk";
import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as Fiber from "effect/Fiber";
import * as FiberId from "effect/FiberId";
import * as FiberRef from "effect/FiberRef";
import { constVoid, dual, identity } from "effect/Function";
import { globalValue } from "effect/GlobalValue";
import * as Layer from "effect/Layer";
import * as Mailbox from "effect/Mailbox";
import * as Option from "effect/Option";
import * as Pool from "effect/Pool";
import * as Runtime from "effect/Runtime";
import * as Schedule from "effect/Schedule";
import * as Schema from "effect/Schema";
import * as Scope from "effect/Scope";
import * as Stream from "effect/Stream";
import { withRun } from "./internal/utils.js";
import * as Rpc from "./Rpc.js";
import { constPing, RequestId } from "./RpcMessage.js";
import * as RpcSchema from "./RpcSchema.js";
import * as RpcSerialization from "./RpcSerialization.js";
import * as RpcWorker from "./RpcWorker.js";
let requestIdCounter = /*#__PURE__*/BigInt(0);
/**
 * @since 1.0.0
 * @category client
 */
export const makeNoSerialization = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
  const spanPrefix = options?.spanPrefix ?? "RpcClient";
  const supportsAck = options?.supportsAck ?? true;
  const disableTracing = options?.disableTracing ?? false;
  const generateRequestId = options?.generateRequestId ?? (() => requestIdCounter++);
  const context = yield* Effect.context();
  const scope = Context.get(context, Scope.Scope);
  const entries = new Map();
  let isShutdown = false;
  yield* Scope.addFinalizer(scope, Effect.fiberIdWith(fiberId => {
    isShutdown = true;
    return clearEntries(Exit.interrupt(fiberId));
  }));
  const clearEntries = Effect.fnUntraced(function* (exit) {
    for (const [id, entry] of entries) {
      entries.delete(id);
      if (entry._tag === "Mailbox") {
        yield* entry.mailbox.done(exit);
      } else {
        entry.resume(exit);
      }
    }
  });
  const onRequest = rpc => {
    const isStream = RpcSchema.isStreamSchema(rpc.successSchema);
    const middleware = getRpcClientMiddleware(rpc);
    return (payload, options) => {
      const headers = options?.headers ? Headers.fromInput(options.headers) : Headers.empty;
      if (!isStream) {
        const effect = Effect.useSpan(`${spanPrefix}.${rpc._tag}`, {
          captureStackTrace: false
        }, span => onEffectRequest(rpc, middleware, span, "make" in rpc.payloadSchema ? rpc.payloadSchema.make(payload ?? {}) : {}, headers, options?.context ?? Context.empty(), options?.discard ?? false));
        return disableTracing ? Effect.withTracerEnabled(effect, false) : effect;
      }
      const mailbox = Effect.suspend(() => onStreamRequest(rpc, middleware, payload ? rpc.payloadSchema.make(payload) : {}, headers, options?.streamBufferSize ?? 16, options?.context ?? Context.empty()));
      if (options?.asMailbox) return mailbox;
      return Stream.unwrapScoped(Effect.map(mailbox, Mailbox.toStream));
    };
  };
  const onEffectRequest = (rpc, middleware, span, payload, headers, context, discard) => Effect.withFiberRuntime(parentFiber => {
    if (isShutdown) {
      return Effect.interrupt;
    }
    const id = generateRequestId();
    const send = middleware({
      _tag: "Request",
      id,
      tag: rpc._tag,
      payload,
      traceId: span.traceId,
      spanId: span.spanId,
      sampled: span.sampled,
      headers: Headers.merge(parentFiber.getFiberRef(currentHeaders), headers)
    });
    if (discard) {
      return Effect.flatMap(send, message => options.onFromClient({
        message,
        context,
        discard
      }));
    }
    const runtime = Runtime.make({
      context: parentFiber.currentContext,
      fiberRefs: parentFiber.getFiberRefs(),
      runtimeFlags: Runtime.defaultRuntime.runtimeFlags
    });
    let fiber;
    return Effect.onInterrupt(Effect.async(resume => {
      const entry = {
        _tag: "Effect",
        rpc,
        context,
        resume(exit) {
          resume(exit);
          if (fiber && !fiber.unsafePoll()) {
            parentFiber.currentScheduler.scheduleTask(() => {
              fiber.unsafeInterruptAsFork(parentFiber.id());
            }, 0);
          }
        }
      };
      entries.set(id, entry);
      fiber = send.pipe(Effect.flatMap(request => options.onFromClient({
        message: request,
        context,
        discard
      })), Effect.withParentSpan(span), Runtime.runFork(runtime));
      fiber.addObserver(exit => {
        if (exit._tag === "Failure") {
          return resume(exit);
        }
      });
    }), interruptors => {
      entries.delete(id);
      const ids = Array.from(interruptors).flatMap(id => Array.from(FiberId.toSet(id)));
      return Effect.zipRight(Fiber.interrupt(fiber), sendInterrupt(id, ids, context));
    });
  });
  const onStreamRequest = Effect.fnUntraced(function* (rpc, middleware, payload, headers, streamBufferSize, context) {
    if (isShutdown) {
      return yield* Effect.interrupt;
    }
    const span = yield* Effect.makeSpanScoped(`${spanPrefix}.${rpc._tag}`, {
      captureStackTrace: false
    }).pipe(disableTracing ? Effect.withTracerEnabled(false) : identity);
    const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
    const id = generateRequestId();
    const scope = Context.unsafeGet(fiber.currentContext, Scope.Scope);
    yield* Scope.addFinalizerExit(scope, exit => {
      if (!entries.has(id)) return Effect.void;
      entries.delete(id);
      return sendInterrupt(id, Exit.isFailure(exit) ? Array.from(Cause.interruptors(exit.cause)).flatMap(id => Array.from(FiberId.toSet(id))) : [], context);
    });
    const mailbox = yield* Mailbox.make(streamBufferSize);
    entries.set(id, {
      _tag: "Mailbox",
      rpc,
      mailbox,
      scope,
      context
    });
    yield* middleware({
      _tag: "Request",
      id,
      tag: rpc._tag,
      traceId: span.traceId,
      payload,
      spanId: span.spanId,
      sampled: span.sampled,
      headers: Headers.merge(fiber.getFiberRef(currentHeaders), headers)
    }).pipe(Effect.flatMap(request => options.onFromClient({
      message: request,
      context,
      discard: false
    })), Effect.withParentSpan(span), Effect.catchAllCause(error => mailbox.failCause(error)), Effect.interruptible, Effect.forkIn(scope));
    return mailbox;
  });
  const getRpcClientMiddleware = rpc => {
    const middlewares = [];
    for (const tag of rpc.middlewares.values()) {
      const middleware = context.unsafeMap.get(`${tag.key}/Client`);
      if (!middleware) continue;
      middlewares.push(middleware);
    }
    return middlewares.length === 0 ? Effect.succeed : function (request) {
      let i = 0;
      return Effect.map(Effect.whileLoop({
        while: () => i < middlewares.length,
        body: () => middlewares[i]({
          rpc,
          request
        }),
        step(nextRequest) {
          request = nextRequest;
          i++;
        }
      }), () => request);
    };
  };
  const sendInterrupt = (requestId, interruptors, context) => Effect.async(resume => {
    const parentFiber = Option.getOrThrow(Fiber.getCurrentFiber());
    const runtime = Runtime.make({
      context: parentFiber.currentContext,
      fiberRefs: parentFiber.getFiberRefs(),
      runtimeFlags: Runtime.defaultRuntime.runtimeFlags
    });
    const fiber = options.onFromClient({
      message: {
        _tag: "Interrupt",
        requestId,
        interruptors
      },
      context,
      discard: false
    }).pipe(Effect.timeout(1000), Runtime.runFork(runtime));
    fiber.addObserver(() => {
      resume(Effect.void);
    });
  });
  const write = message => {
    switch (message._tag) {
      case "Chunk":
        {
          const requestId = message.requestId;
          const entry = entries.get(requestId);
          if (!entry || entry._tag !== "Mailbox") return Effect.void;
          return entry.mailbox.offerAll(message.values).pipe(supportsAck ? Effect.zipRight(options.onFromClient({
            message: {
              _tag: "Ack",
              requestId: message.requestId
            },
            context: entry.context,
            discard: false
          })) : identity, Effect.catchAllCause(cause => entry.mailbox.done(Exit.failCause(cause))));
        }
      case "Exit":
        {
          const requestId = message.requestId;
          const entry = entries.get(requestId);
          if (!entry) return Effect.void;
          entries.delete(requestId);
          if (entry._tag === "Effect") {
            entry.resume(message.exit);
            return Effect.void;
          }
          return entry.mailbox.done(Exit.asVoid(message.exit));
        }
      case "Defect":
        {
          return clearEntries(Exit.die(message.defect));
        }
      case "ClientEnd":
        {
          return Effect.void;
        }
    }
  };
  const client = {};
  for (const rpc of group.requests.values()) {
    ;
    client[rpc._tag] = onRequest(rpc);
  }
  return {
    client: client,
    write
  };
});
/**
 * @since 1.0.0
 * @category client
 */
export const make = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
  const {
    run,
    send,
    supportsAck,
    supportsTransferables
  } = yield* Protocol;
  const entries = new Map();
  const {
    client,
    write
  } = yield* makeNoSerialization(group, {
    ...options,
    supportsAck,
    onFromClient({
      message
    }) {
      switch (message._tag) {
        case "Request":
          {
            const rpc = group.requests.get(message.tag);
            const schemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast);
            const collector = supportsTransferables ? Transferable.unsafeMakeCollector() : undefined;
            const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
            const entry = {
              rpc,
              context: collector ? Context.add(fiber.currentContext, Transferable.Collector, collector) : fiber.currentContext,
              decodeChunk: Option.isSome(schemas) ? Schema.decodeUnknown(Schema.NonEmptyArray(schemas.value.success)) : undefined
            };
            entries.set(message.id, entry);
            return Schema.encode(rpc.payloadSchema)(message.payload).pipe(Effect.locally(FiberRef.currentContext, entry.context), Effect.orDie, Effect.flatMap(payload => send({
              ...message,
              id: String(message.id),
              payload,
              headers: Object.entries(message.headers)
            }, collector && collector.unsafeClear())));
          }
        case "Ack":
          {
            const entry = entries.get(message.requestId);
            if (!entry) return Effect.void;
            return send({
              _tag: "Ack",
              requestId: String(message.requestId)
            });
          }
        case "Interrupt":
          {
            const entry = entries.get(message.requestId);
            if (!entry) return Effect.void;
            entries.delete(message.requestId);
            return send({
              _tag: "Interrupt",
              requestId: String(message.requestId)
            });
          }
        case "Eof":
          {
            return Effect.void;
          }
      }
    }
  });
  yield* run(message => {
    switch (message._tag) {
      case "Chunk":
        {
          const requestId = RequestId(message.requestId);
          const entry = entries.get(requestId);
          if (!entry || !entry.decodeChunk) return Effect.void;
          return entry.decodeChunk(message.values).pipe(Effect.locally(FiberRef.currentContext, entry.context), Effect.orDie, Effect.flatMap(chunk => write({
            _tag: "Chunk",
            clientId: 0,
            requestId: RequestId(message.requestId),
            values: chunk
          })), Effect.onError(cause => write({
            _tag: "Exit",
            clientId: 0,
            requestId: RequestId(message.requestId),
            exit: Exit.failCause(cause)
          })));
        }
      case "Exit":
        {
          const requestId = RequestId(message.requestId);
          const entry = entries.get(requestId);
          if (!entry) return Effect.void;
          entries.delete(requestId);
          return Schema.decode(Rpc.exitSchema(entry.rpc))(message.exit).pipe(Effect.locally(FiberRef.currentContext, entry.context), Effect.orDie, Effect.matchCauseEffect({
            onSuccess: exit => write({
              _tag: "Exit",
              clientId: 0,
              requestId,
              exit
            }),
            onFailure: cause => write({
              _tag: "Exit",
              clientId: 0,
              requestId,
              exit: Exit.failCause(cause)
            })
          }));
        }
      case "Defect":
        {
          return write({
            _tag: "Defect",
            clientId: 0,
            defect: decodeDefect(message.defect)
          });
        }
      default:
        {
          return Effect.void;
        }
    }
  }).pipe(Effect.catchAllCause(Effect.logError), Effect.interruptible, Effect.forkScoped);
  return client;
});
/**
 * @since 1.0.0
 * @category headers
 */
export const currentHeaders = /*#__PURE__*/globalValue("@effect/rpc/RpcClient/currentHeaders", () => FiberRef.unsafeMake(Headers.empty));
/**
 * @since 1.0.0
 * @category headers
 */
export const withHeaders = /*#__PURE__*/dual(2, (effect, headers) => Effect.locallyWith(effect, currentHeaders, Headers.merge(Headers.fromInput(headers))));
/**
 * @since 1.0.0
 * @category headers
 */
export const withHeadersEffect = /*#__PURE__*/dual(2, (effect, headers) => Effect.flatMap(headers, headers => withHeaders(effect, headers)));
/**
 * @since 1.0.0
 * @category protocol
 */
export class Protocol extends /*#__PURE__*/Context.Tag("@effect/rpc/RpcClient/Protocol")() {
  /**
   * @since 1.0.0
   */
  static make = /*#__PURE__*/withRun();
}
/**
 * @since 1.0.0
 * @category protocol
 */
export const makeProtocolHttp = client => Protocol.make(Effect.fnUntraced(function* (writeResponse) {
  const serialization = yield* RpcSerialization.RpcSerialization;
  const isJson = serialization.contentType === "application/json";
  const send = request => {
    if (request._tag !== "Request") {
      return Effect.void;
    }
    const parser = serialization.unsafeMake();
    const encoded = parser.encode(request);
    const body = typeof encoded === "string" ? HttpBody.text(encoded, serialization.contentType) : HttpBody.uint8Array(encoded, serialization.contentType);
    if (isJson) {
      return client.post("", {
        body
      }).pipe(Effect.flatMap(r => r.json), Effect.scoped, Effect.flatMap(u => {
        if (!Array.isArray(u)) {
          return Effect.dieMessage(`Expected an array of responses, but got: ${u}`);
        }
        let i = 0;
        return Effect.whileLoop({
          while: () => i < u.length,
          body: () => writeResponse(u[i++]),
          step: constVoid
        });
      }), Effect.orDie);
    }
    return client.post("", {
      body
    }).pipe(Effect.flatMap(r => Stream.runForEachChunk(r.stream, chunk => {
      const responses = Chunk.toReadonlyArray(chunk).flatMap(parser.decode);
      if (responses.length === 0) return Effect.void;
      let i = 0;
      return Effect.whileLoop({
        while: () => i < responses.length,
        body: () => writeResponse(responses[i++]),
        step: constVoid
      });
    })), Effect.orDie);
  };
  return {
    send,
    supportsAck: false,
    supportsTransferables: false
  };
}));
/**
 * @since 1.0.0
 * @category protocol
 */
export const layerProtocolHttp = options => Layer.scoped(Protocol, Effect.flatMap(HttpClient.HttpClient, client => {
  client = HttpClient.mapRequest(client, HttpClientRequest.prependUrl(options.url));
  return makeProtocolHttp(options.transformClient ? options.transformClient(client) : client);
}));
/**
 * @since 1.0.0
 * @category protocol
 */
export const makeProtocolSocket = options => Protocol.make(Effect.fnUntraced(function* (writeResponse) {
  const socket = yield* Socket.Socket;
  const serialization = yield* RpcSerialization.RpcSerialization;
  const write = yield* socket.writer;
  let parser = serialization.unsafeMake();
  yield* Effect.suspend(() => {
    parser = serialization.unsafeMake();
    return socket.runRaw(message => {
      try {
        const responses = parser.decode(message);
        if (responses.length === 0) return;
        let i = 0;
        return Effect.whileLoop({
          while: () => i < responses.length,
          body: () => writeResponse(responses[i++]),
          step: constVoid
        });
      } catch (defect) {
        return writeResponse({
          _tag: "Defect",
          defect
        });
      }
    });
  }).pipe(Effect.zipRight(Effect.fail(new Socket.SocketCloseError({
    reason: "Close",
    code: 1000
  }))), Effect.tapErrorCause(cause => {
    const error = Cause.failureOption(cause);
    if (options?.retryTransientErrors && Option.isSome(error) && (error.value.reason === "Open" || error.value.reason === "OpenTimeout")) {
      return Effect.void;
    }
    return writeResponse({
      _tag: "Defect",
      defect: Cause.squash(cause)
    });
  }), Effect.retry(Schedule.spaced(1000)), Effect.annotateLogs({
    module: "RpcClient",
    method: "makeProtocolSocket"
  }), Effect.interruptible, Effect.forkScoped);
  yield* Effect.suspend(() => write(parser.encode(constPing))).pipe(Effect.delay("30 seconds"), Effect.ignore, Effect.forever, Effect.interruptible, Effect.forkScoped);
  return {
    send(request) {
      return Effect.orDie(write(parser.encode(request)));
    },
    supportsAck: true,
    supportsTransferables: false
  };
}));
/**
 * @since 1.0.0
 * @category protocol
 */
export const makeProtocolWorker = options => Protocol.make(Effect.fnUntraced(function* (writeResponse) {
  const worker = yield* Worker.PlatformWorker;
  const scope = yield* Effect.scope;
  let workerId = 0;
  const initialMessage = yield* Effect.serviceOption(RpcWorker.InitialMessage);
  const entries = new Map();
  const acquire = Effect.gen(function* () {
    const id = workerId++;
    const backing = yield* worker.spawn(id);
    const readyLatch = yield* Effect.makeLatch();
    yield* backing.run(message => {
      if (message[0] === 0) {
        return readyLatch.open;
      }
      const response = message[1];
      if (response._tag === "Exit") {
        const entry = entries.get(response.requestId);
        if (entry) {
          entries.delete(response.requestId);
          entry.latch.unsafeOpen();
          return writeResponse(response);
        }
      } else if (response._tag === "Defect") {
        for (const [requestId, entry] of entries) {
          entries.delete(requestId);
          entry.latch.unsafeOpen();
        }
        return writeResponse(response);
      }
      return writeResponse(response);
    }).pipe(Effect.tapErrorCause(cause => writeResponse({
      _tag: "Defect",
      defect: Cause.squash(cause)
    })), Effect.retry(Schedule.spaced(1000)), Effect.annotateLogs({
      module: "RpcClient",
      method: "makeProtocolWorker"
    }), Effect.interruptible, Effect.forkScoped);
    yield* readyLatch.await;
    if (Option.isSome(initialMessage)) {
      const [value, transfers] = yield* initialMessage.value;
      yield* backing.send({
        _tag: "InitialMessage",
        value
      }, transfers);
    }
    return backing;
  });
  const pool = "minSize" in options ? yield* Pool.makeWithTTL({
    acquire,
    min: options.minSize,
    max: options.maxSize,
    concurrency: options.concurrency,
    targetUtilization: options.targetUtilization,
    timeToLive: options.timeToLive
  }) : yield* Pool.make({
    acquire,
    size: options.size,
    concurrency: options.concurrency,
    targetUtilization: options.targetUtilization
  });
  yield* Scope.addFinalizer(scope, Effect.sync(() => {
    for (const entry of entries.values()) {
      entry.latch.unsafeOpen();
    }
    entries.clear();
  }));
  const send = (request, transferables) => {
    switch (request._tag) {
      case "Request":
        {
          return pool.get.pipe(Effect.flatMap(worker => {
            const latch = Effect.unsafeMakeLatch(false);
            entries.set(request.id, {
              worker,
              latch
            });
            return Effect.zipRight(worker.send(request, transferables), latch.await);
          }), Effect.scoped, Effect.orDie);
        }
      case "Interrupt":
        {
          const entry = entries.get(request.requestId);
          if (!entry) return Effect.void;
          entries.delete(request.requestId);
          entry.latch.unsafeOpen();
          return Effect.orDie(entry.worker.send(request));
        }
      case "Ack":
        {
          const entry = entries.get(request.requestId);
          if (!entry) return Effect.void;
          return Effect.orDie(entry.worker.send(request));
        }
    }
    return Effect.void;
  };
  yield* Effect.scoped(pool.get);
  return {
    send,
    supportsAck: true,
    supportsTransferables: true
  };
}));
/**
 * @since 1.0.0
 * @category protocol
 */
export const layerProtocolWorker = options => Layer.scoped(Protocol, makeProtocolWorker(options));
/**
 * @since 1.0.0
 * @category protocol
 */
export const layerProtocolSocket = options => Layer.scoped(Protocol, makeProtocolSocket(options));
// internal
const decodeDefect = /*#__PURE__*/Schema.decodeSync(Schema.Defect);
//# sourceMappingURL=RpcClient.js.map