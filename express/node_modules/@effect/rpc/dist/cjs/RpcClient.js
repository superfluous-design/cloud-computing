"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withHeadersEffect = exports.withHeaders = exports.makeProtocolWorker = exports.makeProtocolSocket = exports.makeProtocolHttp = exports.makeNoSerialization = exports.make = exports.layerProtocolWorker = exports.layerProtocolSocket = exports.layerProtocolHttp = exports.currentHeaders = exports.Protocol = void 0;
var Headers = _interopRequireWildcard(require("@effect/platform/Headers"));
var HttpBody = _interopRequireWildcard(require("@effect/platform/HttpBody"));
var HttpClient = _interopRequireWildcard(require("@effect/platform/HttpClient"));
var HttpClientRequest = _interopRequireWildcard(require("@effect/platform/HttpClientRequest"));
var Socket = _interopRequireWildcard(require("@effect/platform/Socket"));
var Transferable = _interopRequireWildcard(require("@effect/platform/Transferable"));
var Worker = _interopRequireWildcard(require("@effect/platform/Worker"));
var Cause = _interopRequireWildcard(require("effect/Cause"));
var Chunk = _interopRequireWildcard(require("effect/Chunk"));
var Context = _interopRequireWildcard(require("effect/Context"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var Fiber = _interopRequireWildcard(require("effect/Fiber"));
var FiberId = _interopRequireWildcard(require("effect/FiberId"));
var FiberRef = _interopRequireWildcard(require("effect/FiberRef"));
var _Function = require("effect/Function");
var _GlobalValue = require("effect/GlobalValue");
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Mailbox = _interopRequireWildcard(require("effect/Mailbox"));
var Option = _interopRequireWildcard(require("effect/Option"));
var Pool = _interopRequireWildcard(require("effect/Pool"));
var Runtime = _interopRequireWildcard(require("effect/Runtime"));
var Schedule = _interopRequireWildcard(require("effect/Schedule"));
var Schema = _interopRequireWildcard(require("effect/Schema"));
var Scope = _interopRequireWildcard(require("effect/Scope"));
var Stream = _interopRequireWildcard(require("effect/Stream"));
var _utils = require("./internal/utils.js");
var Rpc = _interopRequireWildcard(require("./Rpc.js"));
var _RpcMessage = require("./RpcMessage.js");
var RpcSchema = _interopRequireWildcard(require("./RpcSchema.js"));
var RpcSerialization = _interopRequireWildcard(require("./RpcSerialization.js"));
var RpcWorker = _interopRequireWildcard(require("./RpcWorker.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

let requestIdCounter = /*#__PURE__*/BigInt(0);
/**
 * @since 1.0.0
 * @category client
 */
const makeNoSerialization = exports.makeNoSerialization = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
  const spanPrefix = options?.spanPrefix ?? "RpcClient";
  const supportsAck = options?.supportsAck ?? true;
  const disableTracing = options?.disableTracing ?? false;
  const generateRequestId = options?.generateRequestId ?? (() => requestIdCounter++);
  const context = yield* Effect.context();
  const scope = Context.get(context, Scope.Scope);
  const entries = new Map();
  let isShutdown = false;
  yield* Scope.addFinalizer(scope, Effect.fiberIdWith(fiberId => {
    isShutdown = true;
    return clearEntries(Exit.interrupt(fiberId));
  }));
  const clearEntries = Effect.fnUntraced(function* (exit) {
    for (const [id, entry] of entries) {
      entries.delete(id);
      if (entry._tag === "Mailbox") {
        yield* entry.mailbox.done(exit);
      } else {
        entry.resume(exit);
      }
    }
  });
  const onRequest = rpc => {
    const isStream = RpcSchema.isStreamSchema(rpc.successSchema);
    const middleware = getRpcClientMiddleware(rpc);
    return (payload, options) => {
      const headers = options?.headers ? Headers.fromInput(options.headers) : Headers.empty;
      if (!isStream) {
        const effect = Effect.useSpan(`${spanPrefix}.${rpc._tag}`, {
          captureStackTrace: false
        }, span => onEffectRequest(rpc, middleware, span, "make" in rpc.payloadSchema ? rpc.payloadSchema.make(payload ?? {}) : {}, headers, options?.context ?? Context.empty(), options?.discard ?? false));
        return disableTracing ? Effect.withTracerEnabled(effect, false) : effect;
      }
      const mailbox = Effect.suspend(() => onStreamRequest(rpc, middleware, payload ? rpc.payloadSchema.make(payload) : {}, headers, options?.streamBufferSize ?? 16, options?.context ?? Context.empty()));
      if (options?.asMailbox) return mailbox;
      return Stream.unwrapScoped(Effect.map(mailbox, Mailbox.toStream));
    };
  };
  const onEffectRequest = (rpc, middleware, span, payload, headers, context, discard) => Effect.withFiberRuntime(parentFiber => {
    if (isShutdown) {
      return Effect.interrupt;
    }
    const id = generateRequestId();
    const send = middleware({
      _tag: "Request",
      id,
      tag: rpc._tag,
      payload,
      traceId: span.traceId,
      spanId: span.spanId,
      sampled: span.sampled,
      headers: Headers.merge(parentFiber.getFiberRef(currentHeaders), headers)
    });
    if (discard) {
      return Effect.flatMap(send, message => options.onFromClient({
        message,
        context,
        discard
      }));
    }
    const runtime = Runtime.make({
      context: parentFiber.currentContext,
      fiberRefs: parentFiber.getFiberRefs(),
      runtimeFlags: Runtime.defaultRuntime.runtimeFlags
    });
    let fiber;
    return Effect.onInterrupt(Effect.async(resume => {
      const entry = {
        _tag: "Effect",
        rpc,
        context,
        resume(exit) {
          resume(exit);
          if (fiber && !fiber.unsafePoll()) {
            parentFiber.currentScheduler.scheduleTask(() => {
              fiber.unsafeInterruptAsFork(parentFiber.id());
            }, 0);
          }
        }
      };
      entries.set(id, entry);
      fiber = send.pipe(Effect.flatMap(request => options.onFromClient({
        message: request,
        context,
        discard
      })), Effect.withParentSpan(span), Runtime.runFork(runtime));
      fiber.addObserver(exit => {
        if (exit._tag === "Failure") {
          return resume(exit);
        }
      });
    }), interruptors => {
      entries.delete(id);
      const ids = Array.from(interruptors).flatMap(id => Array.from(FiberId.toSet(id)));
      return Effect.zipRight(Fiber.interrupt(fiber), sendInterrupt(id, ids, context));
    });
  });
  const onStreamRequest = Effect.fnUntraced(function* (rpc, middleware, payload, headers, streamBufferSize, context) {
    if (isShutdown) {
      return yield* Effect.interrupt;
    }
    const span = yield* Effect.makeSpanScoped(`${spanPrefix}.${rpc._tag}`, {
      captureStackTrace: false
    }).pipe(disableTracing ? Effect.withTracerEnabled(false) : _Function.identity);
    const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
    const id = generateRequestId();
    const scope = Context.unsafeGet(fiber.currentContext, Scope.Scope);
    yield* Scope.addFinalizerExit(scope, exit => {
      if (!entries.has(id)) return Effect.void;
      entries.delete(id);
      return sendInterrupt(id, Exit.isFailure(exit) ? Array.from(Cause.interruptors(exit.cause)).flatMap(id => Array.from(FiberId.toSet(id))) : [], context);
    });
    const mailbox = yield* Mailbox.make(streamBufferSize);
    entries.set(id, {
      _tag: "Mailbox",
      rpc,
      mailbox,
      scope,
      context
    });
    yield* middleware({
      _tag: "Request",
      id,
      tag: rpc._tag,
      traceId: span.traceId,
      payload,
      spanId: span.spanId,
      sampled: span.sampled,
      headers: Headers.merge(fiber.getFiberRef(currentHeaders), headers)
    }).pipe(Effect.flatMap(request => options.onFromClient({
      message: request,
      context,
      discard: false
    })), Effect.withParentSpan(span), Effect.catchAllCause(error => mailbox.failCause(error)), Effect.interruptible, Effect.forkIn(scope));
    return mailbox;
  });
  const getRpcClientMiddleware = rpc => {
    const middlewares = [];
    for (const tag of rpc.middlewares.values()) {
      const middleware = context.unsafeMap.get(`${tag.key}/Client`);
      if (!middleware) continue;
      middlewares.push(middleware);
    }
    return middlewares.length === 0 ? Effect.succeed : function (request) {
      let i = 0;
      return Effect.map(Effect.whileLoop({
        while: () => i < middlewares.length,
        body: () => middlewares[i]({
          rpc,
          request
        }),
        step(nextRequest) {
          request = nextRequest;
          i++;
        }
      }), () => request);
    };
  };
  const sendInterrupt = (requestId, interruptors, context) => Effect.async(resume => {
    const parentFiber = Option.getOrThrow(Fiber.getCurrentFiber());
    const runtime = Runtime.make({
      context: parentFiber.currentContext,
      fiberRefs: parentFiber.getFiberRefs(),
      runtimeFlags: Runtime.defaultRuntime.runtimeFlags
    });
    const fiber = options.onFromClient({
      message: {
        _tag: "Interrupt",
        requestId,
        interruptors
      },
      context,
      discard: false
    }).pipe(Effect.timeout(1000), Runtime.runFork(runtime));
    fiber.addObserver(() => {
      resume(Effect.void);
    });
  });
  const write = message => {
    switch (message._tag) {
      case "Chunk":
        {
          const requestId = message.requestId;
          const entry = entries.get(requestId);
          if (!entry || entry._tag !== "Mailbox") return Effect.void;
          return entry.mailbox.offerAll(message.values).pipe(supportsAck ? Effect.zipRight(options.onFromClient({
            message: {
              _tag: "Ack",
              requestId: message.requestId
            },
            context: entry.context,
            discard: false
          })) : _Function.identity, Effect.catchAllCause(cause => entry.mailbox.done(Exit.failCause(cause))));
        }
      case "Exit":
        {
          const requestId = message.requestId;
          const entry = entries.get(requestId);
          if (!entry) return Effect.void;
          entries.delete(requestId);
          if (entry._tag === "Effect") {
            entry.resume(message.exit);
            return Effect.void;
          }
          return entry.mailbox.done(Exit.asVoid(message.exit));
        }
      case "Defect":
        {
          return clearEntries(Exit.die(message.defect));
        }
      case "ClientEnd":
        {
          return Effect.void;
        }
    }
  };
  const client = {};
  for (const rpc of group.requests.values()) {
    ;
    client[rpc._tag] = onRequest(rpc);
  }
  return {
    client: client,
    write
  };
});
/**
 * @since 1.0.0
 * @category client
 */
const make = exports.make = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
  const {
    run,
    send,
    supportsAck,
    supportsTransferables
  } = yield* Protocol;
  const entries = new Map();
  const {
    client,
    write
  } = yield* makeNoSerialization(group, {
    ...options,
    supportsAck,
    onFromClient({
      message
    }) {
      switch (message._tag) {
        case "Request":
          {
            const rpc = group.requests.get(message.tag);
            const schemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast);
            const collector = supportsTransferables ? Transferable.unsafeMakeCollector() : undefined;
            const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
            const entry = {
              rpc,
              context: collector ? Context.add(fiber.currentContext, Transferable.Collector, collector) : fiber.currentContext,
              decodeChunk: Option.isSome(schemas) ? Schema.decodeUnknown(Schema.NonEmptyArray(schemas.value.success)) : undefined
            };
            entries.set(message.id, entry);
            return Schema.encode(rpc.payloadSchema)(message.payload).pipe(Effect.locally(FiberRef.currentContext, entry.context), Effect.orDie, Effect.flatMap(payload => send({
              ...message,
              id: String(message.id),
              payload,
              headers: Object.entries(message.headers)
            }, collector && collector.unsafeClear())));
          }
        case "Ack":
          {
            const entry = entries.get(message.requestId);
            if (!entry) return Effect.void;
            return send({
              _tag: "Ack",
              requestId: String(message.requestId)
            });
          }
        case "Interrupt":
          {
            const entry = entries.get(message.requestId);
            if (!entry) return Effect.void;
            entries.delete(message.requestId);
            return send({
              _tag: "Interrupt",
              requestId: String(message.requestId)
            });
          }
        case "Eof":
          {
            return Effect.void;
          }
      }
    }
  });
  yield* run(message => {
    switch (message._tag) {
      case "Chunk":
        {
          const requestId = (0, _RpcMessage.RequestId)(message.requestId);
          const entry = entries.get(requestId);
          if (!entry || !entry.decodeChunk) return Effect.void;
          return entry.decodeChunk(message.values).pipe(Effect.locally(FiberRef.currentContext, entry.context), Effect.orDie, Effect.flatMap(chunk => write({
            _tag: "Chunk",
            clientId: 0,
            requestId: (0, _RpcMessage.RequestId)(message.requestId),
            values: chunk
          })), Effect.onError(cause => write({
            _tag: "Exit",
            clientId: 0,
            requestId: (0, _RpcMessage.RequestId)(message.requestId),
            exit: Exit.failCause(cause)
          })));
        }
      case "Exit":
        {
          const requestId = (0, _RpcMessage.RequestId)(message.requestId);
          const entry = entries.get(requestId);
          if (!entry) return Effect.void;
          entries.delete(requestId);
          return Schema.decode(Rpc.exitSchema(entry.rpc))(message.exit).pipe(Effect.locally(FiberRef.currentContext, entry.context), Effect.orDie, Effect.matchCauseEffect({
            onSuccess: exit => write({
              _tag: "Exit",
              clientId: 0,
              requestId,
              exit
            }),
            onFailure: cause => write({
              _tag: "Exit",
              clientId: 0,
              requestId,
              exit: Exit.failCause(cause)
            })
          }));
        }
      case "Defect":
        {
          return write({
            _tag: "Defect",
            clientId: 0,
            defect: decodeDefect(message.defect)
          });
        }
      default:
        {
          return Effect.void;
        }
    }
  }).pipe(Effect.catchAllCause(Effect.logError), Effect.interruptible, Effect.forkScoped);
  return client;
});
/**
 * @since 1.0.0
 * @category headers
 */
const currentHeaders = exports.currentHeaders = /*#__PURE__*/(0, _GlobalValue.globalValue)("@effect/rpc/RpcClient/currentHeaders", () => FiberRef.unsafeMake(Headers.empty));
/**
 * @since 1.0.0
 * @category headers
 */
const withHeaders = exports.withHeaders = /*#__PURE__*/(0, _Function.dual)(2, (effect, headers) => Effect.locallyWith(effect, currentHeaders, Headers.merge(Headers.fromInput(headers))));
/**
 * @since 1.0.0
 * @category headers
 */
const withHeadersEffect = exports.withHeadersEffect = /*#__PURE__*/(0, _Function.dual)(2, (effect, headers) => Effect.flatMap(headers, headers => withHeaders(effect, headers)));
/**
 * @since 1.0.0
 * @category protocol
 */
class Protocol extends /*#__PURE__*/Context.Tag("@effect/rpc/RpcClient/Protocol")() {
  /**
   * @since 1.0.0
   */
  static make = /*#__PURE__*/(0, _utils.withRun)();
}
/**
 * @since 1.0.0
 * @category protocol
 */
exports.Protocol = Protocol;
const makeProtocolHttp = client => Protocol.make(Effect.fnUntraced(function* (writeResponse) {
  const serialization = yield* RpcSerialization.RpcSerialization;
  const isJson = serialization.contentType === "application/json";
  const send = request => {
    if (request._tag !== "Request") {
      return Effect.void;
    }
    const parser = serialization.unsafeMake();
    const encoded = parser.encode(request);
    const body = typeof encoded === "string" ? HttpBody.text(encoded, serialization.contentType) : HttpBody.uint8Array(encoded, serialization.contentType);
    if (isJson) {
      return client.post("", {
        body
      }).pipe(Effect.flatMap(r => r.json), Effect.scoped, Effect.flatMap(u => {
        if (!Array.isArray(u)) {
          return Effect.dieMessage(`Expected an array of responses, but got: ${u}`);
        }
        let i = 0;
        return Effect.whileLoop({
          while: () => i < u.length,
          body: () => writeResponse(u[i++]),
          step: _Function.constVoid
        });
      }), Effect.orDie);
    }
    return client.post("", {
      body
    }).pipe(Effect.flatMap(r => Stream.runForEachChunk(r.stream, chunk => {
      const responses = Chunk.toReadonlyArray(chunk).flatMap(parser.decode);
      if (responses.length === 0) return Effect.void;
      let i = 0;
      return Effect.whileLoop({
        while: () => i < responses.length,
        body: () => writeResponse(responses[i++]),
        step: _Function.constVoid
      });
    })), Effect.orDie);
  };
  return {
    send,
    supportsAck: false,
    supportsTransferables: false
  };
}));
/**
 * @since 1.0.0
 * @category protocol
 */
exports.makeProtocolHttp = makeProtocolHttp;
const layerProtocolHttp = options => Layer.scoped(Protocol, Effect.flatMap(HttpClient.HttpClient, client => {
  client = HttpClient.mapRequest(client, HttpClientRequest.prependUrl(options.url));
  return makeProtocolHttp(options.transformClient ? options.transformClient(client) : client);
}));
/**
 * @since 1.0.0
 * @category protocol
 */
exports.layerProtocolHttp = layerProtocolHttp;
const makeProtocolSocket = options => Protocol.make(Effect.fnUntraced(function* (writeResponse) {
  const socket = yield* Socket.Socket;
  const serialization = yield* RpcSerialization.RpcSerialization;
  const write = yield* socket.writer;
  let parser = serialization.unsafeMake();
  yield* Effect.suspend(() => {
    parser = serialization.unsafeMake();
    return socket.runRaw(message => {
      try {
        const responses = parser.decode(message);
        if (responses.length === 0) return;
        let i = 0;
        return Effect.whileLoop({
          while: () => i < responses.length,
          body: () => writeResponse(responses[i++]),
          step: _Function.constVoid
        });
      } catch (defect) {
        return writeResponse({
          _tag: "Defect",
          defect
        });
      }
    });
  }).pipe(Effect.zipRight(Effect.fail(new Socket.SocketCloseError({
    reason: "Close",
    code: 1000
  }))), Effect.tapErrorCause(cause => {
    const error = Cause.failureOption(cause);
    if (options?.retryTransientErrors && Option.isSome(error) && (error.value.reason === "Open" || error.value.reason === "OpenTimeout")) {
      return Effect.void;
    }
    return writeResponse({
      _tag: "Defect",
      defect: Cause.squash(cause)
    });
  }), Effect.retry(Schedule.spaced(1000)), Effect.annotateLogs({
    module: "RpcClient",
    method: "makeProtocolSocket"
  }), Effect.interruptible, Effect.forkScoped);
  yield* Effect.suspend(() => write(parser.encode(_RpcMessage.constPing))).pipe(Effect.delay("30 seconds"), Effect.ignore, Effect.forever, Effect.interruptible, Effect.forkScoped);
  return {
    send(request) {
      return Effect.orDie(write(parser.encode(request)));
    },
    supportsAck: true,
    supportsTransferables: false
  };
}));
/**
 * @since 1.0.0
 * @category protocol
 */
exports.makeProtocolSocket = makeProtocolSocket;
const makeProtocolWorker = options => Protocol.make(Effect.fnUntraced(function* (writeResponse) {
  const worker = yield* Worker.PlatformWorker;
  const scope = yield* Effect.scope;
  let workerId = 0;
  const initialMessage = yield* Effect.serviceOption(RpcWorker.InitialMessage);
  const entries = new Map();
  const acquire = Effect.gen(function* () {
    const id = workerId++;
    const backing = yield* worker.spawn(id);
    const readyLatch = yield* Effect.makeLatch();
    yield* backing.run(message => {
      if (message[0] === 0) {
        return readyLatch.open;
      }
      const response = message[1];
      if (response._tag === "Exit") {
        const entry = entries.get(response.requestId);
        if (entry) {
          entries.delete(response.requestId);
          entry.latch.unsafeOpen();
          return writeResponse(response);
        }
      } else if (response._tag === "Defect") {
        for (const [requestId, entry] of entries) {
          entries.delete(requestId);
          entry.latch.unsafeOpen();
        }
        return writeResponse(response);
      }
      return writeResponse(response);
    }).pipe(Effect.tapErrorCause(cause => writeResponse({
      _tag: "Defect",
      defect: Cause.squash(cause)
    })), Effect.retry(Schedule.spaced(1000)), Effect.annotateLogs({
      module: "RpcClient",
      method: "makeProtocolWorker"
    }), Effect.interruptible, Effect.forkScoped);
    yield* readyLatch.await;
    if (Option.isSome(initialMessage)) {
      const [value, transfers] = yield* initialMessage.value;
      yield* backing.send({
        _tag: "InitialMessage",
        value
      }, transfers);
    }
    return backing;
  });
  const pool = "minSize" in options ? yield* Pool.makeWithTTL({
    acquire,
    min: options.minSize,
    max: options.maxSize,
    concurrency: options.concurrency,
    targetUtilization: options.targetUtilization,
    timeToLive: options.timeToLive
  }) : yield* Pool.make({
    acquire,
    size: options.size,
    concurrency: options.concurrency,
    targetUtilization: options.targetUtilization
  });
  yield* Scope.addFinalizer(scope, Effect.sync(() => {
    for (const entry of entries.values()) {
      entry.latch.unsafeOpen();
    }
    entries.clear();
  }));
  const send = (request, transferables) => {
    switch (request._tag) {
      case "Request":
        {
          return pool.get.pipe(Effect.flatMap(worker => {
            const latch = Effect.unsafeMakeLatch(false);
            entries.set(request.id, {
              worker,
              latch
            });
            return Effect.zipRight(worker.send(request, transferables), latch.await);
          }), Effect.scoped, Effect.orDie);
        }
      case "Interrupt":
        {
          const entry = entries.get(request.requestId);
          if (!entry) return Effect.void;
          entries.delete(request.requestId);
          entry.latch.unsafeOpen();
          return Effect.orDie(entry.worker.send(request));
        }
      case "Ack":
        {
          const entry = entries.get(request.requestId);
          if (!entry) return Effect.void;
          return Effect.orDie(entry.worker.send(request));
        }
    }
    return Effect.void;
  };
  yield* Effect.scoped(pool.get);
  return {
    send,
    supportsAck: true,
    supportsTransferables: true
  };
}));
/**
 * @since 1.0.0
 * @category protocol
 */
exports.makeProtocolWorker = makeProtocolWorker;
const layerProtocolWorker = options => Layer.scoped(Protocol, makeProtocolWorker(options));
/**
 * @since 1.0.0
 * @category protocol
 */
exports.layerProtocolWorker = layerProtocolWorker;
const layerProtocolSocket = options => Layer.scoped(Protocol, makeProtocolSocket(options));
// internal
exports.layerProtocolSocket = layerProtocolSocket;
const decodeDefect = /*#__PURE__*/Schema.decodeSync(Schema.Defect);
//# sourceMappingURL=RpcClient.js.map