"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeTracer = exports.make = exports.layerTracer = exports.layer = exports.Client = void 0;
var Ndjson = _interopRequireWildcard(require("@effect/platform/Ndjson"));
var Socket = _interopRequireWildcard(require("@effect/platform/Socket"));
var Cause = _interopRequireWildcard(require("effect/Cause"));
var Context = _interopRequireWildcard(require("effect/Context"));
var Deferred = _interopRequireWildcard(require("effect/Deferred"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var _Function = require("effect/Function");
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Mailbox = _interopRequireWildcard(require("effect/Mailbox"));
var Metric = _interopRequireWildcard(require("effect/Metric"));
var MetricState = _interopRequireWildcard(require("effect/MetricState"));
var Schedule = _interopRequireWildcard(require("effect/Schedule"));
var Stream = _interopRequireWildcard(require("effect/Stream"));
var Tracer = _interopRequireWildcard(require("effect/Tracer"));
var Domain = _interopRequireWildcard(require("./Domain.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category tags
 */
const Client = exports.Client = /*#__PURE__*/Context.GenericTag("@effect/experimental/DevTools/Client");
/**
 * @since 1.0.0
 * @category constructors
 */
const make = exports.make = /*#__PURE__*/Effect.gen(function* () {
  const socket = yield* Socket.Socket;
  const requests = yield* Mailbox.make();
  function metricsSnapshot() {
    const snapshot = Metric.unsafeSnapshot();
    const metrics = [];
    for (let i = 0, len = snapshot.length; i < len; i++) {
      const metricPair = snapshot[i];
      if (MetricState.isCounterState(metricPair.metricState)) {
        metrics.push({
          _tag: "Counter",
          name: metricPair.metricKey.name,
          description: metricPair.metricKey.description,
          tags: metricPair.metricKey.tags,
          state: metricPair.metricState
        });
      } else if (MetricState.isGaugeState(metricPair.metricState)) {
        metrics.push({
          _tag: "Gauge",
          name: metricPair.metricKey.name,
          description: metricPair.metricKey.description,
          tags: metricPair.metricKey.tags,
          state: metricPair.metricState
        });
      } else if (MetricState.isHistogramState(metricPair.metricState)) {
        metrics.push({
          _tag: "Histogram",
          name: metricPair.metricKey.name,
          description: metricPair.metricKey.description,
          tags: metricPair.metricKey.tags,
          state: metricPair.metricState
        });
      } else if (MetricState.isSummaryState(metricPair.metricState)) {
        metrics.push({
          _tag: "Summary",
          name: metricPair.metricKey.name,
          description: metricPair.metricKey.description,
          tags: metricPair.metricKey.tags,
          state: metricPair.metricState
        });
      } else if (MetricState.isFrequencyState(metricPair.metricState)) {
        metrics.push({
          _tag: "Frequency",
          name: metricPair.metricKey.name,
          description: metricPair.metricKey.description,
          tags: metricPair.metricKey.tags,
          state: {
            occurrences: Object.fromEntries(metricPair.metricState.occurrences.entries())
          }
        });
      }
    }
    return {
      _tag: "MetricsSnapshot",
      metrics
    };
  }
  const connected = yield* Deferred.make();
  yield* Mailbox.toStream(requests).pipe(Stream.pipeThroughChannel(Ndjson.duplexSchemaString(Socket.toChannelString(socket), {
    inputSchema: Domain.Request,
    outputSchema: Domain.Response
  })), Stream.runForEach(req => {
    Deferred.unsafeDone(connected, Exit.void);
    switch (req._tag) {
      case "MetricsRequest":
        {
          return requests.offer(metricsSnapshot());
        }
      case "Pong":
        {
          return Effect.void;
        }
    }
  }), Effect.tapErrorCause(Effect.logDebug), Effect.retry(Schedule.spaced("1 seconds")), Effect.forkScoped, Effect.uninterruptible);
  yield* Effect.addFinalizer(() => requests.offer(metricsSnapshot()).pipe(Effect.zipRight(Effect.fiberIdWith(id => requests.failCause(Cause.interrupt(id))))));
  yield* requests.offer({
    _tag: "Ping"
  }).pipe(Effect.delay("3 seconds"), Effect.forever, Effect.forkScoped, Effect.interruptible);
  yield* Deferred.await(connected).pipe(Effect.timeoutOption("1 second"));
  return Client.of({
    unsafeAddSpan: request => requests.unsafeOffer(request)
  });
}).pipe(/*#__PURE__*/Effect.annotateLogs({
  package: "@effect/experimental",
  module: "DevTools",
  service: "Client"
}));
/**
 * @since 1.0.0
 * @category layers
 */
const layer = exports.layer = /*#__PURE__*/Layer.scoped(Client, make);
/**
 * @since 1.0.0
 * @category constructors
 */
const makeTracer = exports.makeTracer = /*#__PURE__*/Effect.gen(function* () {
  const client = yield* Client;
  const currentTracer = yield* Effect.tracer;
  return Tracer.make({
    span(name, parent, context, links, startTime, kind) {
      const span = currentTracer.span(name, parent, context, links, startTime, kind);
      client.unsafeAddSpan(span);
      const oldEvent = span.event;
      span.event = function (name, startTime, attributes) {
        client.unsafeAddSpan({
          _tag: "SpanEvent",
          traceId: span.traceId,
          spanId: span.spanId,
          name,
          startTime,
          attributes: attributes || {}
        });
        return oldEvent.call(this, name, startTime, attributes);
      };
      const oldEnd = span.end;
      span.end = function () {
        client.unsafeAddSpan(span);
        return oldEnd.apply(this, arguments);
      };
      return span;
    },
    context: currentTracer.context
  });
}).pipe(/*#__PURE__*/Effect.annotateLogs({
  package: "@effect/experimental",
  module: "DevTools",
  service: "Tracer"
}));
/**
 * @since 1.0.0
 * @category layers
 */
const layerTracer = exports.layerTracer = /*#__PURE__*/(0, _Function.pipe)(makeTracer, /*#__PURE__*/Effect.map(Layer.setTracer), Layer.unwrapEffect, /*#__PURE__*/Layer.provide(layer));
//# sourceMappingURL=Client.js.map