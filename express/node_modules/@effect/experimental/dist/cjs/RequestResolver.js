"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.persisted = exports.dataLoader = void 0;
var Arr = _interopRequireWildcard(require("effect/Array"));
var Deferred = _interopRequireWildcard(require("effect/Deferred"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Either = _interopRequireWildcard(require("effect/Either"));
var FiberHandle = _interopRequireWildcard(require("effect/FiberHandle"));
var _Function = require("effect/Function");
var Option = _interopRequireWildcard(require("effect/Option"));
var Request = _interopRequireWildcard(require("effect/Request"));
var RequestResolver = _interopRequireWildcard(require("effect/RequestResolver"));
var Persistence = _interopRequireWildcard(require("./Persistence.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category combinators
 */
const dataLoader = exports.dataLoader = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => Effect.gen(function* () {
  const scope = yield* Effect.scope;
  const handle = yield* FiberHandle.make();
  const maxSize = options.maxBatchSize ?? Infinity;
  let batch = Arr.empty();
  const process = items => Effect.forEach(items, ({
    deferred,
    request
  }) => Effect.request(request, self).pipe(Effect.withRequestCaching(false), Effect.exit, Effect.flatMap(exit => Deferred.done(deferred, exit))), {
    batching: true,
    discard: true
  });
  const loop = Effect.suspend(() => {
    if (batch.length === 0) {
      return Effect.void;
    }
    return Effect.sleep(options.window).pipe(Effect.flatMap(() => {
      const items = batch;
      batch = [];
      return Effect.forkIn(process(items), scope);
    }), Effect.zipRight(loop));
  }).pipe(Effect.interruptible);
  const runLoop = FiberHandle.run(handle, loop, {
    onlyIfMissing: true
  });
  const runLoopReset = FiberHandle.run(handle, loop);
  const run = Effect.suspend(() => {
    if (batch.length > maxSize) {
      const items = batch.splice(0, maxSize);
      return runLoopReset.pipe(Effect.zipRight(process(items)), Effect.interruptible, Effect.forkIn(scope));
    }
    return runLoop;
  }).pipe(Effect.uninterruptible);
  return RequestResolver.fromEffect(request => Effect.flatMap(Deferred.make(), deferred => {
    const item = {
      request,
      deferred
    };
    batch.push(item);
    return run.pipe(Effect.zipRight(Deferred.await(deferred)), Effect.onInterrupt(() => Effect.sync(() => {
      const index = batch.indexOf(item);
      if (index >= 0) {
        batch.splice(index, 1);
      }
    })));
  }));
}));
/**
 * @since 1.0.0
 * @category combinators
 */
const persisted = exports.persisted = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => Effect.gen(function* () {
  const storage = yield* (yield* Persistence.ResultPersistence).make({
    storeId: options.storeId,
    timeToLive: options.timeToLive
  });
  const partition = requests => storage.getMany(requests).pipe(Effect.map(Arr.partitionMap((_, i) => Option.match(_, {
    onNone: () => Either.left(requests[i]),
    onSome: _ => Either.right([requests[i], _])
  }))), Effect.orElseSucceed(() => [requests, []]));
  const set = (request, result) => Effect.ignoreLogged(storage.set(request, result));
  return RequestResolver.makeBatched(requests => Effect.flatMap(partition(requests), ([remaining, results]) => {
    const completeCached = Effect.forEach(results, ([request, result]) => Request.complete(request, result), {
      discard: true
    });
    const completeUncached = (0, _Function.pipe)(Effect.forEach(remaining, request => Effect.exit(Effect.request(request, self)), {
      batching: true
    }), Effect.flatMap(results => Effect.forEach(results, (result, i) => {
      const request = remaining[i];
      return Effect.zipRight(set(request, result), Request.complete(request, result));
    }, {
      discard: true
    })), Effect.withRequestCaching(false));
    return Effect.zipRight(completeCached, completeUncached);
  }));
}));
//# sourceMappingURL=RequestResolver.js.map