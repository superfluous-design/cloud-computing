/**
 * @since 1.0.0
 */
import * as Arr from "effect/Array";
import * as Deferred from "effect/Deferred";
import * as Effect from "effect/Effect";
import * as Either from "effect/Either";
import * as FiberHandle from "effect/FiberHandle";
import { dual, pipe } from "effect/Function";
import * as Option from "effect/Option";
import * as Request from "effect/Request";
import * as RequestResolver from "effect/RequestResolver";
import * as Persistence from "./Persistence.js";
/**
 * @since 1.0.0
 * @category combinators
 */
export const dataLoader = /*#__PURE__*/dual(2, (self, options) => Effect.gen(function* () {
  const scope = yield* Effect.scope;
  const handle = yield* FiberHandle.make();
  const maxSize = options.maxBatchSize ?? Infinity;
  let batch = Arr.empty();
  const process = items => Effect.forEach(items, ({
    deferred,
    request
  }) => Effect.request(request, self).pipe(Effect.withRequestCaching(false), Effect.exit, Effect.flatMap(exit => Deferred.done(deferred, exit))), {
    batching: true,
    discard: true
  });
  const loop = Effect.suspend(() => {
    if (batch.length === 0) {
      return Effect.void;
    }
    return Effect.sleep(options.window).pipe(Effect.flatMap(() => {
      const items = batch;
      batch = [];
      return Effect.forkIn(process(items), scope);
    }), Effect.zipRight(loop));
  }).pipe(Effect.interruptible);
  const runLoop = FiberHandle.run(handle, loop, {
    onlyIfMissing: true
  });
  const runLoopReset = FiberHandle.run(handle, loop);
  const run = Effect.suspend(() => {
    if (batch.length > maxSize) {
      const items = batch.splice(0, maxSize);
      return runLoopReset.pipe(Effect.zipRight(process(items)), Effect.interruptible, Effect.forkIn(scope));
    }
    return runLoop;
  }).pipe(Effect.uninterruptible);
  return RequestResolver.fromEffect(request => Effect.flatMap(Deferred.make(), deferred => {
    const item = {
      request,
      deferred
    };
    batch.push(item);
    return run.pipe(Effect.zipRight(Deferred.await(deferred)), Effect.onInterrupt(() => Effect.sync(() => {
      const index = batch.indexOf(item);
      if (index >= 0) {
        batch.splice(index, 1);
      }
    })));
  }));
}));
/**
 * @since 1.0.0
 * @category combinators
 */
export const persisted = /*#__PURE__*/dual(2, (self, options) => Effect.gen(function* () {
  const storage = yield* (yield* Persistence.ResultPersistence).make({
    storeId: options.storeId,
    timeToLive: options.timeToLive
  });
  const partition = requests => storage.getMany(requests).pipe(Effect.map(Arr.partitionMap((_, i) => Option.match(_, {
    onNone: () => Either.left(requests[i]),
    onSome: _ => Either.right([requests[i], _])
  }))), Effect.orElseSucceed(() => [requests, []]));
  const set = (request, result) => Effect.ignoreLogged(storage.set(request, result));
  return RequestResolver.makeBatched(requests => Effect.flatMap(partition(requests), ([remaining, results]) => {
    const completeCached = Effect.forEach(results, ([request, result]) => Request.complete(request, result), {
      discard: true
    });
    const completeUncached = pipe(Effect.forEach(remaining, request => Effect.exit(Effect.request(request, self)), {
      batching: true
    }), Effect.flatMap(results => Effect.forEach(results, (result, i) => {
      const request = remaining[i];
      return Effect.zipRight(set(request, result), Request.complete(request, result));
    }, {
      discard: true
    })), Effect.withRequestCaching(false));
    return Effect.zipRight(completeCached, completeUncached);
  }));
}));
//# sourceMappingURL=RequestResolver.js.map