/**
 * @since 0.24.0
 */
import { dual } from "effect/Function";
/**
 * Returns a default `map` composition.
 *
 * @since 0.24.0
 */
export const mapComposition = (F, G) => (self, f) => F.map(self, G.map(f));
/**
 * Returns a default `imap` implementation.
 *
 * @since 0.24.0
 */
export const imap = map => dual(3, (self, to, _) => map(self, to));
/**
 * @category mapping
 * @since 0.24.0
 */
export const flap = F => dual(2, (a, self) => F.map(self, f => f(a)));
/**
 * @category mapping
 * @since 0.24.0
 */
export const as = F => dual(2, (self, b) => F.map(self, () => b));
/**
 * @category mapping
 * @since 0.24.0
 */
export const asVoid = F => as(F)(undefined);
const let_ = F => dual(3, (self, name, f) => F.map(self, a => Object.assign({}, a, {
  [name]: f(a)
})));
export {
/**
 * **Example**
 *
 * ```ts
 * import * as covariant from "@effect/typeclass/Covariant"
 * import type { HKT } from "effect"
 * import { dual, pipe } from "effect/Function"
 *
 * interface MyData<A> {
 *   readonly value: A
 * }
 *
 * interface MyDataTypeLambda extends HKT.TypeLambda {
 *   readonly type: MyData<this["Target"]>
 * }
 *
 * const map: covariant.Covariant<MyDataTypeLambda>["map"] = dual(
 *   2,
 *   <A, B>(self: MyData<A>, f: (a: A) => B): MyData<B> => ({ value: f(self.value) })
 * )
 *
 * const Covariant: covariant.Covariant<MyDataTypeLambda> = { imap: covariant.imap<MyDataTypeLambda>(map), map }
 *
 * const notation = {
 *   Do: { value: {} } as MyData<{}>,
 *   let: covariant.let(Covariant)
 * }
 *
 * console.log(pipe(notation.Do, notation.let("foo", () => "bar")))
 * // { value: { foo: "bar" } }
 * ```
 *
 * @category do notation
 * @since 0.24.0
 */
let_ as let };
//# sourceMappingURL=Covariant.js.map