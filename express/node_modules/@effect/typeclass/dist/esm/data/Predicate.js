/**
 * @since 0.24.0
 */
import { constFalse, constTrue } from "effect/Function";
import * as Predicate from "effect/Predicate";
import * as contravariant from "../Contravariant.js";
import * as monoid from "../Monoid.js";
import * as semigroup from "../Semigroup.js";
const contramap = Predicate.mapInput;
const imap = /*#__PURE__*/contravariant.imap(contramap);
const of = _ => Predicate.isUnknown;
const product = (self, that) => ([a, b]) => self(a) && that(b);
const productAll = collection => {
  return as => {
    let collectionIndex = 0;
    for (const p of collection) {
      if (collectionIndex >= as.length) {
        break;
      }
      if (p(as[collectionIndex]) === false) {
        return false;
      }
      collectionIndex++;
    }
    return true;
  };
};
const productMany = (self, collection) => {
  const rest = productAll(collection);
  return ([head, ...tail]) => self(head) === false ? false : rest(tail);
};
/**
 * @category instances
 * @since 0.24.0
 */
export const Contravariant = {
  imap,
  contramap
};
/**
 * @category instances
 * @since 0.24.0
 */
export const Invariant = {
  imap
};
/**
 * @category instances
 * @since 0.24.0
 */
export const Of = {
  of
};
/**
 * @category instances
 * @since 0.24.0
 */
export const SemiProduct = {
  imap,
  product,
  productMany
};
/**
 * @category instances
 * @since 0.24.0
 */
export const Product = {
  of,
  imap,
  product,
  productMany,
  productAll
};
/**
 * @category instances
 * @since 0.24.0
 */
export const getSemigroupEqv = () => semigroup.make(Predicate.eqv);
/**
 * @category instances
 * @since 0.24.0
 */
export const getMonoidEqv = () => monoid.fromSemigroup(getSemigroupEqv(), constTrue);
/**
 * @category instances
 * @since 0.24.0
 */
export const getSemigroupXor = () => semigroup.make(Predicate.xor);
/**
 * @category instances
 * @since 0.24.0
 */
export const getMonoidXor = () => monoid.fromSemigroup(getSemigroupXor(), constFalse);
/**
 * @category instances
 * @since 0.24.0
 */
export const getSemigroupSome = () => semigroup.make(Predicate.or, (self, collection) => a => {
  if (self(a)) {
    return true;
  }
  for (const p of collection) {
    if (p(a)) {
      return true;
    }
  }
  return false;
});
/**
 * @category instances
 * @since 0.24.0
 */
export const getMonoidSome = () => monoid.fromSemigroup(getSemigroupSome(), constFalse);
/**
 * @category instances
 * @since 0.24.0
 */
export const getSemigroupEvery = () => semigroup.make(Predicate.and, (self, collection) => a => {
  if (!self(a)) {
    return false;
  }
  for (const p of collection) {
    if (!p(a)) {
      return false;
    }
  }
  return true;
});
/**
 * @category instances
 * @since 0.24.0
 */
export const getMonoidEvery = () => monoid.fromSemigroup(getSemigroupEvery(), constTrue);
//# sourceMappingURL=Predicate.js.map