import { dual } from "effect/Function";
import * as Record from "effect/Record";
import * as covariant from "../Covariant.js";
import * as monoid from "../Monoid.js";
import * as semigroup from "../Semigroup.js";
/** @internal */
export const traverse = F => dual(2, (self, f) => F.map(F.productAll(Object.entries(self).map(([key, a]) => F.map(f(a, key), b => [key, b]))), Object.fromEntries));
const traversePartitionMap = F => dual(2, (self, f) => {
  return F.map(traverse(F)(self, f), Record.separate);
});
const traverseFilterMap = F => dual(2, (self, f) => {
  return F.map(traverse(F)(self, f), Record.getSomes);
});
const _map = Record.map;
const _imap = /*#__PURE__*/covariant.imap(_map);
const _partitionMap = Record.partitionMap;
const _filterMap = Record.filterMap;
const _traverse = traverse;
const _traversePartitionMap = traversePartitionMap;
const _traverseFilterMap = traverseFilterMap;
/**
 * @category instances
 * @since 0.24.0
 */
export const getCovariant = () => ({
  imap: _imap,
  map: _map
});
/**
 * @category instances
 * @since 0.24.0
 */
export const Covariant = /*#__PURE__*/getCovariant();
/**
 * @category instances
 * @since 0.24.0
 */
export const getInvariant = () => ({
  imap: _imap
});
/**
 * @category instances
 * @since 0.24.0
 */
export const Invariant = /*#__PURE__*/getInvariant();
/**
 * @category instances
 * @since 0.24.0
 */
export const getFilterable = () => ({
  partitionMap: _partitionMap,
  filterMap: _filterMap
});
/**
 * @category instances
 * @since 0.24.0
 */
export const Filterable = /*#__PURE__*/getFilterable();
/**
 * @category instances
 * @since 0.24.0
 */
export const getTraversable = () => ({
  traverse: _traverse
});
/**
 * @category instances
 * @since 0.24.0
 */
export const Traversable = /*#__PURE__*/getTraversable();
/**
 * @category instances
 * @since 0.24.0
 */
export const getTraversableFilterable = () => ({
  traversePartitionMap: _traversePartitionMap,
  traverseFilterMap: _traverseFilterMap
});
/**
 * @category instances
 * @since 0.24.0
 */
export const TraversableFilterable = /*#__PURE__*/getTraversableFilterable();
/**
 * A `Semigroup` that creates a union of two records.
 *
 * This `Semigroup` takes two records and combines them into a single record.
 * If a key exists in both records, the provided `Semigroup` instance is used to combine the values for that key.
 * If a key exists in only one of the records, that key-value pair is included as is in the resulting record.
 *
 * For example, when using the `MonoidSum`, values for matching keys will be summed.
 *
 * **Example**
 *
 * ```ts
 * import * as NumberInstances from "@effect/typeclass/data/Number"
 * import { getSemigroupUnion } from "@effect/typeclass/data/Record"
 *
 * console.log(getSemigroupUnion(NumberInstances.MonoidSum).combine({ a: 1 }, { a: 1, b: 3 }))
 * // { a: 2, b: 3 }
 * ```
 *
 * @category instances
 * @since 0.29.4
 */
export const getSemigroupUnion = value => semigroup.make((self, that) => Record.union(self, that, value.combine));
/**
 * A `Monoid` that creates a union of two records.
 *
 * It allows combining two records where values for matching keys are combined using the provided `Monoid` instance.
 * If a key exists in only one of the records, that key-value pair is included as is in the resulting record.
 *
 * The `empty` value for this `Monoid` is an empty record `{}`.
 *
 * **Example**
 *
 * ```ts
 * import * as NumberInstances from "@effect/typeclass/data/Number"
 * import { getMonoidUnion } from "@effect/typeclass/data/Record"
 *
 * const monoid = getMonoidUnion(NumberInstances.MonoidSum)
 *
 * console.log(monoid.combine({ a: 1 }, { a: 1, b: 3 }))
 * // { a: 2, b: 3 }
 *
 * console.log(monoid.combine({ a: 1 }, monoid.empty))
 * // { a: 1 }
 * ```
 *
 * @category instances
 * @since 0.29.4
 */
export const getMonoidUnion = value => monoid.fromSemigroup(getSemigroupUnion(value), Record.empty());
/**
 * A `Semigroup` that creates an intersection of two records.
 *
 * This `Semigroup` takes two records and combines them into a new record containing only the keys that are present in both records.
 * The values for matching keys are combined using the provided `Semigroup` instance.
 *
 * **Example**
 *
 * ```ts
 * import * as NumberInstances from "@effect/typeclass/data/Number"
 * import { getSemigroupIntersection } from "@effect/typeclass/data/Record"
 *
 * console.log(getSemigroupIntersection(NumberInstances.MonoidSum).combine({ a: 1 }, { a: 1, b: 3 }))
 * // { a: 2 }
 * ```
 *
 * @category instances
 * @since 0.29.4
 */
export const getSemigroupIntersection = value => semigroup.make((self, that) => Record.intersection(self, that, value.combine));
//# sourceMappingURL=Record.js.map