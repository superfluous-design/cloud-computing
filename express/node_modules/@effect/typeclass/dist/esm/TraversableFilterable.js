import * as E from "effect/Either";
import { dual } from "effect/Function";
import * as O from "effect/Option";
import * as filterable from "./Filterable.js";
/**
 * Returns a default binary `traversePartitionMap` implementation.
 *
 * @since 0.24.0
 */
export const traversePartitionMap = T => F => (self, f) => F.map(T.traverse(F)(self, f), filterable.separate(T));
/**
 * Returns a default binary `traverseFilterMap` implementation.
 *
 * @since 0.24.0
 */
export const traverseFilterMap = T => F => (self, f) => F.map(T.traverse(F)(self, f), filterable.compact(T));
/**
 * @since 0.24.0
 */
export const traverseFilter = T => F => dual(2, (self, predicate) => T.traverseFilterMap(F)(self, b => F.map(predicate(b), keep => keep ? O.some(b) : O.none())));
/**
 * @since 0.24.0
 */
export const traversePartition = T => F => dual(2, (self, predicate) => T.traversePartitionMap(F)(self, b => F.map(predicate(b), keep => keep ? E.right(b) : E.left(b))));
//# sourceMappingURL=TraversableFilterable.js.map