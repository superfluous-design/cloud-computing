/**
 * @since 0.24.0
 */
import { dual, identity, SK } from "effect/Function";
import * as semigroup from "./Semigroup.js";
/**
 * Lift a `Semigroup` into 'F', the inner values are combined using the provided `Semigroup`.
 *
 * @category lifting
 * @since 0.24.0
 */
export const getSemigroup = F => S => semigroup.make((self, that) => F.map(F.product(self, that), ([a1, a2]) => S.combine(a1, a2)), (self, collection) => F.map(F.productMany(self, collection), ([head, ...tail]) => S.combineMany(head, tail)));
/**
 * Zips two `F` values together using a provided function, returning a new `F` of the result.
 *
 * @since 0.24.0
 */
export const zipWith = F => dual(3, (self, that, f) => F.map(F.product(self, that), ([a, b]) => f(a, b)));
/**
 * @since 0.24.0
 */
export const ap = F => dual(2, (self, that) => zipWith(F)(self, that, (f, a) => f(a)));
/**
 * @since 0.24.0
 */
export const zipLeft = F => dual(2, (self, that) => zipWith(F)(self, that, identity));
/**
 * @since 0.24.0
 */
export const zipRight = F => dual(2, (self, that) => zipWith(F)(self, that, SK));
/**
 * Lifts a binary function into `F`.
 *
 * @category lifting
 * @since 0.24.0
 */
export const lift2 = F => f => dual(2, (self, that) => zipWith(F)(self, that, f));
//# sourceMappingURL=SemiApplicative.js.map