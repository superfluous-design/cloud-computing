/**
 * `Filterable` represents data structures which can be _partitioned_/_filtered_.
 *
 * @since 0.24.0
 */
import * as Either from "effect/Either";
import { dual, identity } from "effect/Function";
import * as Option from "effect/Option";
/**
 * Returns a default binary `partitionMap` composition.
 *
 * @since 0.24.0
 */
export const partitionMapComposition = (F, G) => (self, f) => {
  const filterMap = filterMapComposition(F, G);
  return [filterMap(self, a => Either.getLeft(f(a))), filterMap(self, a => Either.getRight(f(a)))];
};
/**
 * Returns a default binary `filterMap` composition.
 *
 * @since 0.24.0
 */
export const filterMapComposition = (F, G) => (self, f) => F.map(self, G.filterMap(f));
/**
 * @since 0.24.0
 */
export const compact = F => F.filterMap(identity);
/**
 * @since 0.24.0
 */
export const separate = F => F.partitionMap(identity);
/**
 * @since 0.24.0
 */
export const filter = Filterable => dual(2, (self, predicate) => Filterable.filterMap(self, b => predicate(b) ? Option.some(b) : Option.none()));
/**
 * @since 0.24.0
 */
export const partition = F => dual(2, (self, predicate) => F.partitionMap(self, b => predicate(b) ? Either.right(b) : Either.left(b)));
//# sourceMappingURL=Filterable.js.map