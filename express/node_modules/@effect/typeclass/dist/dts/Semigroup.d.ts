import type { TypeLambda } from "effect/HKT";
import type { Order } from "effect/Order";
import type * as invariant from "./Invariant.js";
import * as product_ from "./Product.js";
import type * as semiProduct from "./SemiProduct.js";
/**
 * @category type class
 * @since 0.24.0
 */
export interface Semigroup<A> {
    readonly combine: (self: A, that: A) => A;
    readonly combineMany: (self: A, collection: Iterable<A>) => A;
}
/**
 * @category type lambdas
 * @since 0.24.0
 */
export interface SemigroupTypeLambda extends TypeLambda {
    readonly type: Semigroup<this["Target"]>;
}
/**
 * The `combineMany` parameter is optional and defaults to a standard
 * implementation. You can provide a custom implementation when performance
 * optimizations are possible.
 *
 * @category constructors
 * @since 0.24.0
 */
export declare const make: <A>(combine: Semigroup<A>["combine"], combineMany?: Semigroup<A>["combineMany"]) => Semigroup<A>;
/**
 * `Semigroup` that returns last minimum of elements.
 *
 * @category constructors
 * @since 0.24.0
 */
export declare const min: <A>(O: Order<A>) => Semigroup<A>;
/**
 * `Semigroup` that returns last maximum of elements.
 *
 * @category constructors
 * @since 0.24.0
 */
export declare const max: <A>(O: Order<A>) => Semigroup<A>;
/**
 * @category constructors
 * @since 0.24.0
 */
export declare const constant: <A>(a: A) => Semigroup<A>;
/**
 * The dual of a `Semigroup`, obtained by flipping the arguments of `combine`.
 *
 * @since 0.24.0
 */
export declare const reverse: <A>(S: Semigroup<A>) => Semigroup<A>;
/**
 * The `intercalate` API returns a function that takes a `Semigroup` instance and a separator value, and returns a new
 * `Semigroup` instance that combines values with the given separator.
 *
 * This API is useful when you want to combine values with a specific separator. For example, when you want to concatenate
 * an array of strings with a separator string in between.
 *
 * It is interesting to note that there is no equivalent API in the `Monoid` module. This is because the value `empty`,
 * which is required for the `Monoid` interface, cannot exist.
 *
 * @since 0.24.0
 */
export declare const intercalate: {
    /**
     * The `intercalate` API returns a function that takes a `Semigroup` instance and a separator value, and returns a new
     * `Semigroup` instance that combines values with the given separator.
     *
     * This API is useful when you want to combine values with a specific separator. For example, when you want to concatenate
     * an array of strings with a separator string in between.
     *
     * It is interesting to note that there is no equivalent API in the `Monoid` module. This is because the value `empty`,
     * which is required for the `Monoid` interface, cannot exist.
     *
     * @since 0.24.0
     */
    <A>(separator: A): (S: Semigroup<A>) => Semigroup<A>;
    /**
     * The `intercalate` API returns a function that takes a `Semigroup` instance and a separator value, and returns a new
     * `Semigroup` instance that combines values with the given separator.
     *
     * This API is useful when you want to combine values with a specific separator. For example, when you want to concatenate
     * an array of strings with a separator string in between.
     *
     * It is interesting to note that there is no equivalent API in the `Monoid` module. This is because the value `empty`,
     * which is required for the `Monoid` interface, cannot exist.
     *
     * @since 0.24.0
     */
    <A>(S: Semigroup<A>, separator: A): Semigroup<A>;
};
/**
 * Always return the first argument.
 *
 * @category instances
 * @since 0.24.0
 */
export declare const first: <A = never>() => Semigroup<A>;
/**
 * Always return the last argument.
 *
 * @category instances
 * @since 0.24.0
 */
export declare const last: <A = never>() => Semigroup<A>;
/**
 * @since 0.24.0
 */
export declare const imap: {
    /**
     * @since 0.24.0
     */
    <A, B>(to: (a: A) => B, from: (b: B) => A): (self: Semigroup<A>) => Semigroup<B>;
    /**
     * @since 0.24.0
     */
    <A, B>(self: Semigroup<A>, to: (a: A) => B, from: (b: B) => A): Semigroup<B>;
};
/**
 * @category instances
 * @since 0.24.0
 */
export declare const Invariant: invariant.Invariant<SemigroupTypeLambda>;
/**
 * @category instances
 * @since 0.24.0
 */
export declare const SemiProduct: semiProduct.SemiProduct<SemigroupTypeLambda>;
/**
 * @category instances
 * @since 0.24.0
 */
export declare const Product: product_.Product<SemigroupTypeLambda>;
/**
 * Similar to `Promise.all` but operates on `Semigroup`s.
 *
 * ```
 * [Semigroup<A>, Semigroup<B>, ...] -> Semigroup<[A, B, ...]>
 * ```
 *
 * This function creates and returns a new `Semigroup` for a tuple of values based on the given `Semigroup`s for each element in the tuple.
 * The returned `Semigroup` combines two tuples of the same type by applying the corresponding `Semigroup` passed as arguments to each element in the tuple.
 *
 * It is useful when you need to combine two tuples of the same type and you have a specific way of combining each element of the tuple.
 *
 * @category combinators
 * @since 0.24.0
 */
export declare const tuple: <T extends ReadonlyArray<Semigroup<any>>>(...elements: T) => Semigroup<{
    readonly [I in keyof T]: [T[I]] extends [Semigroup<infer A>] ? A : never;
}>;
/**
 * Given a type `A`, this function creates and returns a `Semigroup` for `ReadonlyArray<A>`.
 * The returned `Semigroup` combines two arrays by concatenating them.
 *
 * @category combinators
 * @since 0.24.0
 */
export declare const array: <A>() => Semigroup<ReadonlyArray<A>>;
/**
 * This function creates and returns a new `Semigroup` for a struct of values based on the given `Semigroup`s for each property in the struct.
 * The returned `Semigroup` combines two structs of the same type by applying the corresponding `Semigroup` passed as arguments to each property in the struct.
 *
 * It is useful when you need to combine two structs of the same type and you have a specific way of combining each property of the struct.
 *
 * @category combinators
 * @since 0.24.0
 */
export declare const struct: <R extends {
    readonly [x: string]: Semigroup<any>;
}>(fields: R) => Semigroup<{
    readonly [K in keyof R]: [R[K]] extends [Semigroup<infer A>] ? A : never;
}>;
//# sourceMappingURL=Semigroup.d.ts.map