import * as Record from "effect/Record";
import * as covariant from "../Covariant.js";
import type * as filterable from "../Filterable.js";
import type * as invariant from "../Invariant.js";
import * as monoid from "../Monoid.js";
import * as semigroup from "../Semigroup.js";
import type * as traversable from "../Traversable.js";
import type * as traversableFilterable from "../TraversableFilterable.js";
/**
 * @category instances
 * @since 0.24.0
 */
export declare const getCovariant: <K extends string>() => covariant.Covariant<Record.ReadonlyRecordTypeLambda<K>>;
/**
 * @category instances
 * @since 0.24.0
 */
export declare const Covariant: covariant.Covariant<Record.ReadonlyRecordTypeLambda<string>>;
/**
 * @category instances
 * @since 0.24.0
 */
export declare const getInvariant: <K extends string>() => invariant.Invariant<Record.ReadonlyRecordTypeLambda<K>>;
/**
 * @category instances
 * @since 0.24.0
 */
export declare const Invariant: invariant.Invariant<Record.ReadonlyRecordTypeLambda<string>>;
/**
 * @category instances
 * @since 0.24.0
 */
export declare const getFilterable: <K extends string>() => filterable.Filterable<Record.ReadonlyRecordTypeLambda<K>>;
/**
 * @category instances
 * @since 0.24.0
 */
export declare const Filterable: filterable.Filterable<Record.ReadonlyRecordTypeLambda<string>>;
/**
 * @category instances
 * @since 0.24.0
 */
export declare const getTraversable: <K extends string>() => traversable.Traversable<Record.ReadonlyRecordTypeLambda<K>>;
/**
 * @category instances
 * @since 0.24.0
 */
export declare const Traversable: traversable.Traversable<Record.ReadonlyRecordTypeLambda<string>>;
/**
 * @category instances
 * @since 0.24.0
 */
export declare const getTraversableFilterable: <K extends string>() => traversableFilterable.TraversableFilterable<Record.ReadonlyRecordTypeLambda<K>>;
/**
 * @category instances
 * @since 0.24.0
 */
export declare const TraversableFilterable: traversableFilterable.TraversableFilterable<Record.ReadonlyRecordTypeLambda<string>>;
/**
 * A `Semigroup` that creates a union of two records.
 *
 * This `Semigroup` takes two records and combines them into a single record.
 * If a key exists in both records, the provided `Semigroup` instance is used to combine the values for that key.
 * If a key exists in only one of the records, that key-value pair is included as is in the resulting record.
 *
 * For example, when using the `MonoidSum`, values for matching keys will be summed.
 *
 * **Example**
 *
 * ```ts
 * import * as NumberInstances from "@effect/typeclass/data/Number"
 * import { getSemigroupUnion } from "@effect/typeclass/data/Record"
 *
 * console.log(getSemigroupUnion(NumberInstances.MonoidSum).combine({ a: 1 }, { a: 1, b: 3 }))
 * // { a: 2, b: 3 }
 * ```
 *
 * @category instances
 * @since 0.29.4
 */
export declare const getSemigroupUnion: <A>(value: semigroup.Semigroup<A>) => semigroup.Semigroup<Record.ReadonlyRecord<string, A>>;
/**
 * A `Monoid` that creates a union of two records.
 *
 * It allows combining two records where values for matching keys are combined using the provided `Monoid` instance.
 * If a key exists in only one of the records, that key-value pair is included as is in the resulting record.
 *
 * The `empty` value for this `Monoid` is an empty record `{}`.
 *
 * **Example**
 *
 * ```ts
 * import * as NumberInstances from "@effect/typeclass/data/Number"
 * import { getMonoidUnion } from "@effect/typeclass/data/Record"
 *
 * const monoid = getMonoidUnion(NumberInstances.MonoidSum)
 *
 * console.log(monoid.combine({ a: 1 }, { a: 1, b: 3 }))
 * // { a: 2, b: 3 }
 *
 * console.log(monoid.combine({ a: 1 }, monoid.empty))
 * // { a: 1 }
 * ```
 *
 * @category instances
 * @since 0.29.4
 */
export declare const getMonoidUnion: <A>(value: monoid.Monoid<A>) => monoid.Monoid<Record.ReadonlyRecord<string, A>>;
/**
 * A `Semigroup` that creates an intersection of two records.
 *
 * This `Semigroup` takes two records and combines them into a new record containing only the keys that are present in both records.
 * The values for matching keys are combined using the provided `Semigroup` instance.
 *
 * **Example**
 *
 * ```ts
 * import * as NumberInstances from "@effect/typeclass/data/Number"
 * import { getSemigroupIntersection } from "@effect/typeclass/data/Record"
 *
 * console.log(getSemigroupIntersection(NumberInstances.MonoidSum).combine({ a: 1 }, { a: 1, b: 3 }))
 * // { a: 2 }
 * ```
 *
 * @category instances
 * @since 0.29.4
 */
export declare const getSemigroupIntersection: <A>(value: semigroup.Semigroup<A>) => semigroup.Semigroup<Record.ReadonlyRecord<string, A>>;
//# sourceMappingURL=Record.d.ts.map