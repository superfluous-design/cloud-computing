import type { Kind, TypeLambda } from "effect/HKT";
import type { Invariant } from "./Invariant.js";
/**
 * @category type class
 * @since 0.24.0
 */
export interface Covariant<F extends TypeLambda> extends Invariant<F> {
    readonly map: {
        <A, B>(f: (a: A) => B): <R, O, E>(self: Kind<F, R, O, E, A>) => Kind<F, R, O, E, B>;
        <R, O, E, A, B>(self: Kind<F, R, O, E, A>, f: (a: A) => B): Kind<F, R, O, E, B>;
    };
}
/**
 * Returns a default `map` composition.
 *
 * @since 0.24.0
 */
export declare const mapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Covariant<F>, G: Covariant<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, f: (a: A) => B) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>;
/**
 * Returns a default `imap` implementation.
 *
 * @since 0.24.0
 */
export declare const imap: <F extends TypeLambda>(map: <R, O, E, A, B>(self: Kind<F, R, O, E, A>, f: (a: A) => B) => Kind<F, R, O, E, B>) => Invariant<F>["imap"];
/**
 * @category mapping
 * @since 0.24.0
 */
export declare const flap: <F extends TypeLambda>(F: Covariant<F>) => {
    <R, O, E, A, B>(self: Kind<F, R, O, E, (a: A) => B>): (a: A) => Kind<F, R, O, E, B>;
    <A_1, R, O_1, E_1, B_1>(a: A_1, self: Kind<F, R, O_1, E_1, (a: A_1) => B_1>): Kind<F, R, O_1, E_1, B_1>;
};
/**
 * @category mapping
 * @since 0.24.0
 */
export declare const as: <F extends TypeLambda>(F: Covariant<F>) => {
    <B>(b: B): <R, O, E, _>(self: Kind<F, R, O, E, _>) => Kind<F, R, O, E, B>;
    <R, O_1, E_1, __1, B>(self: Kind<F, R, O_1, E_1, __1>, b: B): Kind<F, R, O_1, E_1, B>;
};
/**
 * @category mapping
 * @since 0.24.0
 */
export declare const asVoid: <F extends TypeLambda>(F: Covariant<F>) => <R, O, E, _>(self: Kind<F, R, O, E, _>) => Kind<F, R, O, E, void>;
declare const let_: <F extends TypeLambda>(F: Covariant<F>) => {
    <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: A) => B): <R, O, E>(self: Kind<F, R, O, E, A>) => Kind<F, R, O, E, { [K in keyof A | N]: K extends keyof A ? A[K] : B; }>;
    <R, O_1, E_1, A_1 extends object, N extends string, B_1>(self: Kind<F, R, O_1, E_1, A_1>, name: Exclude<N, keyof A_1>, f: (a: A_1) => B_1): Kind<F, R, O_1, E_1, { [K in keyof A_1 | N]: K extends keyof A_1 ? A_1[K] : B_1; }>;
};
export { 
/**
 * **Example**
 *
 * ```ts
 * import * as covariant from "@effect/typeclass/Covariant"
 * import type { HKT } from "effect"
 * import { dual, pipe } from "effect/Function"
 *
 * interface MyData<A> {
 *   readonly value: A
 * }
 *
 * interface MyDataTypeLambda extends HKT.TypeLambda {
 *   readonly type: MyData<this["Target"]>
 * }
 *
 * const map: covariant.Covariant<MyDataTypeLambda>["map"] = dual(
 *   2,
 *   <A, B>(self: MyData<A>, f: (a: A) => B): MyData<B> => ({ value: f(self.value) })
 * )
 *
 * const Covariant: covariant.Covariant<MyDataTypeLambda> = { imap: covariant.imap<MyDataTypeLambda>(map), map }
 *
 * const notation = {
 *   Do: { value: {} } as MyData<{}>,
 *   let: covariant.let(Covariant)
 * }
 *
 * console.log(pipe(notation.Do, notation.let("foo", () => "bar")))
 * // { value: { foo: "bar" } }
 * ```
 *
 * @category do notation
 * @since 0.24.0
 */
let_ as let };
//# sourceMappingURL=Covariant.d.ts.map