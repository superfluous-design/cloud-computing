/**
 * `Filterable` represents data structures which can be _partitioned_/_filtered_.
 *
 * @since 0.24.0
 */
import * as Either from "effect/Either";
import type { Kind, TypeClass, TypeLambda } from "effect/HKT";
import * as Option from "effect/Option";
import type { Covariant } from "./Covariant.js";
/**
 * @category models
 * @since 0.24.0
 */
export interface Filterable<F extends TypeLambda> extends TypeClass<F> {
    readonly partitionMap: {
        <A, B, C>(f: (a: A) => Either.Either<C, B>): <R, O, E>(self: Kind<F, R, O, E, A>) => [Kind<F, R, O, E, B>, Kind<F, R, O, E, C>];
        <R, O, E, A, B, C>(self: Kind<F, R, O, E, A>, f: (a: A) => Either.Either<C, B>): [Kind<F, R, O, E, B>, Kind<F, R, O, E, C>];
    };
    readonly filterMap: {
        <A, B>(f: (a: A) => Option.Option<B>): <R, O, E>(self: Kind<F, R, O, E, A>) => Kind<F, R, O, E, B>;
        <R, O, E, A, B>(self: Kind<F, R, O, E, A>, f: (a: A) => Option.Option<B>): Kind<F, R, O, E, B>;
    };
}
/**
 * Returns a default binary `partitionMap` composition.
 *
 * @since 0.24.0
 */
export declare const partitionMapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Covariant<F>, G: Filterable<G>) => <FR, FO, FE, GR, GO, GE, A, B, C>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, f: (a: A) => Either.Either<C, B>) => [Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>, Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, C>>];
/**
 * Returns a default binary `filterMap` composition.
 *
 * @since 0.24.0
 */
export declare const filterMapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Covariant<F>, G: Filterable<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, f: (a: A) => Option.Option<B>) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>;
/**
 * @since 0.24.0
 */
export declare const compact: <F extends TypeLambda>(F: Filterable<F>) => <R, O, E, A>(self: Kind<F, R, O, E, Option.Option<A>>) => Kind<F, R, O, E, A>;
/**
 * @since 0.24.0
 */
export declare const separate: <F extends TypeLambda>(F: Filterable<F>) => <R, O, E, A, B>(self: Kind<F, R, O, E, Either.Either<B, A>>) => [Kind<F, R, O, E, A>, Kind<F, R, O, E, B>];
/**
 * @since 0.24.0
 */
export declare const filter: <F extends TypeLambda>(F: Filterable<F>) => {
    <C extends A, B extends A, A = C>(refinement: (a: A) => a is B): <R, O, E>(self: Kind<F, R, O, E, C>) => Kind<F, R, O, E, B>;
    <B extends A, A = B>(predicate: (a: A) => boolean): <R, O, E>(self: Kind<F, R, O, E, B>) => Kind<F, R, O, E, B>;
    <R, O, E, C extends A, B extends A, A = C>(self: Kind<F, R, O, E, C>, refinement: (a: A) => a is B): Kind<F, R, O, E, B>;
    <R, O, E, B extends A, A = B>(self: Kind<F, R, O, E, B>, predicate: (a: A) => boolean): Kind<F, R, O, E, B>;
};
/**
 * @since 0.24.0
 */
export declare const partition: <F extends TypeLambda>(F: Filterable<F>) => {
    <C extends A, B extends A, A = C>(refinement: (a: A) => a is B): <R, O, E>(self: Kind<F, R, O, E, C>) => [Kind<F, R, O, E, C>, Kind<F, R, O, E, B>];
    <B_1 extends A_1, A_1 = B_1>(predicate: (a: A_1) => boolean): <R, O_1, E_1>(self: Kind<F, R, O_1, E_1, B_1>) => [Kind<F, R, O_1, E_1, B_1>, Kind<F, R, O_1, E_1, B_1>];
    <R, O_2, E_2, C extends A_2, B_1 extends A_2, A_2 = C>(self: Kind<F, R, O_2, E_2, C>, refinement: (a: A_2) => a is B_1): [Kind<F, R, O_2, E_2, C>, Kind<F, R, O_2, E_2, B_1>];
    <R, O_3, E_3, B_2 extends A_3, A_3 = B_2>(self: Kind<F, R, O_3, E_3, B_2>, predicate: (a: A_3) => boolean): [Kind<F, R, O_3, E_3, B_2>, Kind<F, R, O_3, E_3, B_2>];
};
//# sourceMappingURL=Filterable.d.ts.map