import type { Kind, TypeLambda } from "effect/HKT";
import type { NoInfer } from "effect/Types";
import type { Covariant } from "./Covariant.js";
import type { FlatMap } from "./FlatMap.js";
/**
 * @category type class
 * @since 0.24.0
 */
export interface Chainable<F extends TypeLambda> extends FlatMap<F>, Covariant<F> {
}
/**
 * Sequences the specified effect after this effect, but ignores the value
 * produced by the effect.
 *
 * @category combining
 * @since 0.24.0
 */
export declare const zipLeft: <F extends TypeLambda>(F: Chainable<F>) => {
    <R2, O2, E2, _>(that: Kind<F, R2, O2, E2, _>): <R1, O1, E1, A>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, A>;
    <R1, O1_1, E1_1, A_1, R2, O2_1, E2_1, __1>(self: Kind<F, R1, O1_1, E1_1, A_1>, that: Kind<F, R2, O2_1, E2_1, __1>): Kind<F, R1 & R2, O1_1 | O2_1, E1_1 | E2_1, A_1>;
};
/**
 * Returns an effect that effectfully "peeks" at the success of this effect.
 *
 * @since 0.24.0
 */
export declare const tap: <F extends TypeLambda>(F: Chainable<F>) => {
    <A, R2, O2, E2, _>(f: (a: A) => Kind<F, R2, O2, E2, _>): <R1, O1, E1>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, A>;
    <R1, O1_1, E1_1, A, R2_1, O2_1, E2_1, __1>(self: Kind<F, R1, O1_1, E1_1, A>, f: (a: A) => Kind<F, R2_1, O2_1, E2_1, __1>): Kind<F, R1 & R2_1, O1_1 | O2_1, E1_1 | E2_1, A>;
};
/**
 * @category do notation
 * @since 0.24.0
 */
export declare const bind: <F extends TypeLambda>(F: Chainable<F>) => {
    <N extends string, A extends object, R2, O2, E2, B>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Kind<F, R2, O2, E2, B>): <R1, O1, E1>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O1 | O2, E1 | E2, { [K in keyof A | N]: K extends keyof A ? A[K] : B; }>;
    <R1, O1_1, E1_1, A_1 extends object, N extends string, R2_1, O2_1, E2_1, B_1>(self: Kind<F, R1, O1_1, E1_1, A_1>, name: Exclude<N, keyof A_1>, f: (a: NoInfer<A_1>) => Kind<F, R2_1, O2_1, E2_1, B_1>): Kind<F, R1 & R2_1, O1_1 | O2_1, E1_1 | E2_1, { [K in keyof A_1 | N]: K extends keyof A_1 ? A_1[K] : B_1; }>;
};
//# sourceMappingURL=Chainable.d.ts.map