"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reverse = exports.min = exports.max = exports.clamp = exports.between = void 0;
var order = _interopRequireWildcard(require("effect/Order"));
var monoid = _interopRequireWildcard(require("./Monoid.js"));
var semigroup = _interopRequireWildcard(require("./Semigroup.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * `Monoid` that returns last minimum of elements.
 *
 * @category constructors
 * @since 0.24.0
 */
const min = B => monoid.fromSemigroup(semigroup.min(B.compare), B.maxBound);
/**
 * `Monoid` that returns last maximum of elements.
 *
 * @category constructors
 * @since 0.24.0
 */
exports.min = min;
const max = B => monoid.fromSemigroup(semigroup.max(B.compare), B.minBound);
/**
 * Checks if a value is between the lower and upper limit of a bound.
 *
 * @category predicates
 * @since 0.24.0
 */
exports.max = max;
const between = B => order.between(B.compare)({
  minimum: B.minBound,
  maximum: B.maxBound
});
/**
 * Clamp a value between `minBound` and `maxBound` values.
 *
 * @category utils
 * @since 0.24.0
 */
exports.between = between;
const clamp = B => order.clamp(B.compare)({
  minimum: B.minBound,
  maximum: B.maxBound
});
/**
 * Reverses the `Order` of a `Bounded` and flips `maxBound` and `minBound` values.
 *
 * @category utils
 * @since 0.24.0
 */
exports.clamp = clamp;
const reverse = B => ({
  compare: order.reverse(B.compare),
  minBound: B.maxBound,
  maxBound: B.minBound
});
exports.reverse = reverse;
//# sourceMappingURL=Bounded.js.map