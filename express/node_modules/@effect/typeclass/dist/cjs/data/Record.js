"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.traverse = exports.getTraversableFilterable = exports.getTraversable = exports.getSemigroupUnion = exports.getSemigroupIntersection = exports.getMonoidUnion = exports.getInvariant = exports.getFilterable = exports.getCovariant = exports.TraversableFilterable = exports.Traversable = exports.Invariant = exports.Filterable = exports.Covariant = void 0;
var _Function = require("effect/Function");
var Record = _interopRequireWildcard(require("effect/Record"));
var covariant = _interopRequireWildcard(require("../Covariant.js"));
var monoid = _interopRequireWildcard(require("../Monoid.js"));
var semigroup = _interopRequireWildcard(require("../Semigroup.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/** @internal */
const traverse = F => (0, _Function.dual)(2, (self, f) => F.map(F.productAll(Object.entries(self).map(([key, a]) => F.map(f(a, key), b => [key, b]))), Object.fromEntries));
exports.traverse = traverse;
const traversePartitionMap = F => (0, _Function.dual)(2, (self, f) => {
  return F.map(traverse(F)(self, f), Record.separate);
});
const traverseFilterMap = F => (0, _Function.dual)(2, (self, f) => {
  return F.map(traverse(F)(self, f), Record.getSomes);
});
const _map = Record.map;
const _imap = /*#__PURE__*/covariant.imap(_map);
const _partitionMap = Record.partitionMap;
const _filterMap = Record.filterMap;
const _traverse = traverse;
const _traversePartitionMap = traversePartitionMap;
const _traverseFilterMap = traverseFilterMap;
/**
 * @category instances
 * @since 0.24.0
 */
const getCovariant = () => ({
  imap: _imap,
  map: _map
});
/**
 * @category instances
 * @since 0.24.0
 */
exports.getCovariant = getCovariant;
const Covariant = exports.Covariant = /*#__PURE__*/getCovariant();
/**
 * @category instances
 * @since 0.24.0
 */
const getInvariant = () => ({
  imap: _imap
});
/**
 * @category instances
 * @since 0.24.0
 */
exports.getInvariant = getInvariant;
const Invariant = exports.Invariant = /*#__PURE__*/getInvariant();
/**
 * @category instances
 * @since 0.24.0
 */
const getFilterable = () => ({
  partitionMap: _partitionMap,
  filterMap: _filterMap
});
/**
 * @category instances
 * @since 0.24.0
 */
exports.getFilterable = getFilterable;
const Filterable = exports.Filterable = /*#__PURE__*/getFilterable();
/**
 * @category instances
 * @since 0.24.0
 */
const getTraversable = () => ({
  traverse: _traverse
});
/**
 * @category instances
 * @since 0.24.0
 */
exports.getTraversable = getTraversable;
const Traversable = exports.Traversable = /*#__PURE__*/getTraversable();
/**
 * @category instances
 * @since 0.24.0
 */
const getTraversableFilterable = () => ({
  traversePartitionMap: _traversePartitionMap,
  traverseFilterMap: _traverseFilterMap
});
/**
 * @category instances
 * @since 0.24.0
 */
exports.getTraversableFilterable = getTraversableFilterable;
const TraversableFilterable = exports.TraversableFilterable = /*#__PURE__*/getTraversableFilterable();
/**
 * A `Semigroup` that creates a union of two records.
 *
 * This `Semigroup` takes two records and combines them into a single record.
 * If a key exists in both records, the provided `Semigroup` instance is used to combine the values for that key.
 * If a key exists in only one of the records, that key-value pair is included as is in the resulting record.
 *
 * For example, when using the `MonoidSum`, values for matching keys will be summed.
 *
 * **Example**
 *
 * ```ts
 * import * as NumberInstances from "@effect/typeclass/data/Number"
 * import { getSemigroupUnion } from "@effect/typeclass/data/Record"
 *
 * console.log(getSemigroupUnion(NumberInstances.MonoidSum).combine({ a: 1 }, { a: 1, b: 3 }))
 * // { a: 2, b: 3 }
 * ```
 *
 * @category instances
 * @since 0.29.4
 */
const getSemigroupUnion = value => semigroup.make((self, that) => Record.union(self, that, value.combine));
/**
 * A `Monoid` that creates a union of two records.
 *
 * It allows combining two records where values for matching keys are combined using the provided `Monoid` instance.
 * If a key exists in only one of the records, that key-value pair is included as is in the resulting record.
 *
 * The `empty` value for this `Monoid` is an empty record `{}`.
 *
 * **Example**
 *
 * ```ts
 * import * as NumberInstances from "@effect/typeclass/data/Number"
 * import { getMonoidUnion } from "@effect/typeclass/data/Record"
 *
 * const monoid = getMonoidUnion(NumberInstances.MonoidSum)
 *
 * console.log(monoid.combine({ a: 1 }, { a: 1, b: 3 }))
 * // { a: 2, b: 3 }
 *
 * console.log(monoid.combine({ a: 1 }, monoid.empty))
 * // { a: 1 }
 * ```
 *
 * @category instances
 * @since 0.29.4
 */
exports.getSemigroupUnion = getSemigroupUnion;
const getMonoidUnion = value => monoid.fromSemigroup(getSemigroupUnion(value), Record.empty());
/**
 * A `Semigroup` that creates an intersection of two records.
 *
 * This `Semigroup` takes two records and combines them into a new record containing only the keys that are present in both records.
 * The values for matching keys are combined using the provided `Semigroup` instance.
 *
 * **Example**
 *
 * ```ts
 * import * as NumberInstances from "@effect/typeclass/data/Number"
 * import { getSemigroupIntersection } from "@effect/typeclass/data/Record"
 *
 * console.log(getSemigroupIntersection(NumberInstances.MonoidSum).combine({ a: 1 }, { a: 1, b: 3 }))
 * // { a: 2 }
 * ```
 *
 * @category instances
 * @since 0.29.4
 */
exports.getMonoidUnion = getMonoidUnion;
const getSemigroupIntersection = value => semigroup.make((self, that) => Record.intersection(self, that, value.combine));
exports.getSemigroupIntersection = getSemigroupIntersection;
//# sourceMappingURL=Record.js.map