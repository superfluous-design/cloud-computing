/**
 * @since 1.0.0
 */
import * as Cause from "effect/Cause";
import * as Effect from "effect/Effect";
import { hasProperty, isTagged } from "effect/Predicate";
import * as Schema from "effect/Schema";
import { EntityAddress } from "./EntityAddress.js";
import { RunnerAddress } from "./RunnerAddress.js";
import { SnowflakeFromString } from "./Snowflake.js";
/**
 * @since 1.0.0
 * @category Symbols
 */
export const TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/ClusterError");
/**
 * Represents an error that occurs when a Runner receives a message for an entity
 * that it is not assigned to it.
 *
 * @since 1.0.0
 * @category errors
 */
export class EntityNotAssignedToRunner extends /*#__PURE__*/Schema.TaggedError()("EntityNotAssignedToRunner", {
  address: EntityAddress
}) {
  /**
   * @since 1.0.0
   */
  [TypeId] = TypeId;
  /**
   * @since 1.0.0
   */
  static is(u) {
    return hasProperty(u, TypeId) && isTagged(u, "EntityNotAssignedToRunner");
  }
}
/**
 * Represents an error that occurs when a Runner receives a message for an entity
 * that it is not responsible for managing.
 *
 * @since 1.0.0
 * @category errors
 */
export class EntityNotManagedByRunner extends /*#__PURE__*/Schema.TaggedError()("EntityNotManagedByRunner", {
  address: EntityAddress
}) {
  /**
   * @since 1.0.0
   */
  [TypeId] = TypeId;
  /**
   * @since 1.0.0
   */
  static is(u) {
    return hasProperty(u, TypeId) && isTagged(u, "EntityNotManagedByRunner");
  }
}
/**
 * Represents an error that occurs when a message fails to be properly
 * deserialized by an entity.
 *
 * @since 1.0.0
 * @category errors
 */
export class MalformedMessage extends /*#__PURE__*/Schema.TaggedError()("MalformedMessage", {
  cause: Schema.Defect
}) {
  /**
   * @since 1.0.0
   */
  [TypeId] = TypeId;
  /**
   * @since 1.0.0
   */
  static is(u) {
    return hasProperty(u, TypeId) && isTagged(u, "MalformedMessage");
  }
  /**
   * @since 1.0.0
   */
  static refail = /*#__PURE__*/Effect.mapError(cause => new MalformedMessage({
    cause
  }));
}
/**
 * Represents an error that occurs when a message fails to be persisted into
 * cluster's mailbox storage.
 *
 * @since 1.0.0
 * @category errors
 */
export class PersistenceError extends /*#__PURE__*/Schema.TaggedError()("PersistenceError", {
  cause: Schema.Defect
}) {
  /**
   * @since 1.0.0
   */
  [TypeId] = TypeId;
  /**
   * @since 1.0.0
   */
  static refail(effect) {
    return Effect.catchAllCause(effect, cause => Effect.fail(new PersistenceError({
      cause: Cause.squash(cause)
    })));
  }
}
/**
 * Represents an error that occurs when a Runner is not registered with the shard
 * manager.
 *
 * @since 1.0.0
 * @category errors
 */
export class RunnerNotRegistered extends /*#__PURE__*/Schema.TaggedError()("RunnerNotRegistered", {
  address: RunnerAddress
}) {
  /**
   * @since 1.0.0
   */
  [TypeId] = TypeId;
}
/**
 * Represents an error that occurs when a Runner is unresponsive.
 *
 * @since 1.0.0
 * @category errors
 */
export class RunnerUnavailable extends /*#__PURE__*/Schema.TaggedError()("RunnerUnavailable", {
  address: RunnerAddress
}) {
  /**
   * @since 1.0.0
   */
  [TypeId] = TypeId;
  /**
   * @since 1.0.0
   */
  static is(u) {
    return hasProperty(u, TypeId) && isTagged(u, "RunnerUnavailable");
  }
}
/**
 * Represents an error that occurs when the entities mailbox is full.
 *
 * @since 1.0.0
 * @category errors
 */
export class MailboxFull extends /*#__PURE__*/Schema.TaggedError()("MailboxFull", {
  address: EntityAddress
}) {
  /**
   * @since 1.0.0
   */
  [TypeId] = TypeId;
  /**
   * @since 1.0.0
   */
  static is(u) {
    return hasProperty(u, TypeId) && isTagged(u, "MailboxFull");
  }
}
/**
 * Represents an error that occurs when the entity is already processing a
 * request.
 *
 * @since 1.0.0
 * @category errors
 */
export class AlreadyProcessingMessage extends /*#__PURE__*/Schema.TaggedError()("AlreadyProcessingMessage", {
  envelopeId: SnowflakeFromString,
  address: EntityAddress
}) {
  /**
   * @since 1.0.0
   */
  [TypeId] = TypeId;
  /**
   * @since 1.0.0
   */
  static is(u) {
    return hasProperty(u, TypeId) && isTagged(u, "AlreadyProcessingMessage");
  }
}
//# sourceMappingURL=ClusterError.js.map