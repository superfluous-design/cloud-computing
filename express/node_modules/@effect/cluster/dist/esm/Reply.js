/**
 * @since 1.0.0
 */
import * as Rpc from "@effect/rpc/Rpc";
import * as Context from "effect/Context";
import * as Data from "effect/Data";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as FiberRef from "effect/FiberRef";
import { identity } from "effect/Function";
import { hasProperty } from "effect/Predicate";
import * as Schema from "effect/Schema";
import { MalformedMessage } from "./ClusterError.js";
import { Snowflake, SnowflakeFromString } from "./Snowflake.js";
/**
 * @since 1.0.0
 * @category type ids
 */
export const TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/Reply");
/**
 * @since 1.0.0
 * @category guards
 */
export const isReply = u => hasProperty(u, TypeId);
/**
 * @since 1.0.0
 * @category models
 */
export class ReplyWithContext extends /*#__PURE__*/Data.TaggedClass("ReplyWithContext") {
  /**
   * @since 1.0.0
   */
  static fromDefect(options) {
    return new ReplyWithContext({
      reply: new WithExit({
        requestId: options.requestId,
        id: options.id,
        exit: Exit.die(Schema.encodeSync(Schema.Defect)(options.defect))
      }),
      context: Context.empty(),
      rpc: neverRpc
    });
  }
}
const neverRpc = /*#__PURE__*/Rpc.make("Never", {
  success: Schema.Never,
  error: Schema.Never,
  payload: {}
});
const schemaCache = /*#__PURE__*/new WeakMap();
/**
 * @since 1.0.0
 * @category schemas
 */
export const Reply = rpc => {
  if (schemaCache.has(rpc)) {
    return schemaCache.get(rpc);
  }
  const schema = Schema.Union(WithExit.schema(rpc), Chunk.schema(rpc));
  schemaCache.set(rpc, schema);
  return schema;
};
/**
 * @since 1.0.0
 * @category schemas
 */
export const Encoded = /*#__PURE__*/Schema.Union(/*#__PURE__*/Schema.Struct({
  _tag: /*#__PURE__*/Schema.Literal("WithExit"),
  requestId: Schema.String,
  id: Schema.String,
  exit: Schema.Unknown
}), /*#__PURE__*/Schema.Struct({
  _tag: /*#__PURE__*/Schema.Literal("Chunk"),
  requestId: Schema.String,
  id: Schema.String,
  sequence: Schema.Number,
  values: /*#__PURE__*/Schema.Array(Schema.Unknown)
}));
/**
 * @since 1.0.0
 * @category models
 */
export class Chunk extends /*#__PURE__*/Data.TaggedClass("Chunk") {
  /**
   * @since 1.0.0
   */
  [TypeId] = TypeId;
  /**
   * @since 1.0.0
   */
  static emptyFrom(requestId) {
    return new Chunk({
      requestId,
      id: Snowflake(BigInt(0)),
      sequence: 0,
      values: [undefined]
    });
  }
  /**
   * @since 1.0.0
   */
  static schemaFromSelf = /*#__PURE__*/Schema.declare(u => isReply(u) && u._tag === "Chunk");
  /**
   * @since 1.0.0
   */
  static schema(rpc) {
    const successSchema = rpc.successSchema.success;
    if (!successSchema) {
      return Schema.Never;
    }
    return Schema.transform(Schema.Struct({
      _tag: Schema.Literal("Chunk"),
      requestId: SnowflakeFromString,
      id: SnowflakeFromString,
      sequence: Schema.Number,
      values: Schema.NonEmptyArray(successSchema)
    }), Chunk.schemaFromSelf, {
      decode: encoded => new Chunk(encoded),
      encode: identity
    });
  }
  /**
   * @since 1.0.0
   */
  withRequestId(requestId) {
    return new Chunk({
      ...this,
      requestId
    });
  }
}
/**
 * @since 1.0.0
 * @category models
 */
export class WithExit extends /*#__PURE__*/Data.TaggedClass("WithExit") {
  /**
   * @since 1.0.0
   */
  [TypeId] = TypeId;
  /**
   * @since 1.0.0
   */
  static schema(rpc) {
    return Schema.transform(Schema.Struct({
      _tag: Schema.Literal("WithExit"),
      requestId: SnowflakeFromString,
      id: SnowflakeFromString,
      exit: Rpc.exitSchema(rpc)
    }), Schema.declare(u => isReply(u) && u._tag === "WithExit"), {
      decode: encoded => new WithExit(encoded),
      encode: identity
    });
  }
  /**
   * @since 1.0.0
   */
  withRequestId(requestId) {
    return new WithExit({
      ...this,
      requestId
    });
  }
}
/**
 * @since 1.0.0
 * @category serialization / deserialization
 */
export const serialize = self => {
  const schema = Reply(self.rpc);
  return MalformedMessage.refail(Effect.locally(Schema.encode(schema)(self.reply), FiberRef.currentContext, self.context));
};
/**
 * @since 1.0.0
 * @category serialization / deserialization
 */
export const serializeLastReceived = self => {
  if (self.lastReceivedReply._tag === "None") {
    return Effect.succeedNone;
  }
  const schema = Reply(self.rpc);
  return Effect.asSome(MalformedMessage.refail(Effect.locally(Schema.encode(schema)(self.lastReceivedReply.value), FiberRef.currentContext, self.context)));
};
//# sourceMappingURL=Reply.js.map