import * as RpcClient from "@effect/rpc/RpcClient";
import * as RpcGroup from "@effect/rpc/RpcGroup";
import * as RpcServer from "@effect/rpc/RpcServer";
import * as Arr from "effect/Array";
import * as Context from "effect/Context";
import * as Data from "effect/Data";
import * as Effect from "effect/Effect";
import * as Equal from "effect/Equal";
import * as Exit from "effect/Exit";
import * as Hash from "effect/Hash";
import * as Layer from "effect/Layer";
import * as Mailbox from "effect/Mailbox";
import * as Option from "effect/Option";
import * as Predicate from "effect/Predicate";
import { Scope } from "effect/Scope";
import { EntityAddress } from "./EntityAddress.js";
import { EntityType } from "./EntityType.js";
import * as Envelope from "./Envelope.js";
import { hashString } from "./internal/hash.js";
import { ResourceMap } from "./internal/resourceMap.js";
import { RunnerAddress } from "./RunnerAddress.js";
import * as ShardId from "./ShardId.js";
import { ShardingConfig } from "./ShardingConfig.js";
import * as Snowflake from "./Snowflake.js";
/**
 * @since 1.0.0
 * @category type ids
 */
export const TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/Entity");
/**
 * @since 1.0.0
 * @category refinements
 */
export const isEntity = u => Predicate.hasProperty(u, TypeId);
const Proto = {
  [TypeId]: TypeId,
  [Hash.symbol]() {
    return Hash.structure({
      type: this.type
    });
  },
  [Equal.symbol](that) {
    return isEntity(that) && this.type === that.type;
  },
  annotate(tag, value) {
    return fromRpcGroup(this.type, this.protocol.annotate(tag, value));
  },
  annotateRpcs(tag, value) {
    return fromRpcGroup(this.type, this.protocol.annotateRpcs(tag, value));
  },
  annotateContext(context) {
    return fromRpcGroup(this.type, this.protocol.annotateContext(context));
  },
  annotateRpcsContext(context) {
    return fromRpcGroup(this.type, this.protocol.annotateRpcsContext(context));
  },
  get client() {
    return shardingTag.pipe(Effect.flatMap(sharding => sharding.makeClient(this)));
  },
  toLayer(build, options) {
    return shardingTag.pipe(Effect.flatMap(sharding => sharding.registerEntity(this, Effect.isEffect(build) ? build : Effect.succeed(build), options)), Layer.effectDiscard);
  },
  toLayerMailbox(build, options) {
    const buildHandlers = Effect.gen(this, function* () {
      const behaviour = Effect.isEffect(build) ? yield* build : build;
      const mailbox = yield* Mailbox.make();
      // create the rpc handlers for the entity
      const handler = envelope => {
        return Effect.async(resume => {
          mailbox.unsafeOffer(envelope);
          resumes.set(envelope, resume);
        });
      };
      const handlers = {};
      for (const rpc of this.protocol.requests.keys()) {
        handlers[rpc] = handler;
      }
      // make the Replier for the behaviour
      const resumes = new Map();
      const complete = (request, exit) => Effect.sync(() => {
        const resume = resumes.get(request);
        if (resume) {
          resumes.delete(request);
          resume(exit);
        }
      });
      const replier = {
        succeed: (request, value) => complete(request, Exit.succeed(value)),
        fail: (request, error) => complete(request, Exit.fail(error)),
        failCause: (request, cause) => complete(request, Exit.failCause(cause)),
        complete
      };
      // fork the behaviour into the layer scope
      yield* behaviour(mailbox, replier).pipe(Effect.catchAllCause(cause => {
        const exit = Exit.failCause(cause);
        for (const resume of resumes.values()) {
          resume(exit);
        }
        return Effect.void;
      }), Effect.interruptible, Effect.forkScoped);
      return handlers;
    });
    return this.toLayer(buildHandlers, {
      ...options,
      concurrency: "unbounded"
    });
  }
};
/**
 * Creates a new `Entity` of the specified `type` which will accept messages
 * that adhere to the provided `RpcGroup`.
 *
 * @since 1.0.0
 * @category constructors
 */
export const fromRpcGroup = (
/**
 * The entity type name.
 */
type,
/**
 * The schema definition for messages that the entity is capable of
 * processing.
 */
protocol) => {
  const self = Object.create(Proto);
  self.type = EntityType.make(type);
  self.protocol = protocol;
  return self;
};
/**
 * Creates a new `Entity` of the specified `type` which will accept messages
 * that adhere to the provided schemas.
 *
 * @since 1.0.0
 * @category constructors
 */
export const make = (
/**
 * The entity type name.
 */
type,
/**
 * The schema definition for messages that the entity is capable of
 * processing.
 */
protocol) => fromRpcGroup(type, RpcGroup.make(...protocol));
/**
 * A Context.Tag to access the current entity address.
 *
 * @since 1.0.0
 * @category context
 */
export class CurrentAddress extends /*#__PURE__*/Context.Tag("@effect/cluster/Entity/EntityAddress")() {}
/**
 * A Context.Tag to access the current Runner address.
 *
 * @since 1.0.0
 * @category context
 */
export class CurrentRunnerAddress extends /*#__PURE__*/Context.Tag("@effect/cluster/Entity/RunnerAddress")() {}
/**
 * @since 1.0.0
 * @category Request
 */
export class Request extends Data.Class {
  /**
   * @since 1.0.0
   */
  get lastSentChunkValue() {
    return this.lastSentChunk.pipe(Option.map(chunk => Arr.lastNonEmpty(chunk.values)));
  }
  /**
   * @since 1.0.0
   */
  get nextSequence() {
    if (Option.isNone(this.lastSentChunk)) {
      return 0;
    }
    return this.lastSentChunk.value.sequence + 1;
  }
}
const shardingTag = /*#__PURE__*/Context.GenericTag("@effect/cluster/Sharding");
/**
 * @since 1.0.0
 * @category Testing
 */
export const makeTestClient = /*#__PURE__*/Effect.fnUntraced(function* (entity, layer) {
  const config = yield* ShardingConfig;
  const makeShardId = entityId => ShardId.make(Math.abs(hashString(entityId) % config.numberOfShards) + 1);
  const snowflakeGen = yield* Snowflake.makeGenerator;
  const runnerAddress = new RunnerAddress({
    host: "localhost",
    port: 3000
  });
  const entityMap = new Map();
  const sharding = shardingTag.of({
    ...{},
    registerEntity: (entity, handlers, options) => Effect.contextWith(context => {
      entityMap.set(entity.type, {
        context: context,
        concurrency: options?.concurrency ?? 1,
        build: entity.protocol.toHandlersContext(handlers).pipe(Effect.provide(context.pipe(Context.add(CurrentRunnerAddress, runnerAddress), Context.omit(Scope))))
      });
    })
  });
  yield* Layer.build(Layer.provide(layer, Layer.succeed(shardingTag, sharding)));
  const entityEntry = entityMap.get(entity.type);
  if (!entityEntry) {
    return yield* Effect.dieMessage(`Entity.makeTestClient: ${entity.type} was not registered by layer`);
  }
  const map = yield* ResourceMap.make(Effect.fnUntraced(function* (entityId) {
    const address = new EntityAddress({
      entityType: entity.type,
      entityId: entityId,
      shardId: makeShardId(entityId)
    });
    const handlers = yield* entityEntry.build.pipe(Effect.provideService(CurrentAddress, address));
    // eslint-disable-next-line prefer-const
    let client;
    const server = yield* RpcServer.makeNoSerialization(entity.protocol, {
      concurrency: entityEntry.concurrency,
      onFromServer(response) {
        return client.write(response);
      }
    }).pipe(Effect.provide(handlers));
    client = yield* RpcClient.makeNoSerialization(entity.protocol, {
      supportsAck: true,
      generateRequestId: () => snowflakeGen.unsafeNext(),
      onFromClient({
        message
      }) {
        if (message._tag === "Request") {
          return server.write(0, {
            ...message,
            payload: new Request({
              ...message,
              [Envelope.TypeId]: Envelope.TypeId,
              address,
              requestId: Snowflake.Snowflake(message.id),
              lastSentChunk: Option.none()
            })
          });
        }
        return server.write(0, message);
      }
    });
    return client.client;
  }));
  return entityId => map.get(entityId);
});
//# sourceMappingURL=Entity.js.map