import * as HttpRouter from "@effect/platform/HttpRouter";
import * as HttpServer from "@effect/platform/HttpServer";
import * as RpcServer from "@effect/rpc/RpcServer";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import { layerClientProtocolHttp, layerClientProtocolWebsocket } from "./HttpCommon.js";
import * as Runners from "./Runners.js";
import * as RunnerServer from "./RunnerServer.js";
import * as Sharding from "./Sharding.js";
import * as ShardManager from "./ShardManager.js";
import * as SynchronizedClock from "./SynchronizedClock.js";
/**
 * @since 1.0.0
 * @category Http App
 */
export const toHttpApp = /*#__PURE__*/Effect.gen(function* () {
  const handlers = yield* Layer.build(RunnerServer.layerHandlers);
  return yield* RpcServer.toHttpApp(Runners.Rpcs, {
    spanPrefix: "RunnerServer",
    disableTracing: true
  }).pipe(Effect.provide(handlers));
});
/**
 * @since 1.0.0
 * @category Http App
 */
export const toHttpAppWebsocket = /*#__PURE__*/Effect.gen(function* () {
  const handlers = yield* Layer.build(RunnerServer.layerHandlers);
  return yield* RpcServer.toHttpAppWebsocket(Runners.Rpcs, {
    spanPrefix: "RunnerServer",
    disableTracing: true
  }).pipe(Effect.provide(handlers));
});
/**
 * @since 1.0.0
 * @category Layers
 */
export const layerClient = /*#__PURE__*/Sharding.layer.pipe(/*#__PURE__*/Layer.provideMerge(Runners.layerRpc), /*#__PURE__*/Layer.provideMerge(SynchronizedClock.layer), /*#__PURE__*/Layer.provide(ShardManager.layerClientRpc));
/**
 * A HTTP layer for the `Runners` services, that adds a route to the provided
 * `HttpRouter.Tag`.
 *
 * By default, it uses the `HttpRouter.Default` tag.
 *
 * @since 1.0.0
 * @category Layers
 */
export const layer = options => {
  const layer = RunnerServer.layerWithClients.pipe(Layer.provide(RpcServer.layerProtocolHttp(options)));
  return options.logAddress ? withLogAddress(layer) : layer;
};
/**
 * @since 1.0.0
 * @category Layers
 */
export const layerWebsocketOptions = options => {
  const layer = RunnerServer.layerWithClients.pipe(Layer.provide(RpcServer.layerProtocolWebsocket(options)));
  return options.logAddress ? withLogAddress(layer) : layer;
};
const withLogAddress = layer => Layer.effectDiscard(HttpServer.addressFormattedWith(address => Effect.annotateLogs(Effect.logInfo(`Listening on: ${address}`), {
  package: "@effect/cluster",
  service: "Runner"
}))).pipe(Layer.provideMerge(layer));
/**
 * @since 1.0.0
 * @category Layers
 */
export const layerHttp = /*#__PURE__*/HttpRouter.Default.serve().pipe(/*#__PURE__*/Layer.provideMerge(/*#__PURE__*/layer({
  path: "/",
  logAddress: true
})), /*#__PURE__*/Layer.provide(/*#__PURE__*/layerClientProtocolHttp({
  path: "/"
})));
/**
 * @since 1.0.0
 * @category Layers
 */
export const layerHttpClientOnly = /*#__PURE__*/RunnerServer.layerClientOnly.pipe(/*#__PURE__*/Layer.provide(/*#__PURE__*/layerClientProtocolHttp({
  path: "/"
})));
/**
 * @since 1.0.0
 * @category Layers
 */
export const layerWebsocket = /*#__PURE__*/HttpRouter.Default.serve().pipe(/*#__PURE__*/Layer.provideMerge(/*#__PURE__*/layerWebsocketOptions({
  path: "/",
  logAddress: true
})), /*#__PURE__*/Layer.provide(/*#__PURE__*/layerClientProtocolWebsocket({
  path: "/"
})));
/**
 * @since 1.0.0
 * @category Layers
 */
export const layerWebsocketClientOnly = /*#__PURE__*/RunnerServer.layerClientOnly.pipe(/*#__PURE__*/Layer.provide(/*#__PURE__*/layerClientProtocolWebsocket({
  path: "/"
})));
//# sourceMappingURL=HttpRunner.js.map