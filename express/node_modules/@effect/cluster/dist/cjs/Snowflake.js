"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toParts = exports.timestamp = exports.sequence = exports.makeGenerator = exports.make = exports.machineId = exports.layerGenerator = exports.dateTime = exports.constEpochMillis = exports.TypeId = exports.SnowflakeFromString = exports.SnowflakeFromBigInt = exports.Snowflake = exports.Generator = void 0;
var Context = _interopRequireWildcard(require("effect/Context"));
var DateTime = _interopRequireWildcard(require("effect/DateTime"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var _Function = require("effect/Function");
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Schema = _interopRequireWildcard(require("effect/Schema"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 * @category Symbols
 */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/Snowflake");
/**
 * @since 1.0.0
 * @category Models
 */
const Snowflake = input => typeof input === "string" ? BigInt(input) : input;
/**
 * @since 1.0.0
 * @category Schemas
 */
exports.Snowflake = Snowflake;
const SnowflakeFromBigInt = exports.SnowflakeFromBigInt = /*#__PURE__*/Schema.BigIntFromSelf.pipe(/*#__PURE__*/Schema.brand(TypeId));
/**
 * @since 1.0.0
 * @category Schemas
 */
const SnowflakeFromString = exports.SnowflakeFromString = /*#__PURE__*/Schema.BigInt.pipe(/*#__PURE__*/Schema.brand(TypeId));
/**
 * @since 1.0.0
 * @category Epoch
 */
const constEpochMillis = exports.constEpochMillis = /*#__PURE__*/Date.UTC(2025, 0, 1);
const sinceUnixEpoch = constEpochMillis - /*#__PURE__*/Date.UTC(1970, 0, 1);
const constBigInt12 = /*#__PURE__*/BigInt(12);
const constBigInt22 = /*#__PURE__*/BigInt(22);
const constBigInt1024 = /*#__PURE__*/BigInt(1024);
const constBigInt4096 = /*#__PURE__*/BigInt(4096);
/**
 * @since 1.0.0
 * @category constructors
 */
const make = options => BigInt(options.timestamp - constEpochMillis) << constBigInt22 | BigInt(options.machineId % 1024) << constBigInt12 | BigInt(options.sequence % 4096);
/**
 * @since 1.0.0
 * @category Parts
 */
exports.make = make;
const timestamp = snowflake => Number(snowflake >> constBigInt22) + sinceUnixEpoch;
/**
 * @since 1.0.0
 * @category Parts
 */
exports.timestamp = timestamp;
const dateTime = snowflake => DateTime.unsafeMake(timestamp(snowflake));
/**
 * @since 1.0.0
 * @category Parts
 */
exports.dateTime = dateTime;
const machineId = snowflake => Number((snowflake >> constBigInt12) % constBigInt1024);
/**
 * @since 1.0.0
 * @category Parts
 */
exports.machineId = machineId;
const sequence = snowflake => Number(snowflake % constBigInt4096);
/**
 * @since 1.0.0
 * @category Parts
 */
exports.sequence = sequence;
const toParts = snowflake => ({
  timestamp: timestamp(snowflake),
  machineId: machineId(snowflake),
  sequence: sequence(snowflake)
});
/**
 * @since 1.0.0
 * @category Generator
 */
exports.toParts = toParts;
const makeGenerator = exports.makeGenerator = /*#__PURE__*/Effect.gen(function* () {
  let machineId = Math.floor(Math.random() * 1024);
  const clock = yield* Effect.clock;
  let sequence = 0;
  let sequenceAt = clock.unsafeCurrentTimeMillis();
  return (0, _Function.identity)({
    setMachineId: newMachineId => Effect.sync(() => {
      machineId = newMachineId;
    }),
    unsafeNext() {
      let now = clock.unsafeCurrentTimeMillis();
      // account for clock drift, only allow time to move forward
      if (now < sequenceAt) {
        now = sequenceAt;
      } else if (now > sequenceAt) {
        // reset sequence if we're in a new millisecond
        sequence = 0;
        sequenceAt = now;
      } else if (sequence >= 1024) {
        // if we've hit the max sequence for this millisecond, go to the next
        // millisecond
        sequenceAt++;
        sequence = 0;
      }
      return make({
        machineId,
        sequence: sequence++,
        timestamp: sequenceAt
      });
    }
  });
});
/**
 * @since 1.0.0
 * @category Generator
 */
class Generator extends /*#__PURE__*/Context.Tag("@effect/cluster/Snowflake/Generator")() {}
/**
 * @since 1.0.0
 * @category Generator
 */
exports.Generator = Generator;
const layerGenerator = exports.layerGenerator = /*#__PURE__*/Layer.effect(Generator, makeGenerator);
//# sourceMappingURL=Snowflake.js.map