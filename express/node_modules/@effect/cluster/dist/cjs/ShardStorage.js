"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeMemory = exports.makeEncoded = exports.layerNoop = exports.layerMemory = exports.ShardStorage = void 0;
var Context = _interopRequireWildcard(require("effect/Context"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Layer = _interopRequireWildcard(require("effect/Layer"));
var MutableHashMap = _interopRequireWildcard(require("effect/MutableHashMap"));
var Option = _interopRequireWildcard(require("effect/Option"));
var _Runner = require("./Runner.js");
var _RunnerAddress = require("./RunnerAddress.js");
var _ShardId = require("./ShardId.js");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

/**
 * Represents a generic interface to the persistent storage required by the
 * cluster.
 *
 * @since 1.0.0
 * @category models
 */
class ShardStorage extends /*#__PURE__*/Context.Tag("@effect/cluster/ShardStorage")() {}
/**
 * @since 1.0.0
 * @category layers
 */
exports.ShardStorage = ShardStorage;
const makeEncoded = exports.makeEncoded = /*#__PURE__*/Effect.fnUntraced(function* (encoded) {
  const activeShards = new Set();
  return ShardStorage.of({
    getAssignments: Effect.map(encoded.getAssignments, assignments => {
      const map = new Map();
      for (const [shardId, runnerAddress] of assignments) {
        map.set(_ShardId.ShardId.make(shardId), runnerAddress === null ? Option.none() : Option.some(decodeRunnerAddress(runnerAddress)));
      }
      return map;
    }),
    saveAssignments: assignments => encoded.saveAssignments(Array.from(assignments, ([shardId, runnerAddress]) => [shardId, Option.isNone(runnerAddress) ? null : encodeRunnerAddress(runnerAddress.value)])),
    getRunners: Effect.gen(function* () {
      const runners = yield* encoded.getRunners;
      const results = new Array(runners.length);
      for (let i = 0; i < runners.length; i++) {
        const [address, runner] = runners[i];
        results[i] = [decodeRunnerAddress(address), _Runner.Runner.decodeSync(runner)];
      }
      return results;
    }),
    saveRunners: runners => Effect.suspend(() => encoded.saveRunners(Array.from(runners, ([address, runner]) => [encodeRunnerAddress(address), _Runner.Runner.encodeSync(runner)]))),
    acquire: (address, shardIds) => encoded.acquire(encodeRunnerAddress(address), Array.from(shardIds)),
    refresh: (address, shardIds) => encoded.refresh(encodeRunnerAddress(address), Array.from(shardIds)),
    release: Effect.fnUntraced(function* (address, shardId) {
      activeShards.delete(shardId);
      yield* encoded.release(encodeRunnerAddress(address), shardId).pipe(Effect.onError(() => Effect.sync(() => activeShards.add(shardId))));
    }),
    releaseAll: Effect.fnUntraced(function* (address) {
      activeShards.clear();
      yield* encoded.releaseAll(encodeRunnerAddress(address));
    })
  });
});
/**
 * @since 1.0.0
 * @category layers
 */
const layerNoop = exports.layerNoop = /*#__PURE__*/Layer.sync(ShardStorage, () => {
  let acquired = [];
  return ShardStorage.of({
    getAssignments: Effect.succeed(new Map()),
    saveAssignments: () => Effect.void,
    getRunners: Effect.sync(() => []),
    saveRunners: () => Effect.void,
    acquire: (_address, shards) => {
      acquired = Array.from(shards);
      return Effect.succeed(Array.from(shards));
    },
    refresh: () => Effect.sync(() => acquired),
    release: () => Effect.void,
    releaseAll: () => Effect.void
  });
});
/**
 * @since 1.0.0
 * @category constructors
 */
const makeMemory = exports.makeMemory = /*#__PURE__*/Effect.gen(function* () {
  const assignments = new Map();
  const runners = MutableHashMap.empty();
  function saveAssignments(value) {
    return Effect.sync(() => {
      for (const [shardId, runnerAddress] of value) {
        assignments.set(shardId, runnerAddress);
      }
    });
  }
  function saveRunners(value) {
    return Effect.sync(() => {
      for (const [address, runner] of value) {
        MutableHashMap.set(runners, address, runner);
      }
    });
  }
  let acquired = [];
  return ShardStorage.of({
    getAssignments: Effect.sync(() => new Map(assignments)),
    saveAssignments,
    getRunners: Effect.sync(() => Array.from(runners)),
    saveRunners,
    acquire: (_address, shardIds) => {
      acquired = Array.from(shardIds);
      return Effect.succeed(Array.from(shardIds));
    },
    refresh: () => Effect.sync(() => acquired),
    release: () => Effect.void,
    releaseAll: () => Effect.void
  });
});
/**
 * @since 1.0.0
 * @category layers
 */
const layerMemory = exports.layerMemory = /*#__PURE__*/Layer.effect(ShardStorage, makeMemory);
// -------------------------------------------------------------------------------------
// internal
// -------------------------------------------------------------------------------------
const encodeRunnerAddress = runnerAddress => `${runnerAddress.host}:${runnerAddress.port}`;
const decodeRunnerAddress = runnerAddress => {
  const [host, port] = runnerAddress.split(":");
  return new _RunnerAddress.RunnerAddress({
    host,
    port: Number(port)
  });
};
//# sourceMappingURL=ShardStorage.js.map