"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeTestClient = exports.make = exports.isEntity = exports.fromRpcGroup = exports.TypeId = exports.Request = exports.CurrentRunnerAddress = exports.CurrentAddress = void 0;
var RpcClient = _interopRequireWildcard(require("@effect/rpc/RpcClient"));
var RpcGroup = _interopRequireWildcard(require("@effect/rpc/RpcGroup"));
var RpcServer = _interopRequireWildcard(require("@effect/rpc/RpcServer"));
var Arr = _interopRequireWildcard(require("effect/Array"));
var Context = _interopRequireWildcard(require("effect/Context"));
var Data = _interopRequireWildcard(require("effect/Data"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Equal = _interopRequireWildcard(require("effect/Equal"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var Hash = _interopRequireWildcard(require("effect/Hash"));
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Mailbox = _interopRequireWildcard(require("effect/Mailbox"));
var Option = _interopRequireWildcard(require("effect/Option"));
var Predicate = _interopRequireWildcard(require("effect/Predicate"));
var _Scope = require("effect/Scope");
var _EntityAddress = require("./EntityAddress.js");
var _EntityType = require("./EntityType.js");
var Envelope = _interopRequireWildcard(require("./Envelope.js"));
var _hash = require("./internal/hash.js");
var _resourceMap = require("./internal/resourceMap.js");
var _RunnerAddress = require("./RunnerAddress.js");
var ShardId = _interopRequireWildcard(require("./ShardId.js"));
var _ShardingConfig = require("./ShardingConfig.js");
var Snowflake = _interopRequireWildcard(require("./Snowflake.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 * @category type ids
 */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/Entity");
/**
 * @since 1.0.0
 * @category refinements
 */
const isEntity = u => Predicate.hasProperty(u, TypeId);
exports.isEntity = isEntity;
const Proto = {
  [TypeId]: TypeId,
  [Hash.symbol]() {
    return Hash.structure({
      type: this.type
    });
  },
  [Equal.symbol](that) {
    return isEntity(that) && this.type === that.type;
  },
  annotate(tag, value) {
    return fromRpcGroup(this.type, this.protocol.annotate(tag, value));
  },
  annotateRpcs(tag, value) {
    return fromRpcGroup(this.type, this.protocol.annotateRpcs(tag, value));
  },
  annotateContext(context) {
    return fromRpcGroup(this.type, this.protocol.annotateContext(context));
  },
  annotateRpcsContext(context) {
    return fromRpcGroup(this.type, this.protocol.annotateRpcsContext(context));
  },
  get client() {
    return shardingTag.pipe(Effect.flatMap(sharding => sharding.makeClient(this)));
  },
  toLayer(build, options) {
    return shardingTag.pipe(Effect.flatMap(sharding => sharding.registerEntity(this, Effect.isEffect(build) ? build : Effect.succeed(build), options)), Layer.effectDiscard);
  },
  toLayerMailbox(build, options) {
    const buildHandlers = Effect.gen(this, function* () {
      const behaviour = Effect.isEffect(build) ? yield* build : build;
      const mailbox = yield* Mailbox.make();
      // create the rpc handlers for the entity
      const handler = envelope => {
        return Effect.async(resume => {
          mailbox.unsafeOffer(envelope);
          resumes.set(envelope, resume);
        });
      };
      const handlers = {};
      for (const rpc of this.protocol.requests.keys()) {
        handlers[rpc] = handler;
      }
      // make the Replier for the behaviour
      const resumes = new Map();
      const complete = (request, exit) => Effect.sync(() => {
        const resume = resumes.get(request);
        if (resume) {
          resumes.delete(request);
          resume(exit);
        }
      });
      const replier = {
        succeed: (request, value) => complete(request, Exit.succeed(value)),
        fail: (request, error) => complete(request, Exit.fail(error)),
        failCause: (request, cause) => complete(request, Exit.failCause(cause)),
        complete
      };
      // fork the behaviour into the layer scope
      yield* behaviour(mailbox, replier).pipe(Effect.catchAllCause(cause => {
        const exit = Exit.failCause(cause);
        for (const resume of resumes.values()) {
          resume(exit);
        }
        return Effect.void;
      }), Effect.interruptible, Effect.forkScoped);
      return handlers;
    });
    return this.toLayer(buildHandlers, {
      ...options,
      concurrency: "unbounded"
    });
  }
};
/**
 * Creates a new `Entity` of the specified `type` which will accept messages
 * that adhere to the provided `RpcGroup`.
 *
 * @since 1.0.0
 * @category constructors
 */
const fromRpcGroup = (
/**
 * The entity type name.
 */
type,
/**
 * The schema definition for messages that the entity is capable of
 * processing.
 */
protocol) => {
  const self = Object.create(Proto);
  self.type = _EntityType.EntityType.make(type);
  self.protocol = protocol;
  return self;
};
/**
 * Creates a new `Entity` of the specified `type` which will accept messages
 * that adhere to the provided schemas.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fromRpcGroup = fromRpcGroup;
const make = (
/**
 * The entity type name.
 */
type,
/**
 * The schema definition for messages that the entity is capable of
 * processing.
 */
protocol) => fromRpcGroup(type, RpcGroup.make(...protocol));
/**
 * A Context.Tag to access the current entity address.
 *
 * @since 1.0.0
 * @category context
 */
exports.make = make;
class CurrentAddress extends /*#__PURE__*/Context.Tag("@effect/cluster/Entity/EntityAddress")() {}
/**
 * A Context.Tag to access the current Runner address.
 *
 * @since 1.0.0
 * @category context
 */
exports.CurrentAddress = CurrentAddress;
class CurrentRunnerAddress extends /*#__PURE__*/Context.Tag("@effect/cluster/Entity/RunnerAddress")() {}
/**
 * @since 1.0.0
 * @category Request
 */
exports.CurrentRunnerAddress = CurrentRunnerAddress;
class Request extends Data.Class {
  /**
   * @since 1.0.0
   */
  get lastSentChunkValue() {
    return this.lastSentChunk.pipe(Option.map(chunk => Arr.lastNonEmpty(chunk.values)));
  }
  /**
   * @since 1.0.0
   */
  get nextSequence() {
    if (Option.isNone(this.lastSentChunk)) {
      return 0;
    }
    return this.lastSentChunk.value.sequence + 1;
  }
}
exports.Request = Request;
const shardingTag = /*#__PURE__*/Context.GenericTag("@effect/cluster/Sharding");
/**
 * @since 1.0.0
 * @category Testing
 */
const makeTestClient = exports.makeTestClient = /*#__PURE__*/Effect.fnUntraced(function* (entity, layer) {
  const config = yield* _ShardingConfig.ShardingConfig;
  const makeShardId = entityId => ShardId.make(Math.abs((0, _hash.hashString)(entityId) % config.numberOfShards) + 1);
  const snowflakeGen = yield* Snowflake.makeGenerator;
  const runnerAddress = new _RunnerAddress.RunnerAddress({
    host: "localhost",
    port: 3000
  });
  const entityMap = new Map();
  const sharding = shardingTag.of({
    ...{},
    registerEntity: (entity, handlers, options) => Effect.contextWith(context => {
      entityMap.set(entity.type, {
        context: context,
        concurrency: options?.concurrency ?? 1,
        build: entity.protocol.toHandlersContext(handlers).pipe(Effect.provide(context.pipe(Context.add(CurrentRunnerAddress, runnerAddress), Context.omit(_Scope.Scope))))
      });
    })
  });
  yield* Layer.build(Layer.provide(layer, Layer.succeed(shardingTag, sharding)));
  const entityEntry = entityMap.get(entity.type);
  if (!entityEntry) {
    return yield* Effect.dieMessage(`Entity.makeTestClient: ${entity.type} was not registered by layer`);
  }
  const map = yield* _resourceMap.ResourceMap.make(Effect.fnUntraced(function* (entityId) {
    const address = new _EntityAddress.EntityAddress({
      entityType: entity.type,
      entityId: entityId,
      shardId: makeShardId(entityId)
    });
    const handlers = yield* entityEntry.build.pipe(Effect.provideService(CurrentAddress, address));
    // eslint-disable-next-line prefer-const
    let client;
    const server = yield* RpcServer.makeNoSerialization(entity.protocol, {
      concurrency: entityEntry.concurrency,
      onFromServer(response) {
        return client.write(response);
      }
    }).pipe(Effect.provide(handlers));
    client = yield* RpcClient.makeNoSerialization(entity.protocol, {
      supportsAck: true,
      generateRequestId: () => snowflakeGen.unsafeNext(),
      onFromClient({
        message
      }) {
        if (message._tag === "Request") {
          return server.write(0, {
            ...message,
            payload: new Request({
              ...message,
              [Envelope.TypeId]: Envelope.TypeId,
              address,
              requestId: Snowflake.Snowflake(message.id),
              lastSentChunk: Option.none()
            })
          });
        }
        return server.write(0, message);
      }
    });
    return client.client;
  }));
  return entityId => map.get(entityId);
});
//# sourceMappingURL=Entity.js.map