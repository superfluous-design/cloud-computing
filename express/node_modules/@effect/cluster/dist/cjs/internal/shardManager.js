"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.State = exports.RunnerWithMetadata = void 0;
exports.decideAssignmentsForUnassignedShards = decideAssignmentsForUnassignedShards;
exports.decideAssignmentsForUnbalancedShards = decideAssignmentsForUnbalancedShards;
var Arr = _interopRequireWildcard(require("effect/Array"));
var Clock = _interopRequireWildcard(require("effect/Clock"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var _Function = require("effect/Function");
var MutableHashMap = _interopRequireWildcard(require("effect/MutableHashMap"));
var MutableHashSet = _interopRequireWildcard(require("effect/MutableHashSet"));
var Option = _interopRequireWildcard(require("effect/Option"));
var Order = _interopRequireWildcard(require("effect/Order"));
var _RunnerHealth = require("../RunnerHealth.js");
var _ShardId = require("../ShardId.js");
var _ShardStorage = require("../ShardStorage.js");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/** @internal */
class State {
  runners;
  shards;
  static fromStorage = /*#__PURE__*/Effect.fnUntraced(function* (numberOfShards) {
    const storage = yield* _ShardStorage.ShardStorage;
    const runnerHealth = yield* _RunnerHealth.RunnerHealth;
    // Fetch registered runners and shard assignments from cluster storage
    const storedRunners = yield* storage.getRunners;
    const storedAssignments = yield* storage.getAssignments;
    // Determine which runners are still alive
    const deadRunners = Arr.empty();
    const aliveRunners = MutableHashMap.empty();
    yield* Effect.forEach(storedRunners, ([address, runner]) => Effect.map(runnerHealth.isAlive(address), isAlive => {
      if (isAlive) {
        MutableHashMap.set(aliveRunners, address, runner);
      } else {
        deadRunners.push(runner);
      }
    }), {
      concurrency: "unbounded",
      discard: true
    });
    if (deadRunners.length > 0) {
      yield* Effect.logWarning("Ignoring runners that are no longer considered alive:", deadRunners);
    }
    // Determine which shards remain unassigned to a runner
    const assignedShards = new Map();
    const invalidAssignments = Arr.empty();
    for (const [shard, address] of storedAssignments) {
      if (Option.isSome(address) && MutableHashMap.has(aliveRunners, address.value)) {
        assignedShards.set(shard, address.value);
      } else if (Option.isSome(address)) {
        invalidAssignments.push([shard, address.value]);
      }
    }
    if (invalidAssignments.length > 0) {
      yield* Effect.logWarning("Ignoring shard assignments for runners that are no longer considered alive: ", invalidAssignments);
    }
    // Construct the initial state
    const now = yield* Clock.currentTimeMillis;
    const runnerState = MutableHashMap.empty();
    for (const [address, runner] of aliveRunners) {
      MutableHashMap.set(runnerState, address, RunnerWithMetadata({
        runner,
        registeredAt: now
      }));
    }
    const shardState = new Map();
    for (let n = 1; n <= numberOfShards; n++) {
      const shardId = _ShardId.ShardId.make(n);
      shardState.set(shardId, Option.fromNullable(assignedShards.get(shardId)));
    }
    return new State(runnerState, shardState);
  });
  constructor(runners, shards) {
    this.runners = runners;
    this.shards = shards;
  }
  get maxVersion() {
    if (MutableHashMap.size(this.runners) === 0) return Option.none();
    let version = undefined;
    for (const [, meta] of this.runners) {
      if (version === undefined || meta.runner.version > version) {
        version = meta.runner.version;
      }
    }
    return Option.some(version);
  }
  allRunnersHaveVersion(version) {
    return version.pipe(Option.map(max => Arr.every(this.runnerVersions, version => version === max)), Option.getOrElse(_Function.constFalse));
  }
  get shardsPerRunner() {
    const shards = MutableHashMap.empty();
    if (MutableHashMap.isEmpty(this.runners)) return shards;
    MutableHashMap.forEach(this.runners, (_, address) => {
      MutableHashMap.set(shards, address, new Set());
    });
    for (const [shard, address] of this.shards) {
      if (Option.isNone(address)) continue;
      const shardIds = Option.getOrUndefined(MutableHashMap.get(shards, address.value));
      shardIds.add(shard);
    }
    return shards;
  }
  get averageShardsPerRunner() {
    const runnerCount = MutableHashMap.size(this.runners);
    return runnerCount > 0 ? this.shards.size / runnerCount : 0;
  }
  get unassignedShards() {
    const shardIds = [];
    for (const [shard, address] of this.shards) {
      if (Option.isNone(address)) {
        shardIds.push(shard);
      }
    }
    return shardIds;
  }
  get runnerVersions() {
    const runnerVersions = [];
    for (const [, meta] of this.runners) {
      runnerVersions.push(meta.runner.version);
    }
    return runnerVersions;
  }
}
/** @internal */
exports.State = State;
const RunnerWithMetadata = runner => runner;
/** @internal */
exports.RunnerWithMetadata = RunnerWithMetadata;
function decideAssignmentsForUnassignedShards(state) {
  return pickNewRunners(state.unassignedShards, state, true, 1);
}
const allocationOrder = /*#__PURE__*/Order.combine(/*#__PURE__*/Order.mapInput(Order.number, ([, shards]) => shards), /*#__PURE__*/Order.mapInput(Order.number, ([,, registeredAt]) => registeredAt));
/** @internal */
function decideAssignmentsForUnbalancedShards(state, rate) {
  const shardsPerRunner = state.shardsPerRunner;
  const maxVersion = state.maxVersion;
  const extraShardsToAllocate = Arr.empty();
  if (state.allRunnersHaveVersion(maxVersion)) {
    const averageShardsPerRunner = state.averageShardsPerRunner;
    MutableHashMap.forEach(shardsPerRunner, shards => {
      // Count how many extra shards there are compared to the average
      const extraShards = Math.max(0, shards.size - averageShardsPerRunner);
      for (const shard of takeRandom(shards, extraShards)) {
        const maybeAddress = state.shards.get(shard) ?? Option.none();
        if (Option.isNone(maybeAddress)) {
          extraShardsToAllocate.push([shard, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);
          continue;
        }
        const address = maybeAddress.value;
        extraShardsToAllocate.push([shard, Option.match(MutableHashMap.get(shardsPerRunner, address), {
          onNone: () => Number.MIN_SAFE_INTEGER,
          onSome: shards => -shards.size
        }), Option.match(MutableHashMap.get(state.runners, address), {
          onNone: () => Number.MIN_SAFE_INTEGER,
          onSome: meta => meta.registeredAt
        })]);
      }
    });
  }
  const sortedShardsToRebalance = extraShardsToAllocate.sort(allocationOrder).map(([shard]) => shard);
  return pickNewRunners(sortedShardsToRebalance, state, false, rate, shardsPerRunner, maxVersion);
}
function pickNewRunners(shardsToRebalance, state, immediate, rate, shardsPerRunner = state.shardsPerRunner, maybeMaxVersion = state.maxVersion) {
  const addressAssignments = MutableHashMap.empty();
  const unassignments = MutableHashMap.empty();
  const changes = MutableHashSet.empty();
  if (Option.isNone(maybeMaxVersion)) {
    return [addressAssignments, unassignments, changes];
  }
  const maxVersion = maybeMaxVersion.value;
  for (const shardId of shardsToRebalance) {
    // Find the runner with the fewest assigned shards
    let candidate;
    let candidateShards;
    for (const [address, shards] of shardsPerRunner) {
      // Keep only runners with the maximum version
      const maybeRunnerMeta = MutableHashMap.get(state.runners, address);
      if (Option.isNone(maybeRunnerMeta)) continue;
      const runnerMeta = maybeRunnerMeta.value;
      if (runnerMeta.runner.version !== maxVersion) continue;
      // Do not assign to a runner that has unassignments in the same rebalance
      if (MutableHashMap.has(unassignments, address)) continue;
      // Do not assign too many shards to each runner unless rebalancing must
      // occur immediately
      if (!immediate) {
        const assignmentCount = Option.getOrUndefined(MutableHashMap.get(addressAssignments, address))?.size ?? 0;
        if (assignmentCount >= state.shards.size * rate) continue;
      }
      if (candidate === undefined || shards.size < candidateShards.size) {
        candidate = address;
        candidateShards = shards;
      }
    }
    if (!candidate || !candidateShards) break;
    // If the old runner is the same as the new runner, do nothing
    const oldRunner = Option.getOrUndefined(state.shards.get(shardId) ?? Option.none());
    if (oldRunner && oldRunner.toString() === candidate.toString()) {
      continue;
    }
    const oldShards = oldRunner && Option.getOrUndefined(MutableHashMap.get(shardsPerRunner, oldRunner));
    // If the new runner has one less, as many, or more shards than the
    // old runner, do not change anything
    if (oldShards && candidateShards.size + 1 >= oldShards.size) continue;
    // Otherwise create a new assignment
    MutableHashMap.modifyAt(addressAssignments, candidate, Option.match({
      onNone: () => Option.some(new Set([shardId])),
      onSome: shards => {
        shards.add(shardId);
        return Option.some(shards);
      }
    }));
    if (oldRunner) {
      MutableHashMap.modifyAt(unassignments, oldRunner, Option.match({
        onNone: () => Option.some(new Set([shardId])),
        onSome: shards => {
          shards.add(shardId);
          return Option.some(shards);
        }
      }));
    }
    // Move the shard to the new runner
    candidateShards.add(shardId);
    if (oldShards) {
      oldShards.delete(shardId);
    }
    // Track changes
    MutableHashSet.add(changes, candidate);
    if (oldRunner) MutableHashSet.add(changes, oldRunner);
  }
  return [addressAssignments, unassignments, changes];
}
function takeRandom(self, n) {
  const array = Array.from(self);
  let currentIndex = array.length;
  while (currentIndex != 0) {
    const randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex = currentIndex - 1;
    swap(array, currentIndex, randomIndex);
  }
  return n < array.length ? array.slice(0, n) : array;
}
function swap(array, i, j) {
  const tmp = array[i];
  array[i] = array[j];
  array[j] = tmp;
  return array;
}
//# sourceMappingURL=shardManager.js.map