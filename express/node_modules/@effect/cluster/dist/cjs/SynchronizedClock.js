"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.make = exports.layer = void 0;
var Clock = _interopRequireWildcard(require("effect/Clock"));
var Duration = _interopRequireWildcard(require("effect/Duration"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Schedule = _interopRequireWildcard(require("effect/Schedule"));
var _ShardManager = require("./ShardManager.js");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category Constructors
 */
const make = exports.make = /*#__PURE__*/Effect.fnUntraced(function* (getRemoteTime) {
  const clock = yield* Effect.clock;
  let driftMillis = 0;
  let driftNanos = BigInt(0);
  yield* getRemoteTime.pipe(Effect.timed, Effect.map(([duration, shardManagerTime]) => {
    const halfTrip = Duration.unsafeDivide(duration, 2);
    shardManagerTime = shardManagerTime + Duration.toMillis(halfTrip) + 1;
    const selfTime = clock.unsafeCurrentTimeMillis();
    return shardManagerTime - selfTime;
  }), Effect.replicateEffect(5), Effect.flatMap(drifts => {
    drifts.sort();
    const drift = (driftMillis + drifts[2]) / 2;
    driftMillis = Math.round(drift);
    driftNanos = BigInt(Math.round(drift * 1_000_000));
    return Effect.logDebug("Current drift", driftMillis);
  }), Effect.andThen(Effect.sleep(Duration.minutes(5))), Effect.forever, Effect.sandbox, Effect.retry(Schedule.spaced(Duration.minutes(1))), Effect.annotateLogs({
    package: "@effect/cluster",
    service: "SynchronizedClock"
  }), Effect.forkScoped);
  function unsafeCurrentTimeMillis() {
    return clock.unsafeCurrentTimeMillis() + driftMillis;
  }
  function unsafeCurrentTimeNanos() {
    return clock.unsafeCurrentTimeNanos() + driftNanos;
  }
  return Clock.Clock.of({
    [Clock.ClockTypeId]: Clock.ClockTypeId,
    sleep: clock.sleep,
    unsafeCurrentTimeMillis,
    unsafeCurrentTimeNanos,
    currentTimeMillis: Effect.sync(unsafeCurrentTimeMillis),
    currentTimeNanos: Effect.sync(unsafeCurrentTimeNanos)
  });
});
/**
 * @since 1.0.0
 * @category Layers
 */
const layer = exports.layer = /*#__PURE__*/Layer.unwrapScoped(/*#__PURE__*/Effect.gen(function* () {
  const shardManager = yield* _ShardManager.ShardManagerClient;
  const clock = yield* make(shardManager.getTime);
  return Layer.setClock(clock);
}));
//# sourceMappingURL=SynchronizedClock.js.map