"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeClientRpc = exports.makeClientLocal = exports.make = exports.layerServerHandlers = exports.layerServer = exports.layerConfigFromEnv = exports.layerConfig = exports.layerClientRpc = exports.layerClientLocal = exports.layer = exports.configFromEnv = exports.configConfig = exports.ShardingEventSchema = exports.ShardingEvent = exports.ShardManagerClient = exports.ShardManager = exports.Rpcs = exports.Config = void 0;
var Rpc = _interopRequireWildcard(require("@effect/rpc/Rpc"));
var RpcClient = _interopRequireWildcard(require("@effect/rpc/RpcClient"));
var RpcGroup = _interopRequireWildcard(require("@effect/rpc/RpcGroup"));
var RpcServer = _interopRequireWildcard(require("@effect/rpc/RpcServer"));
var Arr = _interopRequireWildcard(require("effect/Array"));
var Clock = _interopRequireWildcard(require("effect/Clock"));
var Config_ = _interopRequireWildcard(require("effect/Config"));
var ConfigProvider = _interopRequireWildcard(require("effect/ConfigProvider"));
var Context = _interopRequireWildcard(require("effect/Context"));
var Data = _interopRequireWildcard(require("effect/Data"));
var Deferred = _interopRequireWildcard(require("effect/Deferred"));
var Duration = _interopRequireWildcard(require("effect/Duration"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Equal = _interopRequireWildcard(require("effect/Equal"));
var FiberSet = _interopRequireWildcard(require("effect/FiberSet"));
var _Function = require("effect/Function");
var Iterable = _interopRequireWildcard(require("effect/Iterable"));
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Mailbox = _interopRequireWildcard(require("effect/Mailbox"));
var Metric = _interopRequireWildcard(require("effect/Metric"));
var MutableHashMap = _interopRequireWildcard(require("effect/MutableHashMap"));
var MutableHashSet = _interopRequireWildcard(require("effect/MutableHashSet"));
var Option = _interopRequireWildcard(require("effect/Option"));
var PubSub = _interopRequireWildcard(require("effect/PubSub"));
var Queue = _interopRequireWildcard(require("effect/Queue"));
var Schedule = _interopRequireWildcard(require("effect/Schedule"));
var Schema = _interopRequireWildcard(require("effect/Schema"));
var _ClusterError = require("./ClusterError.js");
var ClusterMetrics = _interopRequireWildcard(require("./ClusterMetrics.js"));
var _shardManager = require("./internal/shardManager.js");
var MachineId = _interopRequireWildcard(require("./MachineId.js"));
var _Runner = require("./Runner.js");
var _RunnerAddress = require("./RunnerAddress.js");
var _RunnerHealth = require("./RunnerHealth.js");
var _Runners = require("./Runners.js");
var _ShardId = require("./ShardId.js");
var _ShardingConfig = require("./ShardingConfig.js");
var _ShardStorage = require("./ShardStorage.js");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category models
 */
class ShardManager extends /*#__PURE__*/Context.Tag("@effect/cluster/ShardManager")() {}
/**
 * @since 1.0.0
 * @category Config
 */
exports.ShardManager = ShardManager;
class Config extends /*#__PURE__*/Context.Tag("@effect/cluster/ShardManager/Config")() {
  /**
   * @since 1.0.0
   */
  static defaults = {
    rebalanceDebounce: /*#__PURE__*/Duration.millis(500),
    rebalanceInterval: /*#__PURE__*/Duration.seconds(20),
    rebalanceRetryInterval: /*#__PURE__*/Duration.seconds(10),
    rebalanceRate: 2 / 100,
    persistRetryCount: 100,
    persistRetryInterval: /*#__PURE__*/Duration.seconds(3),
    runnerHealthCheckInterval: /*#__PURE__*/Duration.minutes(1),
    runnerPingTimeout: /*#__PURE__*/Duration.seconds(3)
  };
}
/**
 * @since 1.0.0
 * @category Config
 */
exports.Config = Config;
const configConfig = exports.configConfig = /*#__PURE__*/Config_.all({
  rebalanceDebounce: /*#__PURE__*/Config_.duration("rebalanceDebounce").pipe(/*#__PURE__*/Config_.withDefault(Config.defaults.rebalanceDebounce), /*#__PURE__*/Config_.withDescription("The duration to wait before rebalancing shards after a change.")),
  rebalanceInterval: /*#__PURE__*/Config_.duration("rebalanceInterval").pipe(/*#__PURE__*/Config_.withDefault(Config.defaults.rebalanceInterval), /*#__PURE__*/Config_.withDescription("The interval on which regular rebalancing of shards will occur.")),
  rebalanceRetryInterval: /*#__PURE__*/Config_.duration("rebalanceRetryInterval").pipe(/*#__PURE__*/Config_.withDefault(Config.defaults.rebalanceRetryInterval), /*#__PURE__*/Config_.withDescription("The interval on which rebalancing of shards which failed to be rebalanced will be retried.")),
  rebalanceRate: /*#__PURE__*/Config_.number("rebalanceRate").pipe(/*#__PURE__*/Config_.withDefault(Config.defaults.rebalanceRate), /*#__PURE__*/Config_.withDescription("The maximum ratio of shards to rebalance at once.")),
  persistRetryCount: /*#__PURE__*/Config_.integer("persistRetryCount").pipe(/*#__PURE__*/Config_.withDefault(Config.defaults.persistRetryCount), /*#__PURE__*/Config_.withDescription("The number of times persistence of runners will be retried if it fails.")),
  persistRetryInterval: /*#__PURE__*/Config_.duration("persistRetryInterval").pipe(/*#__PURE__*/Config_.withDefault(Config.defaults.persistRetryInterval), /*#__PURE__*/Config_.withDescription("The interval on which persistence of runners will be retried if it fails.")),
  runnerHealthCheckInterval: /*#__PURE__*/Config_.duration("runnerHealthCheckInterval").pipe(/*#__PURE__*/Config_.withDefault(Config.defaults.runnerHealthCheckInterval), /*#__PURE__*/Config_.withDescription("The interval on which runner health will be checked.")),
  runnerPingTimeout: /*#__PURE__*/Config_.duration("runnerPingTimeout").pipe(/*#__PURE__*/Config_.withDefault(Config.defaults.runnerPingTimeout), /*#__PURE__*/Config_.withDescription("The length of time to wait for a runner to respond to a ping."))
});
/**
 * @since 1.0.0
 * @category Config
 */
const configFromEnv = exports.configFromEnv = /*#__PURE__*/configConfig.pipe(/*#__PURE__*/Effect.withConfigProvider(/*#__PURE__*/ConfigProvider.fromEnv().pipe(ConfigProvider.constantCase)));
/**
 * @since 1.0.0
 * @category Config
 */
const layerConfig = config => Layer.succeed(Config, {
  ...Config.defaults,
  ...config
});
/**
 * @since 1.0.0
 * @category Config
 */
exports.layerConfig = layerConfig;
const layerConfigFromEnv = exports.layerConfigFromEnv = /*#__PURE__*/Layer.effect(Config, configFromEnv);
/**
 * Represents a client which can be used to communicate with the
 * `ShardManager`.
 *
 * @since 1.0.0
 * @category Client
 */
class ShardManagerClient extends /*#__PURE__*/Context.Tag("@effect/cluster/ShardManager/ShardManagerClient")() {}
/**
 * @since 1.0.0
 * @category models
 */
exports.ShardManagerClient = ShardManagerClient;
const ShardingEventSchema = exports.ShardingEventSchema = /*#__PURE__*/Schema.Union(/*#__PURE__*/Schema.TaggedStruct("StreamStarted", {}), /*#__PURE__*/Schema.TaggedStruct("ShardsAssigned", {
  address: _RunnerAddress.RunnerAddress,
  shards: /*#__PURE__*/Schema.Array(_ShardId.ShardId)
}), /*#__PURE__*/Schema.TaggedStruct("ShardsUnassigned", {
  address: _RunnerAddress.RunnerAddress,
  shards: /*#__PURE__*/Schema.Array(_ShardId.ShardId)
}), /*#__PURE__*/Schema.TaggedStruct("RunnerRegistered", {
  address: _RunnerAddress.RunnerAddress
}), /*#__PURE__*/Schema.TaggedStruct("RunnerUnregistered", {
  address: _RunnerAddress.RunnerAddress
}));
/**
 * The messaging protocol for the `ShardManager`.
 *
 * @since 1.0.0
 * @category Rpcs
 */
class Rpcs extends /*#__PURE__*/RpcGroup.make(/*#__PURE__*/Rpc.make("Register", {
  payload: {
    runner: _Runner.Runner
  },
  success: MachineId.MachineId
}), /*#__PURE__*/Rpc.make("Unregister", {
  payload: {
    address: _RunnerAddress.RunnerAddress
  }
}), /*#__PURE__*/Rpc.make("NotifyUnhealthyRunner", {
  payload: {
    address: _RunnerAddress.RunnerAddress
  }
}), /*#__PURE__*/Rpc.make("GetAssignments", {
  success: /*#__PURE__*/Schema.ReadonlyMap({
    key: _ShardId.ShardId,
    value: /*#__PURE__*/Schema.Option(_RunnerAddress.RunnerAddress)
  })
}), /*#__PURE__*/Rpc.make("ShardingEvents", {
  success: ShardingEventSchema,
  stream: true
}), /*#__PURE__*/Rpc.make("GetTime", {
  success: Schema.Number
})) {}
/**
 * @since 1.0.0
 * @category models
 */
exports.Rpcs = Rpcs;
const ShardingEvent = exports.ShardingEvent = /*#__PURE__*/Data.taggedEnum();
/**
 * @since 1.0.0
 * @category Client
 */
const makeClientLocal = exports.makeClientLocal = /*#__PURE__*/Effect.gen(function* () {
  const runnerAddress = yield* _ShardingConfig.ShardingConfig;
  const clock = yield* Effect.clock;
  const shards = new Map();
  for (let n = 1; n <= runnerAddress.numberOfShards; n++) {
    shards.set(_ShardId.ShardId.make(n), runnerAddress.runnerAddress);
  }
  let machineId = 0;
  return ShardManagerClient.of({
    register: () => Effect.sync(() => MachineId.make(++machineId)),
    unregister: () => Effect.void,
    notifyUnhealthyRunner: () => Effect.void,
    getAssignments: Effect.succeed(shards),
    shardingEvents: Effect.gen(function* () {
      const mailbox = yield* Mailbox.make();
      yield* mailbox.offer(ShardingEvent.StreamStarted());
      return mailbox;
    }),
    getTime: clock.currentTimeMillis
  });
});
/**
 * @since 1.0.0
 * @category Client
 */
const makeClientRpc = exports.makeClientRpc = /*#__PURE__*/Effect.gen(function* () {
  const config = yield* _ShardingConfig.ShardingConfig;
  const client = yield* RpcClient.make(Rpcs, {
    spanPrefix: "ShardManagerClient",
    disableTracing: true
  });
  return ShardManagerClient.of({
    register: address => client.Register({
      runner: _Runner.Runner.make({
        address,
        version: config.serverVersion
      })
    }),
    unregister: address => client.Unregister({
      address
    }),
    notifyUnhealthyRunner: address => client.NotifyUnhealthyRunner({
      address
    }),
    getAssignments: client.GetAssignments(),
    shardingEvents: client.ShardingEvents({}, {
      asMailbox: true
    }),
    getTime: client.GetTime()
  });
});
/**
 * @since 1.0.0
 * @category Client
 */
const layerClientLocal = exports.layerClientLocal = /*#__PURE__*/Layer.effect(ShardManagerClient, makeClientLocal);
/**
 * @since 1.0.0
 * @category Client
 */
const layerClientRpc = exports.layerClientRpc = /*#__PURE__*/Layer.scoped(ShardManagerClient, makeClientRpc).pipe(/*#__PURE__*/Layer.provide(/*#__PURE__*/Layer.scoped(RpcClient.Protocol, /*#__PURE__*/Effect.gen(function* () {
  const config = yield* _ShardingConfig.ShardingConfig;
  const clientProtocol = yield* _Runners.RpcClientProtocol;
  return yield* clientProtocol(config.shardManagerAddress);
}))));
/**
 * @since 1.0.0
 * @category Constructors
 */
const make = exports.make = /*#__PURE__*/Effect.gen(function* () {
  const storage = yield* _ShardStorage.ShardStorage;
  const runnersApi = yield* _Runners.Runners;
  const runnerHealthApi = yield* _RunnerHealth.RunnerHealth;
  const clock = yield* Effect.clock;
  const config = yield* Config;
  const shardingConfig = yield* _ShardingConfig.ShardingConfig;
  const state = yield* Effect.orDie(_shardManager.State.fromStorage(shardingConfig.numberOfShards));
  const scope = yield* Effect.scope;
  const events = yield* PubSub.unbounded();
  yield* Metric.incrementBy(ClusterMetrics.runners, MutableHashMap.size(state.runners));
  for (const address of state.shards.values()) {
    const metric = Option.isSome(address) ? Metric.tagged(ClusterMetrics.assignedShards, "address", address.toString()) : ClusterMetrics.unassignedShards;
    yield* Metric.increment(metric);
  }
  function withRetry(effect) {
    return effect.pipe(Effect.retry({
      schedule: Schedule.spaced(config.persistRetryCount),
      times: config.persistRetryCount
    }), Effect.ignore);
  }
  const persistRunners = Effect.unsafeMakeSemaphore(1).withPermits(1)(withRetry(Effect.suspend(() => storage.saveRunners(Iterable.map(state.runners, ([address, runner]) => [address, runner.runner])))));
  const persistAssignments = Effect.unsafeMakeSemaphore(1).withPermits(1)(withRetry(Effect.suspend(() => storage.saveAssignments(state.shards))));
  const notifyUnhealthyRunner = Effect.fnUntraced(function* (address) {
    if (!MutableHashMap.has(state.runners, address)) return;
    yield* Metric.increment(Metric.tagged(ClusterMetrics.runnerHealthChecked, "runner_address", address.toString()));
    if (!(yield* runnerHealthApi.isAlive(address))) {
      yield* Effect.logWarning(`Runner at address '${address.toString()}' is not alive`);
      yield* unregister(address);
    }
  });
  function updateShardsState(shards, address) {
    return Effect.suspend(() => {
      if (Option.isSome(address) && !MutableHashMap.has(state.runners, address.value)) {
        return Effect.fail(new _ClusterError.RunnerNotRegistered({
          address: address.value
        }));
      }
      for (const shardId of shards) {
        if (!state.shards.has(shardId)) continue;
        state.shards.set(shardId, address);
      }
      return Effect.void;
    });
  }
  const getAssignments = Effect.sync(() => state.shards);
  let machineId = 0;
  const register = Effect.fnUntraced(function* (runner) {
    yield* Effect.logInfo(`Registering runner ${_Runner.Runner.pretty(runner)}`);
    const now = clock.unsafeCurrentTimeMillis();
    MutableHashMap.set(state.runners, runner.address, (0, _shardManager.RunnerWithMetadata)({
      runner,
      registeredAt: now
    }));
    yield* Metric.increment(ClusterMetrics.runners);
    yield* PubSub.publish(events, ShardingEvent.RunnerRegistered({
      address: runner.address
    }));
    if (state.unassignedShards.length > 0) {
      yield* rebalance(false);
    }
    yield* Effect.forkIn(persistRunners, scope);
    return MachineId.make(++machineId);
  });
  const unregister = Effect.fnUntraced(function* (address) {
    if (!MutableHashMap.has(state.runners, address)) return;
    yield* Effect.logInfo("Unregistering runner at address:", address);
    const unassignments = Arr.empty();
    for (const [shard, runner] of state.shards) {
      if (Option.isSome(runner) && Equal.equals(runner.value, address)) {
        unassignments.push(shard);
        state.shards.set(shard, Option.none());
      }
    }
    MutableHashMap.remove(state.runners, address);
    yield* Metric.incrementBy(ClusterMetrics.runners, -1);
    if (unassignments.length > 0) {
      yield* Metric.incrementBy(Metric.tagged(ClusterMetrics.unassignedShards, "runner_address", address.toString()), unassignments.length);
      yield* PubSub.publish(events, ShardingEvent.RunnerUnregistered({
        address
      }));
    }
    yield* Effect.forkIn(persistRunners, scope);
    yield* Effect.forkIn(rebalance(true), scope);
  });
  let rebalancing = false;
  let nextRebalanceImmediate = false;
  let rebalanceDeferred;
  const rebalanceFibers = yield* FiberSet.make();
  const rebalance = immmediate => Effect.withFiberRuntime(fiber => {
    if (!rebalancing) {
      rebalancing = true;
      return rebalanceLoop(immmediate);
    }
    if (immmediate) {
      nextRebalanceImmediate = true;
    }
    if (!rebalanceDeferred) {
      rebalanceDeferred = Deferred.unsafeMake(fiber.id());
    }
    return Deferred.await(rebalanceDeferred);
  });
  const rebalanceLoop = immediate => Effect.suspend(() => {
    const deferred = rebalanceDeferred;
    rebalanceDeferred = undefined;
    if (!immediate) {
      immediate = nextRebalanceImmediate;
      nextRebalanceImmediate = false;
    }
    return runRebalance(immediate).pipe(deferred ? Effect.intoDeferred(deferred) : _Function.identity, Effect.onExit(() => {
      if (!rebalanceDeferred) {
        rebalancing = false;
        return Effect.void;
      }
      return Effect.forkIn(rebalanceLoop(), scope);
    }));
  });
  const runRebalance = Effect.fn("ShardManager.rebalance")(function* (immediate) {
    yield* Effect.annotateCurrentSpan("immmediate", immediate);
    yield* Effect.sleep(config.rebalanceDebounce);
    // Determine which shards to assign and unassign
    const [assignments, unassignments, changes] = immediate || state.unassignedShards.length > 0 ? (0, _shardManager.decideAssignmentsForUnassignedShards)(state) : (0, _shardManager.decideAssignmentsForUnbalancedShards)(state, config.rebalanceRate);
    yield* Effect.logDebug(`Rebalancing shards (immediate = ${immediate})`);
    if (MutableHashSet.size(changes) === 0) return;
    yield* Metric.increment(ClusterMetrics.rebalances);
    // Ping runners first and remove unhealthy ones
    const failedRunners = MutableHashSet.empty();
    for (const address of changes) {
      yield* FiberSet.run(rebalanceFibers, runnersApi.ping(address).pipe(Effect.timeout(config.runnerPingTimeout), Effect.catchAll(() => {
        MutableHashSet.add(failedRunners, address);
        MutableHashMap.remove(assignments, address);
        MutableHashMap.remove(unassignments, address);
        return Effect.void;
      })));
    }
    yield* FiberSet.awaitEmpty(rebalanceFibers);
    const failedUnassignments = new Set();
    for (const [address, shards] of unassignments) {
      yield* FiberSet.run(rebalanceFibers, updateShardsState(shards, Option.none()).pipe(Effect.matchEffect({
        onFailure: () => {
          MutableHashSet.add(failedRunners, address);
          for (const shard of shards) {
            failedUnassignments.add(shard);
          }
          // Remove failed runners from the assignments
          MutableHashMap.remove(assignments, address);
          return Effect.void;
        },
        onSuccess: () => {
          const shardCount = shards.size;
          return Metric.incrementBy(Metric.tagged(ClusterMetrics.assignedShards, "runner_address", address.toString()), -shardCount).pipe(Effect.zipRight(Metric.incrementBy(ClusterMetrics.unassignedShards, shardCount)), Effect.zipRight(PubSub.publish(events, ShardingEvent.ShardsUnassigned({
            address,
            shards: Array.from(shards)
          }))));
        }
      })));
    }
    yield* FiberSet.awaitEmpty(rebalanceFibers);
    // Remove failed shard unassignments from the assignments
    MutableHashMap.forEach(assignments, (shards, address) => {
      for (const shard of failedUnassignments) {
        shards.delete(shard);
      }
      if (shards.size === 0) {
        MutableHashMap.remove(assignments, address);
      }
    });
    // Perform the assignments
    for (const [address, shards] of assignments) {
      yield* FiberSet.run(rebalanceFibers, updateShardsState(shards, Option.some(address)).pipe(Effect.matchEffect({
        onFailure: () => {
          MutableHashSet.add(failedRunners, address);
          return Effect.void;
        },
        onSuccess: () => {
          const shardCount = shards.size;
          return Metric.incrementBy(Metric.tagged(ClusterMetrics.assignedShards, "runner_address", address.toString()), -shardCount).pipe(Effect.zipRight(Metric.incrementBy(ClusterMetrics.unassignedShards, -shardCount)), Effect.zipRight(PubSub.publish(events, ShardingEvent.ShardsAssigned({
            address,
            shards: Array.from(shards)
          }))));
        }
      })));
    }
    yield* FiberSet.awaitEmpty(rebalanceFibers);
    const wereFailures = MutableHashSet.size(failedRunners) > 0;
    if (wereFailures) {
      // Check if the failing runners are still reachable
      yield* Effect.forEach(failedRunners, notifyUnhealthyRunner, {
        discard: true
      }).pipe(Effect.forkIn(scope));
      yield* Effect.logWarning("Failed to rebalance runners: ", failedRunners);
    }
    if (wereFailures && immediate) {
      // Try rebalancing again later if there were any failures
      yield* Clock.sleep(config.rebalanceRetryInterval).pipe(Effect.zipRight(rebalance(immediate)), Effect.forkIn(scope));
    }
    yield* persistAssignments;
  });
  const checkRunnerHealth = Effect.suspend(() => Effect.forEach(MutableHashMap.keys(state.runners), notifyUnhealthyRunner, {
    concurrency: 10,
    discard: true
  }));
  yield* Effect.addFinalizer(() => persistAssignments.pipe(Effect.catchAllCause(cause => Effect.logWarning("Failed to persist assignments on shutdown", cause)), Effect.zipRight(persistRunners.pipe(Effect.catchAllCause(cause => Effect.logWarning("Failed to persist runners on shutdown", cause))))));
  yield* Effect.forkIn(persistRunners, scope);
  // Rebalance immediately if there are unassigned shards
  yield* Effect.forkIn(rebalance(state.unassignedShards.length > 0), scope);
  // Start a regular cluster rebalance at the configured interval
  yield* rebalance(false).pipe(Effect.andThen(Effect.sleep(config.rebalanceInterval)), Effect.forever, Effect.forkIn(scope));
  yield* checkRunnerHealth.pipe(Effect.andThen(Effect.sleep(config.runnerHealthCheckInterval)), Effect.forever, Effect.forkIn(scope));
  yield* Effect.gen(function* () {
    const queue = yield* PubSub.subscribe(events);
    while (true) {
      yield* Effect.logInfo("Shard manager event:", yield* Queue.take(queue));
    }
  }).pipe(Effect.forkIn(scope));
  yield* Effect.logInfo("Shard manager initialized");
  return ShardManager.of({
    getAssignments,
    shardingEvents: PubSub.subscribe(events),
    register,
    unregister,
    rebalance,
    notifyUnhealthyRunner,
    checkRunnerHealth
  });
});
/**
 * @since 1.0.0
 * @category layer
 */
const layer = exports.layer = /*#__PURE__*/Layer.scoped(ShardManager, make);
/**
 * @since 1.0.0
 * @category Server
 */
const layerServerHandlers = exports.layerServerHandlers = /*#__PURE__*/Rpcs.toLayer(/*#__PURE__*/Effect.gen(function* () {
  const shardManager = yield* ShardManager;
  const clock = yield* Effect.clock;
  return {
    Register: ({
      runner
    }) => shardManager.register(runner),
    Unregister: ({
      address
    }) => shardManager.unregister(address),
    NotifyUnhealthyRunner: ({
      address
    }) => shardManager.notifyUnhealthyRunner(address),
    GetAssignments: () => shardManager.getAssignments,
    ShardingEvents: Effect.fnUntraced(function* () {
      const queue = yield* shardManager.shardingEvents;
      const mailbox = yield* Mailbox.make();
      yield* mailbox.offer(ShardingEvent.StreamStarted());
      yield* Queue.takeBetween(queue, 1, Number.MAX_SAFE_INTEGER).pipe(Effect.flatMap(events => mailbox.offerAll(events)), Effect.forever, Effect.forkScoped);
      return mailbox;
    }),
    GetTime: () => clock.currentTimeMillis
  };
}));
/**
 * @since 1.0.0
 * @category Server
 */
const layerServer = exports.layerServer = /*#__PURE__*/RpcServer.layer(Rpcs, {
  spanPrefix: "ShardManager",
  disableTracing: true
}).pipe(/*#__PURE__*/Layer.provide(layerServerHandlers));
//# sourceMappingURL=ShardManager.js.map