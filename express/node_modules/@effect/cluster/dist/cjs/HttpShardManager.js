"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toHttpAppWebsocket = exports.toHttpApp = exports.layerWebsocketOptions = exports.layerWebsocket = exports.layerRunnerHealthWebsocket = exports.layerRunnerHealthHttp = exports.layerNoServerWebsocket = exports.layerNoServerHttp = exports.layerHttpOptions = exports.layerHttp = void 0;
var HttpRouter = _interopRequireWildcard(require("@effect/platform/HttpRouter"));
var HttpServer = _interopRequireWildcard(require("@effect/platform/HttpServer"));
var RpcServer = _interopRequireWildcard(require("@effect/rpc/RpcServer"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var _Function = require("effect/Function");
var Layer = _interopRequireWildcard(require("effect/Layer"));
var _HttpCommon = require("./HttpCommon.js");
var MessageStorage = _interopRequireWildcard(require("./MessageStorage.js"));
var RunnerHealth = _interopRequireWildcard(require("./RunnerHealth.js"));
var Runners = _interopRequireWildcard(require("./Runners.js"));
var ShardManager = _interopRequireWildcard(require("./ShardManager.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 * @category Http App
 */
const toHttpApp = exports.toHttpApp = /*#__PURE__*/Effect.gen(function* () {
  const handlers = yield* Layer.build(ShardManager.layerServerHandlers);
  return yield* RpcServer.toHttpApp(ShardManager.Rpcs).pipe(Effect.provide(handlers));
});
/**
 * @since 1.0.0
 * @category Http App
 */
const toHttpAppWebsocket = exports.toHttpAppWebsocket = /*#__PURE__*/Effect.gen(function* () {
  const handlers = yield* Layer.build(ShardManager.layerServerHandlers);
  return yield* RpcServer.toHttpAppWebsocket(ShardManager.Rpcs).pipe(Effect.provide(handlers));
});
/**
 * A layer for the `ShardManager` service, that does not run a server.
 *
 * It only provides the `Runners` rpc client.
 *
 * You can use this with the `toHttpApp` and `toHttpAppWebsocket` apis
 * to run a complete `ShardManager` server.
 *
 * @since 1.0.0
 * @category Layers
 */
const layerNoServerHttp = options => ShardManager.layer.pipe(Layer.provide(Runners.layerRpc.pipe(Layer.provide([(0, _HttpCommon.layerClientProtocolHttp)({
  path: options.runnerPath,
  https: options.runnerHttps
}), MessageStorage.layerNoop]))));
/**
 * A layer for the `ShardManager` service, that does not run a server.
 *
 * It only provides the `Runners` rpc client.
 *
 * You can use this with the `toHttpApp` and `toHttpAppWebsocket` apis
 * to run a complete `ShardManager` server.
 *
 * @since 1.0.0
 * @category Layers
 */
exports.layerNoServerHttp = layerNoServerHttp;
const layerNoServerWebsocket = options => ShardManager.layer.pipe(Layer.provide(Runners.layerRpc.pipe(Layer.provide([(0, _HttpCommon.layerClientProtocolWebsocket)({
  path: options.runnerPath,
  https: options.runnerHttps
}), MessageStorage.layerNoop]))));
/**
 * A HTTP layer for the `ShardManager` server, that adds a route to the provided
 * `HttpRouter.Tag`.
 *
 * By default, it uses the `HttpRouter.Default` tag.
 *
 * @since 1.0.0
 * @category Layers
 */
exports.layerNoServerWebsocket = layerNoServerWebsocket;
const layerHttpOptions = options => {
  const routerTag = options.routerTag ?? HttpRouter.Default;
  return routerTag.serve().pipe(options.logAddress ? withLogAddress : _Function.identity, Layer.merge(ShardManager.layerServer), Layer.provide(RpcServer.layerProtocolHttp(options)), Layer.provideMerge(layerNoServerHttp(options)));
};
/**
 * A WebSocket layer for the `ShardManager` server, that adds a route to the provided
 * `HttpRouter.Tag`.
 *
 * By default, it uses the `HttpRouter.Default` tag.
 *
 * @since 1.0.0
 * @category Layers
 */
exports.layerHttpOptions = layerHttpOptions;
const layerWebsocketOptions = options => {
  const routerTag = options.routerTag ?? HttpRouter.Default;
  return routerTag.serve().pipe(options.logAddress ? withLogAddress : _Function.identity, Layer.merge(ShardManager.layerServer), Layer.provide(RpcServer.layerProtocolWebsocket(options)), Layer.provideMerge(layerNoServerWebsocket(options)));
};
exports.layerWebsocketOptions = layerWebsocketOptions;
const withLogAddress = layer => Layer.effectDiscard(HttpServer.addressFormattedWith(address => Effect.annotateLogs(Effect.logInfo(`Listening on: ${address}`), {
  package: "@effect/cluster",
  service: "ShardManager"
}))).pipe(Layer.provideMerge(layer));
/**
 * A HTTP layer for the `ShardManager` server, that adds a route to the provided
 * `HttpRouter.Tag`.
 *
 * By default, it uses the `HttpRouter.Default` tag.
 *
 * @since 1.0.0
 * @category Layers
 */
const layerHttp = exports.layerHttp = /*#__PURE__*/layerHttpOptions({
  path: "/",
  runnerPath: "/"
});
/**
 * A Websocket layer for the `ShardManager` server, that adds a route to the provided
 * `HttpRouter.Tag`.
 *
 * By default, it uses the `HttpRouter.Default` tag.
 *
 * @since 1.0.0
 * @category Layers
 */
const layerWebsocket = exports.layerWebsocket = /*#__PURE__*/layerWebsocketOptions({
  path: "/",
  runnerPath: "/"
});
/**
 * @since 1.0.0
 * @category Layers
 */
const layerRunnerHealthHttp = exports.layerRunnerHealthHttp = /*#__PURE__*/Layer.provide(RunnerHealth.layerRpc, /*#__PURE__*/(0, _HttpCommon.layerClientProtocolHttp)({
  path: "/"
}));
/**
 * @since 1.0.0
 * @category Layers
 */
const layerRunnerHealthWebsocket = exports.layerRunnerHealthWebsocket = /*#__PURE__*/Layer.provide(RunnerHealth.layerRpc, /*#__PURE__*/(0, _HttpCommon.layerClientProtocolWebsocket)({
  path: "/"
}));
//# sourceMappingURL=HttpShardManager.js.map