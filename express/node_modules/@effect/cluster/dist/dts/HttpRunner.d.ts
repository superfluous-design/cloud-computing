/**
 * @since 1.0.0
 */
import type * as HttpApp from "@effect/platform/HttpApp";
import type * as HttpClient from "@effect/platform/HttpClient";
import * as HttpRouter from "@effect/platform/HttpRouter";
import * as HttpServer from "@effect/platform/HttpServer";
import type * as Socket from "@effect/platform/Socket";
import type * as RpcSerialization from "@effect/rpc/RpcSerialization";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import type { Scope } from "effect/Scope";
import type { MessageStorage } from "./MessageStorage.js";
import * as Runners from "./Runners.js";
import * as Sharding from "./Sharding.js";
import type * as ShardingConfig from "./ShardingConfig.js";
import type { ShardStorage } from "./ShardStorage.js";
/**
 * @since 1.0.0
 * @category Http App
 */
export declare const toHttpApp: Effect.Effect<HttpApp.Default<never, Scope>, never, Scope | Sharding.Sharding | RpcSerialization.RpcSerialization | MessageStorage>;
/**
 * @since 1.0.0
 * @category Http App
 */
export declare const toHttpAppWebsocket: Effect.Effect<HttpApp.Default<never, Scope>, never, Scope | Sharding.Sharding | RpcSerialization.RpcSerialization | MessageStorage>;
/**
 * @since 1.0.0
 * @category Layers
 */
export declare const layerClient: Layer.Layer<Sharding.Sharding | Runners.Runners, never, ShardingConfig.ShardingConfig | Runners.RpcClientProtocol | MessageStorage | ShardStorage>;
/**
 * A HTTP layer for the `Runners` services, that adds a route to the provided
 * `HttpRouter.Tag`.
 *
 * By default, it uses the `HttpRouter.Default` tag.
 *
 * @since 1.0.0
 * @category Layers
 */
export declare const layer: <I = HttpRouter.Default>(options: {
    readonly path: HttpRouter.PathInput;
    readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>;
    readonly logAddress?: boolean | undefined;
}) => Layer.Layer<Sharding.Sharding | Runners.Runners, never, RpcSerialization.RpcSerialization | ShardingConfig.ShardingConfig | Runners.RpcClientProtocol | HttpServer.HttpServer | MessageStorage | ShardStorage>;
/**
 * @since 1.0.0
 * @category Layers
 */
export declare const layerWebsocketOptions: <I = HttpRouter.Default>(options: {
    readonly path: HttpRouter.PathInput;
    readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>;
    readonly logAddress?: boolean | undefined;
}) => Layer.Layer<Sharding.Sharding | Runners.Runners, never, RpcSerialization.RpcSerialization | ShardingConfig.ShardingConfig | Runners.RpcClientProtocol | HttpServer.HttpServer | MessageStorage | ShardStorage>;
/**
 * @since 1.0.0
 * @category Layers
 */
export declare const layerHttp: Layer.Layer<Sharding.Sharding | Runners.Runners, never, RpcSerialization.RpcSerialization | ShardingConfig.ShardingConfig | HttpClient.HttpClient | HttpServer.HttpServer | MessageStorage | ShardStorage>;
/**
 * @since 1.0.0
 * @category Layers
 */
export declare const layerHttpClientOnly: Layer.Layer<Sharding.Sharding | Runners.Runners, never, RpcSerialization.RpcSerialization | ShardingConfig.ShardingConfig | HttpClient.HttpClient | MessageStorage>;
/**
 * @since 1.0.0
 * @category Layers
 */
export declare const layerWebsocket: Layer.Layer<Sharding.Sharding | Runners.Runners, never, RpcSerialization.RpcSerialization | ShardingConfig.ShardingConfig | Socket.WebSocketConstructor | HttpServer.HttpServer | MessageStorage | ShardStorage>;
/**
 * @since 1.0.0
 * @category Layers
 */
export declare const layerWebsocketClientOnly: Layer.Layer<Sharding.Sharding | Runners.Runners, never, ShardingConfig.ShardingConfig | MessageStorage | RpcSerialization.RpcSerialization | Socket.WebSocketConstructor>;
//# sourceMappingURL=HttpRunner.d.ts.map