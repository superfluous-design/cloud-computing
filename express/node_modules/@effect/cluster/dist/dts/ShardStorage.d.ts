/**
 * @since 1.0.0
 */
import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import type { PersistenceError } from "./ClusterError.js";
import { Runner } from "./Runner.js";
import { RunnerAddress } from "./RunnerAddress.js";
import { ShardId } from "./ShardId.js";
declare const ShardStorage_base: Context.TagClass<ShardStorage, "@effect/cluster/ShardStorage", {
    /**
     * Get the current assignments of shards to runners.
     */
    readonly getAssignments: Effect.Effect<ReadonlyMap<ShardId, Option.Option<RunnerAddress>>, PersistenceError>;
    /**
     * Save the current state of shards assignments to runners.
     */
    readonly saveAssignments: (assignments: Iterable<readonly [ShardId, Option.Option<RunnerAddress>]>) => Effect.Effect<void, PersistenceError>;
    /**
     * Get all runners registered with the cluster.
     */
    readonly getRunners: Effect.Effect<Array<[RunnerAddress, Runner]>, PersistenceError>;
    /**
     * Save the current runners registered with the cluster.
     */
    readonly saveRunners: (runners: Iterable<readonly [RunnerAddress, Runner]>) => Effect.Effect<void, PersistenceError>;
    /**
     * Try to acquire the given shard ids for processing.
     *
     * It returns an array of shards it was able to acquire.
     */
    readonly acquire: (address: RunnerAddress, shardIds: Iterable<ShardId>) => Effect.Effect<Array<ShardId>, PersistenceError>;
    /**
     * Refresh the locks owned by the given runner.
     *
     * Locks expire after 15 seconds, so this method should be called every 10
     * seconds to keep the locks alive.
     */
    readonly refresh: (address: RunnerAddress, shardIds: Iterable<ShardId>) => Effect.Effect<Array<ShardId>, PersistenceError>;
    /**
     * Release the given shard ids.
     */
    readonly release: (address: RunnerAddress, shardId: ShardId) => Effect.Effect<void, PersistenceError>;
    /**
     * Release all the shards assigned to the given runner.
     */
    readonly releaseAll: (address: RunnerAddress) => Effect.Effect<void, PersistenceError>;
}>;
/**
 * Represents a generic interface to the persistent storage required by the
 * cluster.
 *
 * @since 1.0.0
 * @category models
 */
export declare class ShardStorage extends ShardStorage_base {
}
/**
 * @since 1.0.0
 * @category Encoded
 */
export interface Encoded {
    /**
     * Get the current assignments of shards to runners.
     */
    readonly getAssignments: Effect.Effect<Array<readonly [
        shardId: number,
        runnerAddress: string | null
    ]>, PersistenceError>;
    /**
     * Save the current state of shards assignments to runners.
     */
    readonly saveAssignments: (assignments: Array<readonly [shardId: number, RunnerAddress: string | null]>) => Effect.Effect<void, PersistenceError>;
    /**
     * Get all runners registered with the cluster.
     */
    readonly getRunners: Effect.Effect<Array<readonly [address: string, runner: string]>, PersistenceError>;
    /**
     * Save the current runners registered with the cluster.
     */
    readonly saveRunners: (runners: Array<readonly [address: string, runner: string]>) => Effect.Effect<void, PersistenceError>;
    /**
     * Acquire the lock on the given shards, returning the shards that were
     * successfully locked.
     */
    readonly acquire: (address: string, shardIds: ReadonlyArray<number>) => Effect.Effect<Array<number>, PersistenceError>;
    /**
     * Refresh the lock on the given shards, returning the shards that were
     * successfully locked.
     */
    readonly refresh: (address: string, shardIds: ReadonlyArray<number>) => Effect.Effect<Array<number>, PersistenceError>;
    /**
     * Release the lock on the given shards.
     */
    readonly release: (address: string, shardIds: number) => Effect.Effect<void, PersistenceError>;
    /**
     * Release the lock on all shards for the given runner.
     */
    readonly releaseAll: (address: string) => Effect.Effect<void, PersistenceError>;
}
/**
 * @since 1.0.0
 * @category layers
 */
export declare const makeEncoded: (this: unknown, encoded: Encoded) => Effect.Effect<{
    /**
     * Get the current assignments of shards to runners.
     */
    readonly getAssignments: Effect.Effect<ReadonlyMap<ShardId, Option.Option<RunnerAddress>>, PersistenceError>;
    /**
     * Save the current state of shards assignments to runners.
     */
    readonly saveAssignments: (assignments: Iterable<readonly [ShardId, Option.Option<RunnerAddress>]>) => Effect.Effect<void, PersistenceError>;
    /**
     * Get all runners registered with the cluster.
     */
    readonly getRunners: Effect.Effect<Array<[RunnerAddress, Runner]>, PersistenceError>;
    /**
     * Save the current runners registered with the cluster.
     */
    readonly saveRunners: (runners: Iterable<readonly [RunnerAddress, Runner]>) => Effect.Effect<void, PersistenceError>;
    /**
     * Try to acquire the given shard ids for processing.
     *
     * It returns an array of shards it was able to acquire.
     */
    readonly acquire: (address: RunnerAddress, shardIds: Iterable<ShardId>) => Effect.Effect<Array<ShardId>, PersistenceError>;
    /**
     * Refresh the locks owned by the given runner.
     *
     * Locks expire after 15 seconds, so this method should be called every 10
     * seconds to keep the locks alive.
     */
    readonly refresh: (address: RunnerAddress, shardIds: Iterable<ShardId>) => Effect.Effect<Array<ShardId>, PersistenceError>;
    /**
     * Release the given shard ids.
     */
    readonly release: (address: RunnerAddress, shardId: ShardId) => Effect.Effect<void, PersistenceError>;
    /**
     * Release all the shards assigned to the given runner.
     */
    readonly releaseAll: (address: RunnerAddress) => Effect.Effect<void, PersistenceError>;
}, never, never>;
/**
 * @since 1.0.0
 * @category layers
 */
export declare const layerNoop: Layer.Layer<ShardStorage>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const makeMemory: Effect.Effect<{
    /**
     * Get the current assignments of shards to runners.
     */
    readonly getAssignments: Effect.Effect<ReadonlyMap<ShardId, Option.Option<RunnerAddress>>, PersistenceError>;
    /**
     * Save the current state of shards assignments to runners.
     */
    readonly saveAssignments: (assignments: Iterable<readonly [ShardId, Option.Option<RunnerAddress>]>) => Effect.Effect<void, PersistenceError>;
    /**
     * Get all runners registered with the cluster.
     */
    readonly getRunners: Effect.Effect<Array<[RunnerAddress, Runner]>, PersistenceError>;
    /**
     * Save the current runners registered with the cluster.
     */
    readonly saveRunners: (runners: Iterable<readonly [RunnerAddress, Runner]>) => Effect.Effect<void, PersistenceError>;
    /**
     * Try to acquire the given shard ids for processing.
     *
     * It returns an array of shards it was able to acquire.
     */
    readonly acquire: (address: RunnerAddress, shardIds: Iterable<ShardId>) => Effect.Effect<Array<ShardId>, PersistenceError>;
    /**
     * Refresh the locks owned by the given runner.
     *
     * Locks expire after 15 seconds, so this method should be called every 10
     * seconds to keep the locks alive.
     */
    readonly refresh: (address: RunnerAddress, shardIds: Iterable<ShardId>) => Effect.Effect<Array<ShardId>, PersistenceError>;
    /**
     * Release the given shard ids.
     */
    readonly release: (address: RunnerAddress, shardId: ShardId) => Effect.Effect<void, PersistenceError>;
    /**
     * Release all the shards assigned to the given runner.
     */
    readonly releaseAll: (address: RunnerAddress) => Effect.Effect<void, PersistenceError>;
}, never, never>;
/**
 * @since 1.0.0
 * @category layers
 */
export declare const layerMemory: Layer.Layer<ShardStorage>;
export {};
//# sourceMappingURL=ShardStorage.d.ts.map