/**
 * @since 1.0.0
 */
import type * as Rpc from "@effect/rpc/Rpc";
import * as Context from "effect/Context";
import * as Data from "effect/Data";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import type { PersistenceError } from "./ClusterError.js";
import { MalformedMessage } from "./ClusterError.js";
import type { EntityAddress } from "./EntityAddress.js";
import * as Envelope from "./Envelope.js";
import * as Message from "./Message.js";
import * as Reply from "./Reply.js";
import type { ShardId } from "./ShardId.js";
import type { ShardingConfig } from "./ShardingConfig.js";
import * as Snowflake from "./Snowflake.js";
declare const MessageStorage_base: Context.TagClass<MessageStorage, "@effect/cluster/MessageStorage", {
    /**
     * Save the provided message and its associated metadata.
     */
    readonly saveRequest: <R extends Rpc.Any>(envelope: Message.OutgoingRequest<R>) => Effect.Effect<SaveResult<R>, PersistenceError | MalformedMessage>;
    /**
     * Save the provided message and its associated metadata.
     */
    readonly saveEnvelope: (envelope: Message.OutgoingEnvelope) => Effect.Effect<void, PersistenceError | MalformedMessage>;
    /**
     * Save the provided `Reply` and its associated metadata.
     */
    readonly saveReply: <R extends Rpc.Any>(reply: Reply.ReplyWithContext<R>) => Effect.Effect<void, PersistenceError | MalformedMessage>;
    /**
     * Retrieves the replies for the specified requests.
     *
     * - Un-acknowledged chunk replies
     * - WithExit replies
     */
    readonly repliesFor: <R extends Rpc.Any>(requests: Iterable<Message.OutgoingRequest<R>>) => Effect.Effect<Array<Reply.Reply<R>>, PersistenceError | MalformedMessage>;
    /**
     * For locally sent messages, register a handler to process the replies.
     */
    readonly registerReplyHandler: <R extends Rpc.Any>(message: Message.OutgoingRequest<R> | Message.IncomingRequest<R>) => Effect.Effect<void>;
    /**
     * Retrieves the unprocessed messages for the specified shards.
     *
     * A message is unprocessed when:
     *
     * - Requests that have no WithExit replies
     *   - Or they have no unacknowledged chunk replies
     * - The latest AckChunk envelope
     * - All Interrupt's for unprocessed requests
     */
    readonly unprocessedMessages: (shardIds: Iterable<ShardId>) => Effect.Effect<Array<Message.Incoming<any>>, PersistenceError>;
    /**
     * Retrieves the unprocessed messages by id.
     */
    readonly unprocessedMessagesById: <R extends Rpc.Any>(messageIds: Iterable<Snowflake.Snowflake>) => Effect.Effect<Array<Message.Incoming<R>>, PersistenceError>;
    /**
     * Reset the mailbox state for the provided shards.
     */
    readonly resetShards: (shardIds: Iterable<ShardId>) => Effect.Effect<void, PersistenceError>;
    /**
     * Reset the mailbox state for the provided address.
     */
    readonly resetAddress: (address: EntityAddress) => Effect.Effect<void, PersistenceError>;
}>;
/**
 * @since 1.0.0
 * @category context
 */
export declare class MessageStorage extends MessageStorage_base {
}
/**
 * @since 1.0.0
 * @category SaveResult
 */
export type SaveResult<R extends Rpc.Any> = SaveResult.Success | SaveResult.Duplicate<R>;
/**
 * @since 1.0.0
 * @category SaveResult
 */
export declare const SaveResult: {
    readonly Success: <A>(args: void) => SaveResult.Success;
    readonly Duplicate: <A>(args: {
        readonly originalId: Snowflake.Snowflake;
        readonly lastReceivedReply: Option.Option<Reply.Reply<A extends Rpc.Any ? A : never>>;
    }) => SaveResult.Duplicate<A extends Rpc.Any ? A : never>;
    readonly $is: <Tag extends "Success" | "Duplicate">(tag: Tag) => {
        <T extends SaveResult<any>>(u: T): u is T & {
            readonly _tag: Tag;
        };
        (u: unknown): u is Extract<SaveResult.Success, {
            readonly _tag: Tag;
        }> | Extract<SaveResult.Duplicate<never>, {
            readonly _tag: Tag;
        }>;
    };
    readonly $match: {
        <A, B, C, D, Cases extends {
            readonly Success: (args: SaveResult.Success) => any;
            readonly Duplicate: (args: SaveResult.Duplicate<A extends Rpc.Any ? A : never>) => any;
        }>(cases: Cases): (self: SaveResult<A extends Rpc.Any ? A : never>) => import("effect/Unify").Unify<ReturnType<Cases["Success" | "Duplicate"]>>;
        <A, B, C, D, Cases extends {
            readonly Success: (args: SaveResult.Success) => any;
            readonly Duplicate: (args: SaveResult.Duplicate<A extends Rpc.Any ? A : never>) => any;
        }>(self: SaveResult<A extends Rpc.Any ? A : never>, cases: Cases): import("effect/Unify").Unify<ReturnType<Cases["Success" | "Duplicate"]>>;
    };
};
/**
 * @since 1.0.0
 * @category SaveResult
 */
export declare const SaveResultEncoded: {
    readonly Success: Data.Case.Constructor<SaveResult.Success, "_tag">;
    readonly Duplicate: Data.Case.Constructor<SaveResult.DuplicateEncoded, "_tag">;
    readonly $is: <Tag extends "Success" | "Duplicate">(tag: Tag) => (u: unknown) => u is Extract<SaveResult.Success, {
        readonly _tag: Tag;
    }> | Extract<SaveResult.DuplicateEncoded, {
        readonly _tag: Tag;
    }>;
    readonly $match: {
        <Cases extends {
            readonly Success: (args: SaveResult.Success) => any;
            readonly Duplicate: (args: SaveResult.DuplicateEncoded) => any;
        }>(cases: Cases): (value: SaveResult.Encoded) => import("effect/Unify").Unify<ReturnType<Cases["Success" | "Duplicate"]>>;
        <Cases extends {
            readonly Success: (args: SaveResult.Success) => any;
            readonly Duplicate: (args: SaveResult.DuplicateEncoded) => any;
        }>(value: SaveResult.Encoded, cases: Cases): import("effect/Unify").Unify<ReturnType<Cases["Success" | "Duplicate"]>>;
    };
};
/**
 * @since 1.0.0
 * @category SaveResult
 */
export declare namespace SaveResult {
    /**
     * @since 1.0.0
     * @category SaveResult
     */
    type Encoded = SaveResult.Success | SaveResult.DuplicateEncoded;
    /**
     * @since 1.0.0
     * @category SaveResult
     */
    interface Success {
        readonly _tag: "Success";
    }
    /**
     * @since 1.0.0
     * @category SaveResult
     */
    interface Duplicate<R extends Rpc.Any> {
        readonly _tag: "Duplicate";
        readonly originalId: Snowflake.Snowflake;
        readonly lastReceivedReply: Option.Option<Reply.Reply<R>>;
    }
    /**
     * @since 1.0.0
     * @category SaveResult
     */
    interface DuplicateEncoded {
        readonly _tag: "Duplicate";
        readonly originalId: Snowflake.Snowflake;
        readonly lastReceivedReply: Option.Option<Reply.ReplyEncoded<any>>;
    }
    /**
     * @since 1.0.0
     * @category SaveResult
     */
    interface Constructor extends Data.TaggedEnum.WithGenerics<1> {
        readonly taggedEnum: SaveResult<this["A"] extends Rpc.Any ? this["A"] : never>;
    }
}
/**
 * @since 1.0.0
 * @category Encoded
 */
export type Encoded = {
    /**
     * Save the provided message and its associated metadata.
     */
    readonly saveEnvelope: (options: {
        readonly envelope: Envelope.Envelope.Encoded;
        readonly primaryKey: string | null;
        readonly deliverAt: number | null;
    }) => Effect.Effect<SaveResult.Encoded, PersistenceError>;
    /**
     * Save the provided `Reply` and its associated metadata.
     */
    readonly saveReply: (reply: Reply.ReplyEncoded<any>) => Effect.Effect<void, PersistenceError>;
    /**
     * Retrieves the replies for the specified requests.
     *
     * - Un-acknowledged chunk replies
     * - WithExit replies
     */
    readonly repliesFor: (requestIds: Array<string>) => Effect.Effect<Array<Reply.ReplyEncoded<any>>, PersistenceError>;
    /**
     * Retrieves the unprocessed messages for the given shards.
     *
     * A message is unprocessed when:
     *
     * - Requests that have no WithExit replies
     *   - Or they have no unacknowledged chunk replies
     * - The latest AckChunk envelope
     * - All Interrupt's for unprocessed requests
     */
    readonly unprocessedMessages: (shardIds: ReadonlyArray<number>, now: number) => Effect.Effect<Array<{
        readonly envelope: Envelope.Envelope.Encoded;
        readonly lastSentReply: Option.Option<Reply.ReplyEncoded<any>>;
    }>, PersistenceError>;
    /**
     * Retrieves the unprocessed messages by id.
     */
    readonly unprocessedMessagesById: (messageIds: ReadonlyArray<Snowflake.Snowflake>, now: number) => Effect.Effect<Array<{
        readonly envelope: Envelope.Envelope.Encoded;
        readonly lastSentReply: Option.Option<Reply.ReplyEncoded<any>>;
    }>, PersistenceError>;
    /**
     * Reset the mailbox state for the provided address.
     */
    readonly resetAddress: (address: EntityAddress) => Effect.Effect<void, PersistenceError>;
    /**
     * Reset the mailbox state for the provided shards.
     */
    readonly resetShards: (shardIds: ReadonlyArray<number>) => Effect.Effect<void, PersistenceError>;
};
/**
 * @since 1.0.0
 * @category Encoded
 */
export type EncodedUnprocessedOptions<A> = {
    readonly existingShards: Array<number>;
    readonly newShards: Array<number>;
    readonly cursor: Option.Option<A>;
};
/**
 * @since 1.0.0
 * @category Encoded
 */
export type EncodedRepliesOptions<A> = {
    readonly existingRequests: Array<string>;
    readonly newRequests: Array<string>;
    readonly cursor: Option.Option<A>;
};
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const make: (storage: Omit<MessageStorage["Type"], "registerReplyHandler">) => Effect.Effect<MessageStorage["Type"]>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const makeEncoded: (encoded: Encoded) => Effect.Effect<MessageStorage["Type"], never, Snowflake.Generator>;
/**
 * @since 1.0.0
 * @category Constructors
 */
export declare const noop: MessageStorage["Type"];
/**
 * @since 1.0.0
 * @category Memory
 */
export type MemoryEntry = {
    readonly envelope: Envelope.Request.Encoded;
    lastReceivedChunk: Option.Option<Reply.ChunkEncoded<any>>;
    replies: Array<Reply.ReplyEncoded<any>>;
};
declare const MemoryDriver_base: Effect.Service.Class<MemoryDriver, "@effect/cluster/MessageStorage/MemoryDriver", {
    readonly dependencies: readonly [Layer.Layer<Snowflake.Generator, never, never>];
    readonly effect: Effect.Effect<{
        readonly storage: {
            /**
             * Save the provided message and its associated metadata.
             */
            readonly saveRequest: <R extends Rpc.Any>(envelope: Message.OutgoingRequest<R>) => Effect.Effect<SaveResult<R>, PersistenceError | MalformedMessage>;
            /**
             * Save the provided message and its associated metadata.
             */
            readonly saveEnvelope: (envelope: Message.OutgoingEnvelope) => Effect.Effect<void, PersistenceError | MalformedMessage>;
            /**
             * Save the provided `Reply` and its associated metadata.
             */
            readonly saveReply: <R extends Rpc.Any>(reply: Reply.ReplyWithContext<R>) => Effect.Effect<void, PersistenceError | MalformedMessage>;
            /**
             * Retrieves the replies for the specified requests.
             *
             * - Un-acknowledged chunk replies
             * - WithExit replies
             */
            readonly repliesFor: <R extends Rpc.Any>(requests: Iterable<Message.OutgoingRequest<R>>) => Effect.Effect<Array<Reply.Reply<R>>, PersistenceError | MalformedMessage>;
            /**
             * For locally sent messages, register a handler to process the replies.
             */
            readonly registerReplyHandler: <R extends Rpc.Any>(message: Message.OutgoingRequest<R> | Message.IncomingRequest<R>) => Effect.Effect<void>;
            /**
             * Retrieves the unprocessed messages for the specified shards.
             *
             * A message is unprocessed when:
             *
             * - Requests that have no WithExit replies
             *   - Or they have no unacknowledged chunk replies
             * - The latest AckChunk envelope
             * - All Interrupt's for unprocessed requests
             */
            readonly unprocessedMessages: (shardIds: Iterable<ShardId>) => Effect.Effect<Array<Message.Incoming<any>>, PersistenceError>;
            /**
             * Retrieves the unprocessed messages by id.
             */
            readonly unprocessedMessagesById: <R extends Rpc.Any>(messageIds: Iterable<Snowflake.Snowflake>) => Effect.Effect<Array<Message.Incoming<R>>, PersistenceError>;
            /**
             * Reset the mailbox state for the provided shards.
             */
            readonly resetShards: (shardIds: Iterable<ShardId>) => Effect.Effect<void, PersistenceError>;
            /**
             * Reset the mailbox state for the provided address.
             */
            readonly resetAddress: (address: EntityAddress) => Effect.Effect<void, PersistenceError>;
        };
        readonly encoded: Encoded;
        readonly requests: Map<string, MemoryEntry>;
        readonly requestsByPrimaryKey: Map<string, MemoryEntry>;
        readonly unprocessed: Set<Envelope.Request.Encoded>;
        readonly replyIds: Set<string>;
        readonly journal: Envelope.Envelope.Encoded[];
        readonly cursors: WeakMap<{}, number>;
    }, never, Snowflake.Generator>;
}>;
/**
 * @since 1.0.0
 * @category Memory
 */
export declare class MemoryDriver extends MemoryDriver_base {
}
/**
 * @since 1.0.0
 * @category layers
 */
export declare const layerNoop: Layer.Layer<MessageStorage>;
/**
 * @since 1.0.0
 * @category layers
 */
export declare const layerMemory: Layer.Layer<MessageStorage | MemoryDriver, never, ShardingConfig>;
export {};
//# sourceMappingURL=MessageStorage.d.ts.map