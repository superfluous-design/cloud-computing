/**
 * @since 1.0.0
 */
import * as Rpc from "@effect/rpc/Rpc";
import * as RpcClient_ from "@effect/rpc/RpcClient";
import * as RpcGroup from "@effect/rpc/RpcGroup";
import * as RpcSchema from "@effect/rpc/RpcSchema";
import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import * as Schema from "effect/Schema";
import type { Scope } from "effect/Scope";
import type { PersistenceError } from "./ClusterError.js";
import { AlreadyProcessingMessage, EntityNotAssignedToRunner, EntityNotManagedByRunner, MailboxFull, RunnerUnavailable } from "./ClusterError.js";
import * as Envelope from "./Envelope.js";
import * as Message from "./Message.js";
import * as MessageStorage from "./MessageStorage.js";
import * as Reply from "./Reply.js";
import type { RunnerAddress } from "./RunnerAddress.js";
import { ShardingConfig } from "./ShardingConfig.js";
import * as Snowflake from "./Snowflake.js";
declare const Runners_base: Context.TagClass<Runners, "@effect/cluster/Runners", {
    /**
     * Checks if a Runner is responsive.
     */
    readonly ping: (address: RunnerAddress) => Effect.Effect<void, RunnerUnavailable>;
    /**
     * Send a message locally.
     *
     * This ensures that the message hits storage before being sent to the local
     * entity.
     */
    readonly sendLocal: <R extends Rpc.Any>(options: {
        readonly message: Message.Outgoing<R>;
        readonly send: <Rpc extends Rpc.Any>(message: Message.IncomingLocal<Rpc>) => Effect.Effect<void, EntityNotManagedByRunner | EntityNotAssignedToRunner | MailboxFull | AlreadyProcessingMessage>;
        readonly simulateRemoteSerialization: boolean;
    }) => Effect.Effect<void, EntityNotManagedByRunner | EntityNotAssignedToRunner | MailboxFull | AlreadyProcessingMessage | PersistenceError>;
    /**
     * Send a message to a Runner.
     */
    readonly send: <R extends Rpc.Any>(options: {
        readonly address: RunnerAddress;
        readonly message: Message.Outgoing<R>;
    }) => Effect.Effect<void, EntityNotManagedByRunner | EntityNotAssignedToRunner | RunnerUnavailable | MailboxFull | AlreadyProcessingMessage | PersistenceError>;
    /**
     * Notify a Runner that a message is available, then read replies from storage.
     */
    readonly notify: <R extends Rpc.Any>(options: {
        readonly address: Option.Option<RunnerAddress>;
        readonly message: Message.Outgoing<R>;
        readonly discard: boolean;
    }) => Effect.Effect<void, EntityNotManagedByRunner | PersistenceError>;
    /**
     * Notify the current Runner that a message is available, then read replies from
     * storage.
     *
     * This ensures that the message hits storage before being sent to the local
     * entity.
     */
    readonly notifyLocal: <R extends Rpc.Any>(options: {
        readonly message: Message.Outgoing<R>;
        readonly notify: (options: Message.IncomingLocal<any>) => Effect.Effect<void, EntityNotManagedByRunner | EntityNotAssignedToRunner>;
        readonly discard: boolean;
    }) => Effect.Effect<void, EntityNotManagedByRunner | PersistenceError>;
}>;
/**
 * @since 1.0.0
 * @category context
 */
export declare class Runners extends Runners_base {
}
/**
 * @since 1.0.0
 * @category Constructors
 */
export declare const make: (options: Omit<Runners["Type"], "sendLocal" | "notifyLocal">) => Effect.Effect<Runners["Type"], never, MessageStorage.MessageStorage | Snowflake.Generator | ShardingConfig | Scope>;
/**
 * @since 1.0.0
 * @category No-op
 */
export declare const makeNoop: Effect.Effect<Runners["Type"], never, MessageStorage.MessageStorage | Snowflake.Generator | ShardingConfig | Scope>;
/**
 * @since 1.0.0
 * @category Layers
 */
export declare const layerNoop: Layer.Layer<Runners, never, ShardingConfig | MessageStorage.MessageStorage>;
declare const Rpcs_base: RpcGroup.RpcGroup<Rpc.Rpc<"Ping", Schema.Struct<{}>, typeof Schema.Void, typeof Schema.Never, never> | Rpc.Rpc<"Notify", Schema.Struct<{
    envelope: Schema.Union<[Schema.Struct<{
        _tag: Schema.Literal<["Request"]>;
        requestId: Schema.Schema<Snowflake.Snowflake, string>;
        address: typeof import("./EntityAddress.js").EntityAddress;
        tag: typeof Schema.String;
        payload: typeof Schema.Unknown;
        headers: Schema.Schema<import("@effect/platform/Headers").Headers, import("effect/Record").ReadonlyRecord<string, string>>;
        traceId: typeof Schema.String;
        spanId: typeof Schema.String;
        sampled: typeof Schema.Boolean;
    }>, typeof Envelope.AckChunk, typeof Envelope.Interrupt]>;
}>, typeof Schema.Void, Schema.Union<[typeof EntityNotManagedByRunner, typeof EntityNotAssignedToRunner, typeof AlreadyProcessingMessage]>, never> | Rpc.Rpc<"Effect", Schema.Struct<{
    request: Schema.Struct<{
        _tag: Schema.Literal<["Request"]>;
        requestId: Schema.Schema<Snowflake.Snowflake, string>;
        address: typeof import("./EntityAddress.js").EntityAddress;
        tag: typeof Schema.String;
        payload: typeof Schema.Unknown;
        headers: Schema.Schema<import("@effect/platform/Headers").Headers, import("effect/Record").ReadonlyRecord<string, string>>;
        traceId: typeof Schema.String;
        spanId: typeof Schema.String;
        sampled: typeof Schema.Boolean;
    }>;
    persisted: typeof Schema.Boolean;
}>, Schema.Schema<Reply.ReplyEncoded<any>, Reply.ReplyEncoded<any>, never>, Schema.Union<[typeof EntityNotManagedByRunner, typeof EntityNotAssignedToRunner, typeof MailboxFull, typeof AlreadyProcessingMessage]>, never> | Rpc.Rpc<"Stream", Schema.Struct<{
    request: Schema.Struct<{
        _tag: Schema.Literal<["Request"]>;
        requestId: Schema.Schema<Snowflake.Snowflake, string>;
        address: typeof import("./EntityAddress.js").EntityAddress;
        tag: typeof Schema.String;
        payload: typeof Schema.Unknown;
        headers: Schema.Schema<import("@effect/platform/Headers").Headers, import("effect/Record").ReadonlyRecord<string, string>>;
        traceId: typeof Schema.String;
        spanId: typeof Schema.String;
        sampled: typeof Schema.Boolean;
    }>;
    persisted: typeof Schema.Boolean;
}>, RpcSchema.Stream<Schema.Schema<Reply.ReplyEncoded<any>, Reply.ReplyEncoded<any>, never>, Schema.Union<[typeof EntityNotManagedByRunner, typeof EntityNotAssignedToRunner, typeof MailboxFull, typeof AlreadyProcessingMessage]>>, typeof Schema.Never, never> | Rpc.Rpc<"Envelope", Schema.Struct<{
    envelope: Schema.Union<[typeof Envelope.AckChunk, typeof Envelope.Interrupt]>;
    persisted: typeof Schema.Boolean;
}>, typeof Schema.Void, Schema.Union<[typeof EntityNotManagedByRunner, typeof EntityNotAssignedToRunner, typeof MailboxFull, typeof AlreadyProcessingMessage]>, never>>;
/**
 * @since 1.0.0
 * @category Rpcs
 */
export declare class Rpcs extends Rpcs_base {
}
/**
 * @since 1.0.0
 * @category Rpcs
 */
export interface RpcClient extends RpcClient_.FromGroup<typeof Rpcs> {
}
/**
 * @since 1.0.0
 * @category Rpcs
 */
export declare const makeRpcClient: Effect.Effect<RpcClient, never, RpcClient_.Protocol | Scope>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const makeRpc: Effect.Effect<Runners["Type"], never, Scope | RpcClientProtocol | MessageStorage.MessageStorage | Snowflake.Generator | ShardingConfig>;
/**
 * @since 1.0.0
 * @category Layers
 */
export declare const layerRpc: Layer.Layer<Runners, never, MessageStorage.MessageStorage | RpcClientProtocol | ShardingConfig>;
declare const RpcClientProtocol_base: Context.TagClass<RpcClientProtocol, "@effect/cluster/Runners/RpcClientProtocol", (address: RunnerAddress) => Effect.Effect<RpcClient_.Protocol["Type"], never, Scope>>;
/**
 * @since 1.0.0
 * @category Client
 */
export declare class RpcClientProtocol extends RpcClientProtocol_base {
}
export {};
//# sourceMappingURL=Runners.d.ts.map