import * as Effect from "effect/Effect";
import * as Schema from "effect/Schema";
import { EntityAddress } from "./EntityAddress.js";
import { RunnerAddress } from "./RunnerAddress.js";
/**
 * @since 1.0.0
 * @category Symbols
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category Symbols
 */
export type TypeId = typeof TypeId;
declare const EntityNotAssignedToRunner_base: Schema.TaggedErrorClass<EntityNotAssignedToRunner, "EntityNotAssignedToRunner", {
    readonly _tag: Schema.tag<"EntityNotAssignedToRunner">;
} & {
    address: typeof EntityAddress;
}>;
/**
 * Represents an error that occurs when a Runner receives a message for an entity
 * that it is not assigned to it.
 *
 * @since 1.0.0
 * @category errors
 */
export declare class EntityNotAssignedToRunner extends EntityNotAssignedToRunner_base {
    /**
     * @since 1.0.0
     */
    readonly [TypeId]: symbol;
    /**
     * @since 1.0.0
     */
    static is(u: unknown): u is EntityNotAssignedToRunner;
}
declare const EntityNotManagedByRunner_base: Schema.TaggedErrorClass<EntityNotManagedByRunner, "EntityNotManagedByRunner", {
    readonly _tag: Schema.tag<"EntityNotManagedByRunner">;
} & {
    address: typeof EntityAddress;
}>;
/**
 * Represents an error that occurs when a Runner receives a message for an entity
 * that it is not responsible for managing.
 *
 * @since 1.0.0
 * @category errors
 */
export declare class EntityNotManagedByRunner extends EntityNotManagedByRunner_base {
    /**
     * @since 1.0.0
     */
    readonly [TypeId]: symbol;
    /**
     * @since 1.0.0
     */
    static is(u: unknown): u is EntityNotManagedByRunner;
}
declare const MalformedMessage_base: Schema.TaggedErrorClass<MalformedMessage, "MalformedMessage", {
    readonly _tag: Schema.tag<"MalformedMessage">;
} & {
    cause: typeof Schema.Defect;
}>;
/**
 * Represents an error that occurs when a message fails to be properly
 * deserialized by an entity.
 *
 * @since 1.0.0
 * @category errors
 */
export declare class MalformedMessage extends MalformedMessage_base {
    /**
     * @since 1.0.0
     */
    readonly [TypeId]: symbol;
    /**
     * @since 1.0.0
     */
    static is(u: unknown): u is MalformedMessage;
    /**
     * @since 1.0.0
     */
    static refail: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, MalformedMessage, R>;
}
declare const PersistenceError_base: Schema.TaggedErrorClass<PersistenceError, "PersistenceError", {
    readonly _tag: Schema.tag<"PersistenceError">;
} & {
    cause: typeof Schema.Defect;
}>;
/**
 * Represents an error that occurs when a message fails to be persisted into
 * cluster's mailbox storage.
 *
 * @since 1.0.0
 * @category errors
 */
export declare class PersistenceError extends PersistenceError_base {
    /**
     * @since 1.0.0
     */
    readonly [TypeId]: symbol;
    /**
     * @since 1.0.0
     */
    static refail<A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, PersistenceError, R>;
}
declare const RunnerNotRegistered_base: Schema.TaggedErrorClass<RunnerNotRegistered, "RunnerNotRegistered", {
    readonly _tag: Schema.tag<"RunnerNotRegistered">;
} & {
    address: typeof RunnerAddress;
}>;
/**
 * Represents an error that occurs when a Runner is not registered with the shard
 * manager.
 *
 * @since 1.0.0
 * @category errors
 */
export declare class RunnerNotRegistered extends RunnerNotRegistered_base {
    /**
     * @since 1.0.0
     */
    readonly [TypeId]: symbol;
}
declare const RunnerUnavailable_base: Schema.TaggedErrorClass<RunnerUnavailable, "RunnerUnavailable", {
    readonly _tag: Schema.tag<"RunnerUnavailable">;
} & {
    address: typeof RunnerAddress;
}>;
/**
 * Represents an error that occurs when a Runner is unresponsive.
 *
 * @since 1.0.0
 * @category errors
 */
export declare class RunnerUnavailable extends RunnerUnavailable_base {
    /**
     * @since 1.0.0
     */
    readonly [TypeId]: symbol;
    /**
     * @since 1.0.0
     */
    static is(u: unknown): u is RunnerUnavailable;
}
declare const MailboxFull_base: Schema.TaggedErrorClass<MailboxFull, "MailboxFull", {
    readonly _tag: Schema.tag<"MailboxFull">;
} & {
    address: typeof EntityAddress;
}>;
/**
 * Represents an error that occurs when the entities mailbox is full.
 *
 * @since 1.0.0
 * @category errors
 */
export declare class MailboxFull extends MailboxFull_base {
    /**
     * @since 1.0.0
     */
    readonly [TypeId]: symbol;
    /**
     * @since 1.0.0
     */
    static is(u: unknown): u is MailboxFull;
}
declare const AlreadyProcessingMessage_base: Schema.TaggedErrorClass<AlreadyProcessingMessage, "AlreadyProcessingMessage", {
    readonly _tag: Schema.tag<"AlreadyProcessingMessage">;
} & {
    envelopeId: Schema.Schema<import("./Snowflake.js").Snowflake, string, never>;
    address: typeof EntityAddress;
}>;
/**
 * Represents an error that occurs when the entity is already processing a
 * request.
 *
 * @since 1.0.0
 * @category errors
 */
export declare class AlreadyProcessingMessage extends AlreadyProcessingMessage_base {
    /**
     * @since 1.0.0
     */
    readonly [TypeId]: symbol;
    /**
     * @since 1.0.0
     */
    static is(u: unknown): u is AlreadyProcessingMessage;
}
export {};
//# sourceMappingURL=ClusterError.d.ts.map